"""
question_bank.py - Banco de preguntas para BD Big Data Quiz
Total: 610 preguntas

Categorías:
- Categorías 1-9: Preguntas de MongoDB (520 preguntas)
- Categoría 10: Test 1 - Fundamentos de Datos (10 preguntas)
- Categoría 11: Test 2 - NoSQL y MongoDB (10 preguntas)
- Categoría 12: Test 3 - MongoDB CRUD (10 preguntas)
- Categoría 13: Test 4 - Agregación MongoDB (10 preguntas)
- Categoría 14: Test 5 - Backup, Índices, Replicación y Sharding (10 preguntas)
- Categoría 15: Test 6 - Drivers MongoDB (10 preguntas)
- Categoría 16: Test 7 - Cassandra (10 preguntas)
- Categoría 17: Test 8 - Grafo (Neo4j) (10 preguntas)
- Categoría 18: Test 9 - Redis (10 preguntas)
"""

# Categoría 1: Instalación y Entorno (30 preguntas) ✅
# Categoría 2: CRUD - Create (60 preguntas) ✅
# Categoría 3: CRUD - Read (80 preguntas) ✅
# Categoría 4: CRUD - Update (60 preguntas) ✅

QUESTIONS_BATCH_1 = [
    # ==================== CATEGORÍA 1: INSTALACIÓN Y ENTORNO ====================
    # Preguntas 1-30

    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué tipo de base de datos es MongoDB?",
        "option_a": "Base de datos relacional",
        "option_b": "Base de datos orientada a documentos NoSQL",
        "option_c": "Base de datos de grafos",
        "option_d": "Base de datos en memoria",
        "option_e": "Base de datos de columnas anchas",
        "correct_answer": "b",
        "explanation": "MongoDB es una base de datos NoSQL orientada a documentos que almacena datos en formato BSON (Binary JSON). No usa tablas y relaciones como las bases de datos SQL tradicionales, sino colecciones de documentos flexibles.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el formato de almacenamiento de documentos en MongoDB?",
        "option_a": "XML",
        "option_b": "CSV",
        "option_c": "BSON (Binary JSON)",
        "option_d": "YAML",
        "option_e": "Plain Text",
        "correct_answer": "c",
        "explanation": "MongoDB almacena documentos en formato BSON (Binary JSON), que es una representación binaria de JSON. BSON extiende JSON con tipos de datos adicionales como Date, ObjectId, y Binary, y permite un almacenamiento más eficiente.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es una colección en MongoDB?",
        "option_a": "Un grupo de bases de datos",
        "option_b": "Un conjunto de documentos similar a una tabla en SQL",
        "option_c": "Un índice para búsquedas rápidas",
        "option_d": "Un tipo de dato especial",
        "option_e": "Una función de agregación",
        "correct_answer": "b",
        "explanation": "Una colección en MongoDB es equivalente a una tabla en bases de datos relacionales. Agrupa documentos relacionados, pero a diferencia de las tablas SQL, los documentos en una colección pueden tener estructuras diferentes (esquema flexible).",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la ventaja principal del esquema flexible de MongoDB?",
        "option_a": "Mayor velocidad de consulta",
        "option_b": "Menor uso de memoria",
        "option_c": "No requiere definir estructura fija antes de insertar datos",
        "option_d": "Mejor seguridad de datos",
        "option_e": "Compatibilidad con SQL estándar",
        "correct_answer": "c",
        "explanation": "El esquema flexible de MongoDB permite insertar documentos sin definir previamente su estructura. Cada documento en una colección puede tener campos diferentes, facilitando la evolución del modelo de datos sin necesidad de migraciones complejas.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es MongoDB Atlas?",
        "option_a": "Un cliente de escritorio para MongoDB",
        "option_b": "Una herramienta de visualización de datos",
        "option_c": "Un servicio de MongoDB en la nube totalmente gestionado",
        "option_d": "Un lenguaje de consulta para MongoDB",
        "option_e": "Una librería de Python para MongoDB",
        "correct_answer": "c",
        "explanation": "MongoDB Atlas es el servicio de base de datos como servicio (DBaaS) en la nube de MongoDB. Proporciona despliegue, gestión y escalado automático de clusters MongoDB en proveedores cloud como AWS, Azure y Google Cloud.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué puerto utiliza MongoDB por defecto?",
        "option_a": "3306",
        "option_b": "5432",
        "option_c": "27017",
        "option_d": "8080",
        "option_e": "27018",
        "correct_answer": "c",
        "explanation": "MongoDB utiliza el puerto 27017 por defecto para las conexiones de clientes. El puerto 27018 se usa típicamente para el daemon mongos en configuraciones de sharding, y 27019 para el config server.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué comando se usa para iniciar el shell de MongoDB?",
        "option_a": "mongodb",
        "option_b": "mongo",
        "option_c": "mongosh",
        "option_d": "start-mongo",
        "option_e": "db.start()",
        "correct_answer": "c",
        "explanation": "El comando 'mongosh' (MongoDB Shell) es el shell interactivo moderno de MongoDB. Anteriormente se usaba 'mongo', pero desde la versión 5.0+ se recomienda usar mongosh que ofrece mejor funcionalidad y compatibilidad con JavaScript moderno.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra todas las bases de datos en MongoDB?",
        "option_a": "db.showDatabases()",
        "option_b": "show databases",
        "option_c": "list databases",
        "option_d": "db.getDatabases()",
        "option_e": "display dbs",
        "correct_answer": "b",
        "explanation": "El comando 'show databases' o su alias 'show dbs' muestra todas las bases de datos en el servidor MongoDB. Es un comando del shell, no una función de JavaScript. También existe 'db.adminCommand({listDatabases: 1})' para uso programático.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se selecciona o crea una base de datos en MongoDB?",
        "option_a": "CREATE DATABASE nombre",
        "option_b": "use nombre",
        "option_c": "db.create('nombre')",
        "option_d": "select nombre",
        "option_e": "new database nombre",
        "correct_answer": "b",
        "explanation": "El comando 'use nombre' cambia a una base de datos. Si la base de datos no existe, MongoDB la creará automáticamente cuando insertes el primer documento. No es necesario un comando CREATE DATABASE explícito.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra la base de datos actual en uso?",
        "option_a": "show current",
        "option_b": "db.getName()",
        "option_c": "db",
        "option_d": "current db",
        "option_e": "which database",
        "correct_answer": "c",
        "explanation": "El comando 'db' en el shell de MongoDB muestra el nombre de la base de datos actualmente seleccionada. Es la forma más rápida de verificar en qué base de datos estás trabajando.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se muestran todas las colecciones de la base de datos actual?",
        "option_a": "list collections",
        "option_b": "show collections",
        "option_c": "db.showCollections()",
        "option_d": "display tables",
        "option_e": "get collections",
        "correct_answer": "b",
        "explanation": "El comando 'show collections' muestra todas las colecciones en la base de datos actual. Alternativamente, puedes usar 'show tables' (que es un alias) o 'db.getCollectionNames()' para obtener un array con los nombres.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es un documento en MongoDB?",
        "option_a": "Un archivo PDF almacenado en la base de datos",
        "option_b": "Una fila en una tabla",
        "option_c": "Un registro en formato BSON con pares clave-valor",
        "option_d": "Un esquema de validación",
        "option_e": "Una función JavaScript",
        "correct_answer": "c",
        "explanation": "Un documento en MongoDB es una estructura de datos compuesta por pares clave-valor, similar a objetos JSON. Es la unidad básica de datos en MongoDB, equivalente a una fila en SQL, pero con estructura flexible y capacidad de anidar datos.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el _id en MongoDB?",
        "option_a": "Un índice secundario opcional",
        "option_b": "El campo de clave primaria único y obligatorio para cada documento",
        "option_c": "Un identificador de colección",
        "option_d": "Una función para generar IDs",
        "option_e": "Un campo de auditoría",
        "correct_answer": "b",
        "explanation": "El campo _id es la clave primaria de cada documento en MongoDB. Es obligatorio, único dentro de una colección, e inmutable. Si no se proporciona al insertar, MongoDB genera automáticamente un ObjectId de 12 bytes.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la estructura de un ObjectId en MongoDB?",
        "option_a": "UUID estándar de 36 caracteres",
        "option_b": "Entero autoincremental",
        "option_c": "Valor hexadecimal de 24 caracteres (12 bytes)",
        "option_d": "Hash MD5",
        "option_e": "GUID de Windows",
        "correct_answer": "c",
        "explanation": "Un ObjectId es un valor BSON de 12 bytes que se representa como una cadena hexadecimal de 24 caracteres. Incluye timestamp (4 bytes), identificador de máquina (5 bytes), y un contador incremental (3 bytes), lo que garantiza su unicidad.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué ventaja tiene MongoDB sobre bases de datos SQL tradicionales en términos de escalabilidad?",
        "option_a": "Solo puede escalarse verticalmente",
        "option_b": "Escalabilidad horizontal nativa mediante sharding",
        "option_c": "No soporta escalabilidad",
        "option_d": "Requiere hardware especializado para escalar",
        "option_e": "Solo funciona en un único servidor",
        "correct_answer": "b",
        "explanation": "MongoDB soporta escalabilidad horizontal mediante sharding, distribuyendo datos automáticamente entre múltiples servidores. Esto permite manejar grandes volúmenes de datos y tráfico sin las limitaciones de escalado vertical de bases de datos SQL tradicionales.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué herramienta de línea de comandos se usa para importar datos JSON a MongoDB?",
        "option_a": "mongodump",
        "option_b": "mongoimport",
        "option_c": "mongorestore",
        "option_d": "mongoexport",
        "option_e": "mongoload",
        "correct_answer": "b",
        "explanation": "mongoimport es la herramienta para importar datos desde archivos JSON, CSV o TSV a MongoDB. Ejemplo: 'mongoimport --db basedatos --collection coleccion --file datos.json'. mongodump/mongorestore se usan para backups BSON.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para exportar una colección completa a JSON?",
        "option_a": "mongodump --db basedatos --collection coleccion",
        "option_b": "mongoexport --db basedatos --collection coleccion --out archivo.json",
        "option_c": "db.coleccion.export('archivo.json')",
        "option_d": "mongosave --collection coleccion --file archivo.json",
        "option_e": "export --from coleccion --to archivo.json",
        "correct_answer": "b",
        "explanation": "mongoexport se usa para exportar datos en formato JSON o CSV. La sintaxis incluye --db para la base de datos, --collection para la colección, y --out para el archivo de salida. mongodump exporta en formato BSON para backups.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es un replica set en MongoDB?",
        "option_a": "Un conjunto de colecciones duplicadas",
        "option_b": "Un grupo de instancias MongoDB que mantienen el mismo conjunto de datos para alta disponibilidad",
        "option_c": "Una técnica de indexación",
        "option_d": "Un backup automático",
        "option_e": "Un tipo de consulta optimizada",
        "correct_answer": "b",
        "explanation": "Un replica set es un grupo de procesos mongod que mantienen el mismo conjunto de datos. Proporciona redundancia y alta disponibilidad mediante replicación automática. Incluye un nodo primario (escrituras) y múltiples secundarios (réplicas).",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia principal entre MongoDB y bases de datos SQL?",
        "option_a": "MongoDB no soporta consultas complejas",
        "option_b": "MongoDB usa esquema flexible y no requiere JOINs tradicionales",
        "option_c": "SQL es más rápido para todos los casos de uso",
        "option_d": "MongoDB no puede almacenar datos estructurados",
        "option_e": "SQL no soporta índices",
        "correct_answer": "b",
        "explanation": "La diferencia clave es que MongoDB usa un modelo de datos basado en documentos con esquema flexible, mientras SQL usa tablas con esquema fijo. MongoDB evita JOINs costosos mediante documentos embebidos y referencias, optimizando para lecturas.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuándo NO es recomendable usar MongoDB?",
        "option_a": "Cuando necesitas esquema flexible",
        "option_b": "Cuando requieres transacciones ACID complejas entre múltiples tablas relacionales",
        "option_c": "Cuando trabajas con datos JSON",
        "option_d": "Cuando necesitas escalabilidad horizontal",
        "option_e": "Cuando trabajas con documentos anidados",
        "correct_answer": "b",
        "explanation": "MongoDB no es ideal para aplicaciones que requieren transacciones ACID complejas entre múltiples entidades altamente relacionadas con muchos JOINs. Aunque MongoDB 4.0+ soporta transacciones multi-documento, bases de datos SQL tradicionales siguen siendo mejores para estos casos.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el Write Concern en MongoDB?",
        "option_a": "Un nivel de logging de errores",
        "option_b": "El nivel de confirmación requerido para operaciones de escritura",
        "option_c": "Un tipo de índice",
        "option_d": "Una validación de esquema",
        "option_e": "Un patrón de diseño",
        "correct_answer": "b",
        "explanation": "Write Concern es el nivel de confirmación requerido de MongoDB para operaciones de escritura. Define cuántos nodos del replica set deben confirmar la escritura antes de considerarla exitosa. Valores comunes: {w: 1} (solo primario), {w: 'majority'} (mayoría).",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el Read Concern en MongoDB?",
        "option_a": "La cantidad de documentos que se pueden leer",
        "option_b": "El nivel de garantía sobre la durabilidad de los datos leídos",
        "option_c": "El tiempo máximo de espera para lecturas",
        "option_d": "Un filtro de lectura",
        "option_e": "Una validación de datos",
        "correct_answer": "b",
        "explanation": "Read Concern controla el nivel de consistencia de los datos leídos en operaciones de consulta. Niveles incluyen: 'local' (datos más recientes del nodo), 'majority' (datos reconocidos por la mayoría), 'linearizable' (garantía de lectura más fuerte).",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se elimina una base de datos completa en MongoDB?",
        "option_a": "DROP DATABASE nombre",
        "option_b": "db.dropDatabase()",
        "option_c": "delete database nombre",
        "option_d": "db.remove()",
        "option_e": "destroy db nombre",
        "correct_answer": "b",
        "explanation": "El método db.dropDatabase() elimina la base de datos actual y todas sus colecciones. Primero debes usar 'use nombre_bd' para seleccionar la base de datos, luego ejecutar db.dropDatabase(). Esta operación es irreversible.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra las estadísticas de una base de datos?",
        "option_a": "db.status()",
        "option_b": "db.stats()",
        "option_c": "show stats",
        "option_d": "db.info()",
        "option_e": "database statistics",
        "correct_answer": "b",
        "explanation": "db.stats() devuelve estadísticas sobre la base de datos actual, incluyendo número de colecciones, vistas, objetos, tamaño promedio de documentos, tamaño de datos, índices, etc. Útil para monitoreo y optimización.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es WiredTiger en MongoDB?",
        "option_a": "Una herramienta de migración de datos",
        "option_b": "El motor de almacenamiento por defecto desde MongoDB 3.2",
        "option_c": "Un cliente GUI para MongoDB",
        "option_d": "Un protocolo de red",
        "option_e": "Una librería de validación",
        "correct_answer": "b",
        "explanation": "WiredTiger es el motor de almacenamiento por defecto de MongoDB desde la versión 3.2. Proporciona compresión de datos, concurrencia a nivel de documento, y mejor rendimiento que el motor MMAPv1 anterior. Soporta snapshots y checkpoints.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué formato de compresión usa WiredTiger por defecto?",
        "option_a": "gzip",
        "option_b": "snappy",
        "option_c": "lz4",
        "option_d": "zlib",
        "option_e": "bzip2",
        "correct_answer": "b",
        "explanation": "WiredTiger usa Snappy como algoritmo de compresión por defecto para colecciones. Snappy ofrece un buen balance entre velocidad y ratio de compresión. Para índices, usa compresión prefix. También soporta zlib y zstd para mayor compresión.",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se verifica la versión de MongoDB instalada?",
        "option_a": "mongodb --version",
        "option_b": "mongod --version",
        "option_c": "mongo --ver",
        "option_d": "show version",
        "option_e": "db.getVersion()",
        "correct_answer": "b",
        "explanation": "El comando 'mongod --version' muestra la versión del servidor MongoDB instalado. En el shell, puedes usar 'db.version()' o 'mongosh --version' para ver la versión del shell. También 'db.serverBuildInfo()' da información detallada.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el oplog en MongoDB?",
        "option_a": "Un archivo de log de errores",
        "option_b": "Una colección especial que registra todas las operaciones de escritura para replicación",
        "option_c": "Una herramienta de monitoreo",
        "option_d": "Un índice automático",
        "option_e": "Un comando de optimización",
        "correct_answer": "b",
        "explanation": "El oplog (operations log) es una colección capped especial que registra todas las operaciones que modifican datos. Los nodos secundarios de un replica set leen el oplog del primario para replicar los cambios. Es circular y tiene tamaño fijo.",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué puerto usa MongoDB Compass por defecto para conectarse?",
        "option_a": "27016",
        "option_b": "27017",
        "option_c": "28017",
        "option_d": "8080",
        "option_e": "3000",
        "correct_answer": "b",
        "explanation": "MongoDB Compass, la GUI oficial de MongoDB, se conecta por defecto al puerto 27017, que es el puerto estándar del servidor MongoDB. Compass proporciona una interfaz visual para explorar datos, crear consultas y analizar rendimiento.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el sharding en MongoDB?",
        "option_a": "Un método de backup incremental",
        "option_b": "Un método de particionamiento horizontal de datos entre múltiples máquinas",
        "option_c": "Una técnica de indexación",
        "option_d": "Un tipo de validación de datos",
        "option_e": "Un algoritmo de compresión",
        "correct_answer": "b",
        "explanation": "Sharding es el método de MongoDB para distribuir datos horizontalmente entre múltiples máquinas (shards). Permite escalar más allá de los límites de un solo servidor dividiendo la colección en chunks distribuidos según una shard key.",
        "difficulty": "medium"
    },

    # ==================== CATEGORÍA 2: CRUD - CREATE ====================
    # Preguntas 31-50 (20 de 60 totales)

    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para insertar un documento en MongoDB?",
        "option_a": "db.coleccion.add({campo: 'valor'})",
        "option_b": "db.coleccion.insertOne({campo: 'valor'})",
        "option_c": "db.coleccion.create({campo: 'valor'})",
        "option_d": "INSERT INTO coleccion VALUES ({campo: 'valor'})",
        "option_e": "db.coleccion.put({campo: 'valor'})",
        "correct_answer": "b",
        "explanation": "db.coleccion.insertOne({documento}) es el método correcto para insertar un único documento en MongoDB. Retorna un objeto con el _id del documento insertado. Si el documento no tiene _id, MongoDB genera uno automáticamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se insertan múltiples documentos a la vez en MongoDB?",
        "option_a": "db.coleccion.insertOne([{}, {}])",
        "option_b": "db.coleccion.insertMany([{}, {}])",
        "option_c": "db.coleccion.insertAll([{}, {}])",
        "option_d": "db.coleccion.bulkInsert([{}, {}])",
        "option_e": "db.coleccion.addMany([{}, {}])",
        "correct_answer": "b",
        "explanation": "db.coleccion.insertMany([array_de_documentos]) inserta múltiples documentos en una sola operación. Es más eficiente que múltiples insertOne(). Retorna un objeto con los _id de todos los documentos insertados.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para el dataset infovuelos_limpio, ¿cuál es la sintaxis correcta para insertar un nuevo vuelo?",
        "option_a": "db.infovuelos.insert({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_b": "db.infovuelos_limpio.insertOne({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_c": "INSERT INTO infovuelos_limpio VALUES ('Madrid', 'Barcelona', 150)",
        "option_d": "db.infovuelos_limpio.add({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_e": "db.infovuelos_limpio.create({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "correct_answer": "b",
        "explanation": "db.infovuelos_limpio.insertOne({documento}) es la sintaxis correcta. Usa el nombre exacto de la colección (infovuelos_limpio) y el método insertOne() con un objeto conteniendo los campos del vuelo. El método insert() está deprecado.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué sucede si intentas insertar un documento con un _id que ya existe?",
        "option_a": "Se actualiza el documento existente",
        "option_b": "Se genera un error de duplicate key",
        "option_c": "Se ignora silenciosamente",
        "option_d": "Se crea un nuevo documento con _id diferente",
        "option_e": "Se elimina el documento anterior",
        "correct_answer": "b",
        "explanation": "MongoDB genera un error 'E11000 duplicate key error' si intentas insertar un documento con un _id que ya existe en la colección. El _id debe ser único. Para actualizar, debes usar updateOne() o replaceOne().",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para insertar un listing en la colección listings_limpio con campos anidados, ¿cuál es correcto?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Apartamento', ubicacion: {ciudad: 'Madrid', barrio: 'Centro'}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Apartamento', ubicacion.ciudad: 'Madrid'})",
        "option_c": "db.listings_limpio.insertOne([nombre: 'Apartamento', ubicacion: [ciudad: 'Madrid']])",
        "option_d": "INSERT INTO listings_limpio (nombre, ubicacion) VALUES ('Apartamento', 'Madrid, Centro')",
        "option_e": "db.listings_limpio.add(nombre='Apartamento', ubicacion={'Madrid', 'Centro'})",
        "correct_answer": "a",
        "explanation": "MongoDB permite documentos anidados usando objetos JavaScript. La sintaxis correcta es {campo: {subcampo: valor}}. Esto crea una estructura jerárquica donde ubicacion es un objeto con propiedades ciudad y barrio.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con un array de valores?",
        "option_a": "db.coleccion.insertOne({tags: ['tag1', 'tag2', 'tag3']})",
        "option_b": "db.coleccion.insertOne({tags: 'tag1, tag2, tag3'})",
        "option_c": "db.coleccion.insertOne({tags: {0: 'tag1', 1: 'tag2'}})",
        "option_d": "db.coleccion.insertOne({tags: SET['tag1', 'tag2']})",
        "option_e": "db.coleccion.insertOne({tags: ARRAY('tag1', 'tag2')})",
        "correct_answer": "a",
        "explanation": "En MongoDB, los arrays se insertan usando la sintaxis de arrays JavaScript: [valor1, valor2, ...]. MongoDB soporta arrays nativamente como tipo de dato BSON, permitiendo almacenar listas de valores en un solo campo.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cuál es la diferencia entre insert() e insertOne()?",
        "option_a": "No hay diferencia, son sinónimos",
        "option_b": "insertOne() es el método moderno recomendado; insert() está deprecado",
        "option_c": "insert() es más rápido",
        "option_d": "insertOne() solo funciona en MongoDB Atlas",
        "option_e": "insert() requiere permisos de administrador",
        "correct_answer": "b",
        "explanation": "insertOne() e insertMany() son los métodos modernos introducidos en MongoDB 3.2+. El método insert() está deprecado. Los métodos nuevos tienen mejor manejo de errores, retornan objetos más consistentes y son más explícitos en su propósito.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento especificando un _id personalizado?",
        "option_a": "db.coleccion.insertOne({_id: 'mi_id_custom', nombre: 'valor'})",
        "option_b": "db.coleccion.insertOne({nombre: 'valor'}).setId('mi_id_custom')",
        "option_c": "db.coleccion.insertOne({nombre: 'valor'}, {_id: 'mi_id_custom'})",
        "option_d": "No es posible, MongoDB siempre genera el _id",
        "option_e": "db.coleccion.insertWithId('mi_id_custom', {nombre: 'valor'})",
        "correct_answer": "a",
        "explanation": "Puedes especificar tu propio _id incluyéndolo en el documento: {_id: valor, ...}. El _id puede ser cualquier tipo BSON excepto arrays. Si no proporcionas _id, MongoDB genera un ObjectId automáticamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para el dataset data_act_01_limpio, ¿cómo insertarías un documento con fecha actual?",
        "option_a": "db.data_act_01_limpio.insertOne({fecha: Date.now()})",
        "option_b": "db.data_act_01_limpio.insertOne({fecha: new Date()})",
        "option_c": "db.data_act_01_limpio.insertOne({fecha: CURRENT_TIMESTAMP})",
        "option_d": "db.data_act_01_limpio.insertOne({fecha: today()})",
        "option_e": "db.data_act_01_limpio.insertOne({fecha: '2024-01-21'})",
        "correct_answer": "b",
        "explanation": "new Date() crea un objeto Date de JavaScript que MongoDB almacena como tipo BSON Date. Date.now() retorna un timestamp numérico (no recomendado). Las cadenas de texto no son fechas tipadas. BSON Date permite consultas y operaciones temporales eficientes.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué retorna el método insertOne() tras una inserción exitosa?",
        "option_a": "El documento completo insertado",
        "option_b": "Un objeto con acknowledged: true y insertedId con el _id",
        "option_c": "El número de documentos insertados",
        "option_d": "true o false",
        "option_e": "Nada (void)",
        "correct_answer": "b",
        "explanation": "insertOne() retorna un objeto con dos propiedades: 'acknowledged' (boolean indicando si la operación fue reconocida) y 'insertedId' (el _id del documento insertado). Ejemplo: {acknowledged: true, insertedId: ObjectId('...')}",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué retorna insertMany() cuando inserta 5 documentos exitosamente?",
        "option_a": "Un array con los 5 documentos",
        "option_b": "Un objeto con acknowledged: true e insertedIds: {0: id1, 1: id2, ...}",
        "option_c": "El número 5",
        "option_d": "Los ObjectIds separados por comas",
        "option_e": "true",
        "correct_answer": "b",
        "explanation": "insertMany() retorna un objeto con 'acknowledged' (boolean) e 'insertedIds' (un objeto/mapa donde las keys son índices y los valores son los _id insertados). Ejemplo: {acknowledged: true, insertedIds: {0: ObjectId('...'), 1: ObjectId('...')}}",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es la opción 'ordered' en insertMany()?",
        "option_a": "Ordena los documentos alfabéticamente antes de insertar",
        "option_b": "Controla si la inserción se detiene en el primer error (true) o continúa (false)",
        "option_c": "Define el orden de los índices",
        "option_d": "Ordena por _id automáticamente",
        "option_e": "Requiere que los documentos estén ordenados por timestamp",
        "correct_answer": "b",
        "explanation": "La opción 'ordered: true' (default) detiene la inserción al primer error. Con 'ordered: false', MongoDB intenta insertar todos los documentos, omitiendo los que causan error. Útil para inserciones masivas donde algunos documentos pueden fallar.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples vuelos en infovuelos_limpio con ordered: false?",
        "option_a": "db.infovuelos_limpio.insertMany([{...}, {...}], {ordered: false})",
        "option_b": "db.infovuelos_limpio.insertMany([{...}, {...}], ordered=false)",
        "option_c": "db.infovuelos_limpio.insertMany([{...}, {...}]).unordered()",
        "option_d": "db.infovuelos_limpio.bulkInsert([{...}, {...}], false)",
        "option_e": "db.infovuelos_limpio.insertMany([{...}, {...}], {mode: 'unordered'})",
        "correct_answer": "a",
        "explanation": "La sintaxis correcta es insertMany(array_documentos, opciones). Las opciones se pasan como segundo parámetro en un objeto: {ordered: false}. Esto hace que MongoDB intente insertar todos los documentos incluso si algunos fallan.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite de tamaño máximo de un documento en MongoDB?",
        "option_a": "1 MB",
        "option_b": "8 MB",
        "option_c": "16 MB",
        "option_d": "32 MB",
        "option_e": "No hay límite",
        "correct_answer": "c",
        "explanation": "MongoDB tiene un límite de 16 MB por documento. Este límite previene uso excesivo de memoria y ancho de banda. Para datos más grandes, usa GridFS que divide archivos en chunks. El límite se aplica al documento BSON completo.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con un campo que contiene un objeto complejo en listings_limpio?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: {habitaciones: 3, banos: 2, amenidades: ['wifi', 'parking']}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Casa', detalles.habitaciones: 3, detalles.banos: 2})",
        "option_c": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: JSON.stringify({habitaciones: 3})})",
        "option_d": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: OBJECT(habitaciones=3, banos=2)})",
        "option_e": "db.listings_limpio.insertOne(nombre='Casa', detalles={habitaciones:3})",
        "correct_answer": "a",
        "explanation": "MongoDB soporta objetos anidados arbitrariamente complejos. Puedes incluir objetos dentro de objetos, arrays dentro de objetos, etc. La sintaxis es JavaScript estándar. No necesitas stringify, MongoDB maneja la estructura nativa.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede si insertas un documento sin especificar ningún campo?",
        "option_a": "MongoDB rechaza el documento vacío",
        "option_b": "Se inserta un documento con solo el _id",
        "option_c": "Se genera un error de validación",
        "option_d": "Se crea un documento con campos null",
        "option_e": "La colección se elimina",
        "correct_answer": "b",
        "explanation": "MongoDB permite insertar documentos vacíos: db.coleccion.insertOne({}). Se creará un documento con solo el campo _id generado automáticamente. Esto es válido aunque poco práctico en la mayoría de casos de uso.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con WriteConcern 'majority' para garantizar replicación?",
        "option_a": "db.coleccion.insertOne({...}, {w: 'majority'})",
        "option_b": "db.coleccion.insertOne({...}, {writeConcern: 'majority'})",
        "option_c": "db.coleccion.insertOne({...}, {replicate: 'all'})",
        "option_d": "db.coleccion.insertOne({...}).majority()",
        "option_e": "db.coleccion.insertOne({...}, {durability: 'high'})",
        "correct_answer": "a",
        "explanation": "El WriteConcern se especifica como opción con la propiedad 'w'. {w: 'majority'} espera confirmación de la mayoría de nodos del replica set antes de retornar. Aumenta durabilidad pero reduce performance. {w: 1} solo espera al nodo primario (default).",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'bulk write' en MongoDB?",
        "option_a": "Una operación de escritura masiva con múltiples tipos de operaciones (insert, update, delete) en una sola llamada",
        "option_b": "Un método para escribir archivos grandes",
        "option_c": "Una técnica de compresión de datos",
        "option_d": "Un tipo especial de índice",
        "option_e": "Una herramienta de backup",
        "correct_answer": "a",
        "explanation": "bulkWrite() permite ejecutar múltiples operaciones (insertOne, updateOne, deleteOne, etc.) en una sola llamada al servidor. Es más eficiente que múltiples operaciones individuales. Soporta modo ordenado y no ordenado.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con un campo de tipo NumberDecimal?",
        "option_a": "db.data_act_01_limpio.insertOne({precio: 99.99})",
        "option_b": "db.data_act_01_limpio.insertOne({precio: NumberDecimal('99.99')})",
        "option_c": "db.data_act_01_limpio.insertOne({precio: new Decimal(99.99)})",
        "option_d": "db.data_act_01_limpio.insertOne({precio: DECIMAL(99.99)})",
        "option_e": "db.data_act_01_limpio.insertOne({precio: parseDecimal('99.99')})",
        "correct_answer": "b",
        "explanation": "NumberDecimal('string') es el constructor para el tipo Decimal128 de BSON, diseñado para cálculos financieros precisos. Números normales se almacenan como Double (64-bit) que pueden tener imprecisiones. NumberDecimal evita errores de redondeo.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué ventaja tiene usar insertMany() sobre múltiples insertOne()?",
        "option_a": "insertMany() valida los datos automáticamente",
        "option_b": "insertMany() es más eficiente al enviar una sola solicitud al servidor",
        "option_c": "insertMany() crea índices automáticamente",
        "option_d": "insertMany() no requiere permisos especiales",
        "option_e": "insertMany() soporta transacciones implícitas",
        "correct_answer": "b",
        "explanation": "insertMany() reduce el overhead de red al enviar todos los documentos en una sola solicitud al servidor en lugar de múltiples round-trips. Esto mejora significativamente el rendimiento en inserciones masivas. También permite uso de writeConcern más eficiente.",
        "difficulty": "medium"
    }
]

# Total Batch 1: 50 preguntas
# Categoría 1 (Instalación y Entorno): 30 preguntas COMPLETAS ✅
# Categoría 2 (CRUD - Create): 20 de 60 preguntas

# ==================== BATCH 2: Preguntas 51-100 ====================
# Categoría 2: CRUD - Create (40 preguntas restantes)
# Categoría 3: CRUD - Read (10 preguntas iniciales)

QUESTIONS_BATCH_2 = [
    # ==================== CATEGORÍA 2: CRUD - CREATE (continuación) ====================
    # Preguntas 51-90 (40 preguntas para completar las 60 de esta categoría)

    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un campo null en MongoDB?",
        "option_a": "db.coleccion.insertOne({campo: null})",
        "option_b": "db.coleccion.insertOne({campo: NULL})",
        "option_c": "db.coleccion.insertOne({campo: 'null'})",
        "option_d": "No es posible insertar valores null",
        "option_e": "db.coleccion.insertOne({campo: undefined})",
        "correct_answer": "a",
        "explanation": "MongoDB soporta el valor null de JavaScript. Se inserta como {campo: null}. Esto es diferente de undefined (que no se almacena) y de 'null' como string. null es un valor BSON válido que indica ausencia intencional de valor.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre un campo con valor null y un campo que no existe?",
        "option_a": "Son exactamente lo mismo",
        "option_b": "null indica ausencia intencional de valor; campo inexistente simplemente no está definido",
        "option_c": "null ocupa más espacio",
        "option_d": "Campos inexistentes no se pueden consultar",
        "option_e": "null es un error, campos inexistentes son normales",
        "correct_answer": "b",
        "explanation": "Hay diferencia semántica: {campo: null} indica que el campo existe pero intencionalmente no tiene valor. Un campo inexistente simplemente no está en el documento. Ambos se consultan diferente: {campo: null} vs {campo: {$exists: false}}.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas un vuelo con un array de escalas?",
        "option_a": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: ['MAD', 'BCN', 'PAR']})",
        "option_b": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: 'MAD,BCN,PAR'})",
        "option_c": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: ARRAY('MAD', 'BCN', 'PAR')})",
        "option_d": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: {'MAD', 'BCN', 'PAR'}})",
        "option_e": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas[0]: 'MAD', escalas[1]: 'BCN'})",
        "correct_answer": "a",
        "explanation": "Los arrays en MongoDB se insertan usando sintaxis de array JavaScript: ['valor1', 'valor2', ...]. MongoDB almacena arrays nativamente como tipo BSON Array, permitiendo consultas eficientes sobre elementos del array.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un ObjectId específico que ya tienes?",
        "option_a": "db.coleccion.insertOne({_id: 'ObjectId(507f1f77bcf86cd799439011)'})",
        "option_b": "db.coleccion.insertOne({_id: ObjectId('507f1f77bcf86cd799439011')})",
        "option_c": "db.coleccion.insertOne({_id: new ObjectId('507f1f77bcf86cd799439011')})",
        "option_d": "db.coleccion.insertOne({_id: '507f1f77bcf86cd799439011'})",
        "option_e": "Tanto b como c son correctas",
        "correct_answer": "e",
        "explanation": "Ambas sintaxis son válidas: ObjectId('string') y new ObjectId('string') crean un objeto ObjectId de BSON. No uses comillas alrededor del ObjectId() ni uses solo el string, ya que se almacenaría como string en lugar de tipo ObjectId.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede si insertas dos documentos con el mismo _id en insertMany()?",
        "option_a": "Ambos se insertan con diferentes _id",
        "option_b": "Se genera error y se detiene la inserción (con ordered: true por defecto)",
        "option_c": "Se actualiza el primero",
        "option_d": "MongoDB los fusiona automáticamente",
        "option_e": "Se ignoran los duplicados silenciosamente",
        "correct_answer": "b",
        "explanation": "Con ordered: true (default), insertMany() se detiene al encontrar un error de _id duplicado, dejando sin insertar los documentos posteriores. Con ordered: false, intenta insertar todos excepto los duplicados y reporta errores al final.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo insertas un documento con un subdocumento de ubicación geográfica?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Casa', geo: {type: 'Point', coordinates: [40.4168, -3.7038]}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Casa', geo: POINT(40.4168, -3.7038)})",
        "option_c": "db.listings_limpio.insertOne({nombre: 'Casa', lat: 40.4168, lon: -3.7038})",
        "option_d": "db.listings_limpio.insertOne({nombre: 'Casa', geo: '40.4168,-3.7038'})",
        "option_e": "db.listings_limpio.insertOne({nombre: 'Casa', geo: {lat: 40.4168, lng: -3.7038}})",
        "correct_answer": "a",
        "explanation": "MongoDB soporta datos geoespaciales usando GeoJSON. El formato correcto para un punto es {type: 'Point', coordinates: [longitud, latitud]}. Nota: longitud primero, luego latitud. Esto permite usar índices geoespaciales y consultas $near, $geoWithin, etc.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un timestamp de MongoDB?",
        "option_a": "db.coleccion.insertOne({ts: new Timestamp()})",
        "option_b": "db.coleccion.insertOne({ts: Timestamp(1, 0)})",
        "option_c": "db.coleccion.insertOne({ts: CURRENT_TIMESTAMP})",
        "option_d": "db.coleccion.insertOne({ts: Date.now()})",
        "option_e": "db.coleccion.insertOne({ts: new Date()})",
        "correct_answer": "b",
        "explanation": "Timestamp(segundos, contador) es el tipo BSON Timestamp usado internamente por MongoDB para replicación (no para fechas de aplicación). Para fechas usa new Date(). Timestamp() requiere dos parámetros: timestamp Unix y contador ordinal.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es mejor para fechas en aplicaciones: Date o Timestamp de BSON?",
        "option_a": "Timestamp siempre es mejor",
        "option_b": "Date para aplicaciones; Timestamp es para uso interno de MongoDB",
        "option_c": "Son intercambiables",
        "option_d": "Timestamp es más preciso",
        "option_e": "Date está deprecado",
        "correct_answer": "b",
        "explanation": "BSON Date (new Date()) es para fechas de aplicación. BSON Timestamp es para uso interno de MongoDB (oplog, replicación). Timestamp tiene semántica diferente y no debe usarse para datos de aplicación. Date soporta operaciones de fecha estándar.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con datos binarios (Binary) en MongoDB?",
        "option_a": "db.coleccion.insertOne({archivo: BinData(0, 'base64string')})",
        "option_b": "db.coleccion.insertOne({archivo: new Binary('data')})",
        "option_c": "db.coleccion.insertOne({archivo: BLOB('data')})",
        "option_d": "db.coleccion.insertOne({archivo: Buffer.from('data')})",
        "option_e": "Opciones a y b son correctas",
        "correct_answer": "e",
        "explanation": "Tanto BinData(subtype, base64) (en shell) como new Binary(buffer, subtype) (en drivers) son válidos. Los datos binarios se almacenan eficientemente como BSON Binary. Útil para almacenar archivos pequeños, pero para archivos grandes usa GridFS.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con un campo de tipo Long (64-bit)?",
        "option_a": "db.data_act_01_limpio.insertOne({contador: NumberLong('9223372036854775807')})",
        "option_b": "db.data_act_01_limpio.insertOne({contador: 9223372036854775807})",
        "option_c": "db.data_act_01_limpio.insertOne({contador: BIGINT(9223372036854775807)})",
        "option_d": "db.data_act_01_limpio.insertOne({contador: Long(9223372036854775807)})",
        "option_e": "db.data_act_01_limpio.insertOne({contador: new Int64(9223372036854775807)})",
        "correct_answer": "a",
        "explanation": "NumberLong('string') se usa para enteros de 64 bits que exceden el rango seguro de JavaScript (2^53). Los números normales en JS son de 64-bit float. NumberLong asegura precisión total para enteros grandes, crítico para IDs, timestamps, contadores.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples documentos usando bulkWrite()?",
        "option_a": "db.coleccion.bulkWrite([{insertOne: {document: {...}}}, {insertOne: {document: {...}}}])",
        "option_b": "db.coleccion.bulkWrite([{insert: {...}}, {insert: {...}}])",
        "option_c": "db.coleccion.bulkWrite([{...}, {...}])",
        "option_d": "db.coleccion.bulkWrite({insertMany: [{...}, {...}]})",
        "option_e": "db.coleccion.bulkWrite([{operation: 'insert', doc: {...}}])",
        "correct_answer": "a",
        "explanation": "bulkWrite() usa array de operaciones donde cada operación es un objeto con el tipo (insertOne, updateOne, etc.) y parámetros. Sintaxis: [{insertOne: {document: {...}}}, ...]. Permite mezclar múltiples tipos de operaciones en una sola llamada.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la ventaja de bulkWrite() sobre insertMany()?",
        "option_a": "bulkWrite() es más rápido",
        "option_b": "bulkWrite() permite combinar inserts, updates y deletes en una operación",
        "option_c": "bulkWrite() no genera errores",
        "option_d": "bulkWrite() soporta transacciones automáticas",
        "option_e": "insertMany() está deprecado",
        "correct_answer": "b",
        "explanation": "bulkWrite() permite ejecutar múltiples tipos de operaciones (insertOne, updateOne, deleteOne, replaceOne) en una sola llamada al servidor. insertMany() solo inserta. bulkWrite() es más flexible para operaciones batch heterogéneas.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo verificas cuántos documentos se insertaron exitosamente con insertMany()?",
        "option_a": "result.count",
        "option_b": "result.insertedCount",
        "option_c": "Object.keys(result.insertedIds).length",
        "option_d": "Opciones b y c son correctas",
        "option_e": "result.nInserted",
        "correct_answer": "d",
        "explanation": "insertMany() retorna un objeto con 'insertedCount' (número de docs insertados) y 'insertedIds' (objeto con los IDs). Puedes usar result.insertedCount directamente o contar las keys de insertedIds. Ambos dan el mismo resultado.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas un vuelo con un campo de tipo RegExp?",
        "option_a": "db.infovuelos_limpio.insertOne({codigo: /^IB\\d{4}$/})",
        "option_b": "db.infovuelos_limpio.insertOne({codigo: new RegExp('^IB\\\\d{4}$')})",
        "option_c": "db.infovuelos_limpio.insertOne({codigo: REGEX('^IB\\\\d{4}$')})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "MongoDB no soporta RegExp en documentos",
        "correct_answer": "d",
        "explanation": "MongoDB soporta BSON RegExp. Puedes usar sintaxis literal /pattern/flags o new RegExp('pattern', 'flags'). Aunque raro almacenar regex en docs, es posible. Más común es usar regex en consultas con operador $regex.",
        "difficulty": "hard",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué tipo de datos NO soporta MongoDB/BSON?",
        "option_a": "Arrays",
        "option_b": "Fechas",
        "option_c": "Funciones JavaScript",
        "option_d": "Binary data",
        "option_e": "Todos son soportados",
        "correct_answer": "c",
        "explanation": "MongoDB no almacena funciones JavaScript en documentos (aunque el shell permite ejecutar funciones). BSON soporta: String, Number, Boolean, Date, Timestamp, Binary, ObjectId, Array, Document, Null, RegExp, pero no funciones por razones de seguridad y serialización.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con validación de esquema opcional (sin Schema Validation)?",
        "option_a": "db.coleccion.insertOne({cualquier_campo: 'cualquier_valor'})",
        "option_b": "db.coleccion.insertOne({cualquier_campo: 'cualquier_valor'}, {validate: false})",
        "option_c": "db.coleccion.novalidate.insertOne({cualquier_campo: 'cualquier_valor'})",
        "option_d": "db.coleccion.insertOne({cualquier_campo: 'cualquier_valor'}, {bypassValidation: true})",
        "option_e": "Opciones a y d son correctas",
        "correct_answer": "e",
        "explanation": "Por defecto MongoDB no valida esquemas (esquema flexible). Si has definido validación con $jsonSchema, puedes saltarla con {bypassDocumentValidation: true}. Sin validación definida, insertOne() acepta cualquier estructura.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo insertas un documento con un array de documentos embebidos?",
        "option_a": "db.listings_limpio.insertOne({titulo: 'Casa', reviews: [{autor: 'Juan', rating: 5}, {autor: 'Ana', rating: 4}]})",
        "option_b": "db.listings_limpio.insertOne({titulo: 'Casa', reviews: [{autor: 'Juan', rating: 5}], [{autor: 'Ana', rating: 4}]})",
        "option_c": "db.listings_limpio.insertOne({titulo: 'Casa', reviews: JSON.stringify([{autor: 'Juan'}])})",
        "option_d": "db.listings_limpio.insertOne({titulo: 'Casa', reviews[0]: {autor: 'Juan'}, reviews[1]: {autor: 'Ana'}})",
        "option_e": "No es posible tener arrays de objetos",
        "correct_answer": "a",
        "explanation": "MongoDB soporta arrays de documentos embebidos: [{doc1}, {doc2}, ...]. Es una estructura común y poderosa que permite modelar relaciones uno-a-muchos dentro de un documento. Cada elemento del array puede ser un documento completo con su propia estructura.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuándo deberías usar documentos embebidos vs referencias en MongoDB?",
        "option_a": "Siempre usar embebidos, MongoDB no soporta referencias",
        "option_b": "Embebidos para datos que se acceden juntos; referencias para datos que se comparten o son muy grandes",
        "option_c": "Siempre usar referencias como en SQL",
        "option_d": "Depende del motor de almacenamiento",
        "option_e": "No hay diferencia de performance",
        "correct_answer": "b",
        "explanation": "Usa embebidos cuando: datos se leen juntos, relación uno-a-pocos, datos no se comparten. Usa referencias cuando: datos muy grandes, se comparten entre docs, relación muchos-a-muchos, o se actualizan frecuentemente. El diseño depende de patrones de acceso.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un campo que es un array vacío?",
        "option_a": "db.coleccion.insertOne({tags: []})",
        "option_b": "db.coleccion.insertOne({tags: null})",
        "option_c": "db.coleccion.insertOne({tags: EMPTY_ARRAY})",
        "option_d": "db.coleccion.insertOne({tags: {}})",
        "option_e": "No es posible, arrays deben tener al menos un elemento",
        "correct_answer": "a",
        "explanation": "MongoDB permite arrays vacíos: {campo: []}. Es diferente de null (indica sin valor) y de campo inexistente. Un array vacío puede crecer posteriormente con $push. Útil para inicializar listas que se llenarán después.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con un MinKey o MaxKey?",
        "option_a": "db.data_act_01_limpio.insertOne({limite: MinKey()})",
        "option_b": "db.data_act_01_limpio.insertOne({limite: new MinKey()})",
        "option_c": "db.data_act_01_limpio.insertOne({limite: MinKey})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "MinKey y MaxKey no son tipos BSON válidos",
        "correct_answer": "d",
        "explanation": "MinKey y MaxKey son tipos BSON especiales que se comparan menor/mayor que cualquier otro valor. Sintaxis: MinKey() o new MinKey(). Útiles para consultas de rango y en operaciones de sharding. Raramente usados en aplicaciones normales.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es un documento 'capped collection' y cómo afecta a insertOne()?",
        "option_a": "Una colección con validación de esquema estricta",
        "option_b": "Una colección de tamaño fijo que sobrescribe docs antiguos cuando se llena",
        "option_c": "Una colección comprimida",
        "option_d": "Una colección encriptada",
        "option_e": "Una colección temporal",
        "correct_answer": "b",
        "explanation": "Las capped collections tienen tamaño máximo fijo. Cuando se llena, MongoDB sobrescribe automáticamente los documentos más antiguos (comportamiento FIFO). Las inserciones son rápidas y mantienen orden de inserción. Útiles para logs, caché, historial limitado.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento garantizando que se escriba en el journal para durabilidad?",
        "option_a": "db.coleccion.insertOne({...}, {w: 1, j: true})",
        "option_b": "db.coleccion.insertOne({...}, {journal: true})",
        "option_c": "db.coleccion.insertOne({...}, {durability: 'high'})",
        "option_d": "db.coleccion.insertOne({...}, {fsync: true})",
        "option_e": "db.coleccion.insertOne({...}, {w: 'majority'})",
        "correct_answer": "a",
        "explanation": "WriteConcern con {j: true} espera confirmación de que la operación se escribió en el journal (log de escritura adelantada). Esto garantiza durabilidad ante fallos. {w: 1, j: true} espera escritura en journal del primario. Más lento pero más seguro.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el write concern {w: 0}?",
        "option_a": "Modo más seguro de escritura",
        "option_b": "Escritura sin esperar confirmación (fire and forget)",
        "option_c": "Escritura en memoria sin journal",
        "option_d": "Escritura solo en nodos secundarios",
        "option_e": "Deshabilita escrituras",
        "correct_answer": "b",
        "explanation": "{w: 0} es 'unacknowledged write' o 'fire and forget'. El cliente no espera confirmación del servidor, maximizando throughput pero sin garantías de éxito. No recomendado en producción. {w: 1} espera ack del primario, {w: 'majority'} de la mayoría.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas 1000 documentos de forma eficiente?",
        "option_a": "Usar un loop con 1000 insertOne()",
        "option_b": "db.infovuelos_limpio.insertMany([...1000 docs...])",
        "option_c": "db.infovuelos_limpio.bulkWrite([{insertOne: {...}} × 1000])",
        "option_d": "Opciones b y c son eficientes",
        "option_e": "Usar mongoimport desde archivo JSON",
        "correct_answer": "d",
        "explanation": "insertMany() y bulkWrite() son eficientes al agrupar operaciones. Evita loops de insertOne() (1000 round-trips). Para datasets muy grandes, mongoimport es la herramienta más rápida. insertMany() tiene límite de 100,000 docs por operación.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede con el performance de inserciones cuando agregas muchos índices a una colección?",
        "option_a": "Mejora el performance de inserciones",
        "option_b": "Las inserciones se vuelven más lentas porque cada índice debe actualizarse",
        "option_c": "No hay efecto en el performance",
        "option_d": "Los índices solo afectan las consultas",
        "option_e": "MongoDB deshabilita índices durante inserciones masivas",
        "correct_answer": "b",
        "explanation": "Cada índice adicional ralentiza las inserciones porque MongoDB debe actualizar todos los índices al insertar. El trade-off es: índices aceleran queries pero ralentizan writes. Diseña índices basándote en patrones de lectura vs escritura de tu aplicación.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento especificando timeout personalizado?",
        "option_a": "db.coleccion.insertOne({...}, {maxTimeMS: 5000})",
        "option_b": "db.coleccion.insertOne({...}, {timeout: 5000})",
        "option_c": "db.coleccion.insertOne({...}).timeout(5000)",
        "option_d": "db.coleccion.insertOne({...}, {ttl: 5000})",
        "option_e": "No es posible especificar timeout en inserciones",
        "correct_answer": "a",
        "explanation": "La opción maxTimeMS especifica el tiempo máximo en milisegundos para la operación. Si excede el timeout, MongoDB cancela la operación con error. Útil para prevenir operaciones que se cuelgan. Ejemplo: {maxTimeMS: 5000} para timeout de 5 segundos.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo insertas un documento con un campo de tipo Code (JavaScript)?",
        "option_a": "db.listings_limpio.insertOne({script: Code('function() { return 42; }')})",
        "option_b": "db.listings_limpio.insertOne({script: new Code('function() { return 42; }')})",
        "option_c": "db.listings_limpio.insertOne({script: 'function() { return 42; }'})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "MongoDB no permite almacenar código JavaScript",
        "correct_answer": "d",
        "explanation": "BSON Code permite almacenar código JavaScript. Sintaxis: Code('codigo') o new Code('codigo'). Usado raramente, principalmente para funciones MapReduce o stored procedures. Por seguridad, no es común almacenar código en docs de aplicación.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite de anidamiento (nesting) de documentos en MongoDB?",
        "option_a": "10 niveles",
        "option_b": "50 niveles",
        "option_c": "100 niveles",
        "option_d": "No hay límite específico, pero está limitado por el tamaño máximo de 16MB",
        "option_e": "MongoDB no permite documentos anidados",
        "correct_answer": "d",
        "explanation": "MongoDB no tiene límite explícito de niveles de anidamiento, pero está limitado por el tamaño máximo de documento (16MB) y consideraciones prácticas. Anidamiento excesivo complica consultas y actualizaciones. Generalmente se recomienda mantener estructura simple.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples documentos asegurando atomicidad en MongoDB 4.0+?",
        "option_a": "db.coleccion.insertMany([...], {atomic: true})",
        "option_b": "Usar sesión con transacción: session.withTransaction(() => { db.col.insertMany([...]) })",
        "option_c": "db.coleccion.transaction.insertMany([...])",
        "option_d": "insertMany() es atómico por defecto",
        "option_e": "No es posible atomicidad en MongoDB",
        "correct_answer": "b",
        "explanation": "MongoDB 4.0+ soporta transacciones multi-documento. Para atomicidad en múltiples operaciones, usa sesiones con transacciones. insertMany() de por sí no es una transacción (aunque cada insertOne() dentro es atómico). Para atomicidad total necesitas transacciones explícitas.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'upsert' y cuándo se usa con operaciones de inserción?",
        "option_a": "Un tipo especial de índice",
        "option_b": "Una operación que inserta si no existe o actualiza si existe",
        "option_c": "Un método de compresión",
        "option_d": "Una validación de esquema",
        "option_e": "insertOne() siempre hace upsert",
        "correct_answer": "b",
        "explanation": "Upsert (update + insert) inserta un documento si no existe o lo actualiza si existe. No está disponible en insertOne(), pero sí en updateOne/updateMany con opción {upsert: true}. Útil para operaciones idempotentes o cuando no sabes si el documento existe.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con el _id como string UUID?",
        "option_a": "db.data_act_01_limpio.insertOne({_id: UUID()})",
        "option_b": "db.data_act_01_limpio.insertOne({_id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'})",
        "option_c": "db.data_act_01_limpio.insertOne({_id: new UUID('a1b2c3d4-e5f6-7890-abcd-ef1234567890')})",
        "option_d": "db.data_act_01_limpio.insertOne({_id: GUID('a1b2c3d4-e5f6-7890-abcd-ef1234567890')})",
        "option_e": "Opciones b y c son posibles",
        "correct_answer": "e",
        "explanation": "El _id puede ser cualquier tipo BSON excepto arrays. Puedes usar string UUID: {_id: 'uuid-string'} o BSON UUID: {_id: UUID('...')} (en drivers que lo soporten). La mayoría usa ObjectId por defecto, pero UUIDs son válidos si necesitas compatibilidad con otros sistemas.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es la 'write performance' vs 'read performance' en el diseño de esquema?",
        "option_a": "Son lo mismo",
        "option_b": "Documentos embebidos optimizan lecturas; normalización con referencias optimiza escrituras",
        "option_c": "Write performance siempre es más importante",
        "option_d": "MongoDB optimiza ambos automáticamente",
        "option_e": "El esquema no afecta el performance",
        "correct_answer": "b",
        "explanation": "Trade-off de diseño: documentos embebidos optimizan lecturas (un solo query) pero ralentizan escrituras (documentos más grandes). Referencias optimizan escrituras (docs pequeños) pero requieren múltiples queries ($lookup). Diseña según tu patrón de acceso dominante.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento y obtienes el _id generado inmediatamente?",
        "option_a": "const result = db.coleccion.insertOne({...}); const id = result.insertedId;",
        "option_b": "const id = db.coleccion.insertOne({...}).getId();",
        "option_c": "db.coleccion.insertOne({...}, {returnId: true});",
        "option_d": "const id = db.coleccion.insertOne({...})._id;",
        "option_e": "No es posible obtener el _id inmediatamente",
        "correct_answer": "a",
        "explanation": "insertOne() retorna un objeto con la propiedad 'insertedId' que contiene el _id del documento insertado. Accedes con result.insertedId. Si no especificaste _id, será el ObjectId generado automáticamente por MongoDB.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Por qué MongoDB genera ObjectIds únicos globalmente sin coordinación central?",
        "option_a": "Usa un servidor central para generar IDs",
        "option_b": "ObjectId incluye timestamp, identificador de máquina y contador, garantizando unicidad",
        "option_c": "Usa números aleatorios",
        "option_d": "Solo es único dentro de una colección",
        "option_e": "Requiere sincronización entre nodos",
        "correct_answer": "b",
        "explanation": "ObjectId (12 bytes): 4 bytes timestamp + 5 bytes identificador de proceso/máquina + 3 bytes contador incremental. Esta estructura garantiza unicidad global sin coordinación entre nodos, esencial para sistemas distribuidos. Permite generación local rápida.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas 3 vuelos usando una sola llamada bulkWrite con manejo de errores?",
        "option_a": "db.infovuelos_limpio.bulkWrite([{insertOne: {document: {...}}}, {...}, {...}], {ordered: false})",
        "option_b": "db.infovuelos_limpio.bulkWrite([{insert: {...}}, {...}, {...}])",
        "option_c": "db.infovuelos_limpio.insertMany([{...}, {...}, {...}])",
        "option_d": "db.infovuelos_limpio.bulkInsert([{...}, {...}, {...}])",
        "option_e": "Opciones a y c son correctas",
        "correct_answer": "e",
        "explanation": "Tanto bulkWrite() con insertOne operations como insertMany() sirven. bulkWrite() es más flexible (puede mezclar operaciones). {ordered: false} hace que continúe insertando si uno falla. insertMany() con {ordered: false} tiene el mismo comportamiento.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'document validation' en MongoDB y cómo afecta a insertOne()?",
        "option_a": "MongoDB no soporta validación",
        "option_b": "Puedes definir reglas de validación con $jsonSchema que rechazan documentos que no cumplen",
        "option_c": "Validación automática de tipos de datos",
        "option_d": "Solo valida el _id",
        "option_e": "Validación solo en el cliente",
        "correct_answer": "b",
        "explanation": "Desde MongoDB 3.6+, puedes definir validación de esquema con $jsonSchema al crear la colección. insertOne() rechaza documentos que no cumplen el schema. Puedes especificar validationLevel (strict/moderate) y validationAction (error/warn). Útil para integridad de datos.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento especificando el comportamiento ante conflictos de _id duplicado en bulkWrite?",
        "option_a": "bulkWrite([...], {continueOnError: true})",
        "option_b": "bulkWrite([...], {ordered: false})",
        "option_c": "bulkWrite([...], {skipDuplicates: true})",
        "option_d": "bulkWrite([...], {ignoreErrors: true})",
        "option_e": "No es posible, siempre falla con duplicados",
        "correct_answer": "b",
        "explanation": "Con {ordered: false}, bulkWrite() continúa procesando operaciones posteriores incluso si algunas fallan por _id duplicado. {ordered: true} (default) se detiene en el primer error. Los errores se reportan en el resultado, pero las operaciones exitosas se completan.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite de operaciones en un solo bulkWrite()?",
        "option_a": "100 operaciones",
        "option_b": "1,000 operaciones",
        "option_c": "100,000 operaciones",
        "option_d": "1,000,000 operaciones",
        "option_e": "No hay límite explícito, pero está limitado por el tamaño de mensaje de 48MB",
        "correct_answer": "e",
        "explanation": "No hay límite explícito en número de operaciones, pero el tamaño total del mensaje está limitado a 48MB (maxMessageSizeBytes). Para grandes volúmenes, divide en múltiples bulkWrite(). MongoDB procesa en batches internos de 1000 operaciones.",
        "difficulty": "hard"
    },

    # ==================== CATEGORÍA 3: CRUD - READ ====================
    # Preguntas 91-100 (10 de 80 totales)

    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para encontrar todos los documentos de una colección?",
        "option_a": "db.coleccion.findAll()",
        "option_b": "db.coleccion.find()",
        "option_c": "db.coleccion.select()",
        "option_d": "SELECT * FROM coleccion",
        "option_e": "db.coleccion.getAll()",
        "correct_answer": "b",
        "explanation": "db.coleccion.find() sin parámetros retorna todos los documentos de la colección (equivalente a SELECT * en SQL). Retorna un cursor que puedes iterar. Para limitar resultados usa .limit(n). findAll() y getAll() no existen en MongoDB.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras un único documento en MongoDB?",
        "option_a": "db.coleccion.find().one()",
        "option_b": "db.coleccion.findOne()",
        "option_c": "db.coleccion.find().first()",
        "option_d": "db.coleccion.getSingle()",
        "option_e": "db.coleccion.find().limit(1)",
        "correct_answer": "b",
        "explanation": "findOne() retorna el primer documento que coincide con el filtro (o null si no hay coincidencias). No retorna un cursor, retorna el documento directamente. find().limit(1) retorna un cursor con un doc, no es lo mismo.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo encuentras todos los vuelos con origen 'Madrid'?",
        "option_a": "db.infovuelos_limpio.find({origen: 'Madrid'})",
        "option_b": "db.infovuelos_limpio.find({origen = 'Madrid'})",
        "option_c": "db.infovuelos_limpio.find(origen: 'Madrid')",
        "option_d": "db.infovuelos_limpio.find('origen', 'Madrid')",
        "option_e": "db.infovuelos_limpio.where({origen: 'Madrid'})",
        "correct_answer": "a",
        "explanation": "La sintaxis correcta es find({campo: valor}). El filtro es un objeto JavaScript con pares clave-valor. MongoDB busca documentos donde el campo 'origen' sea exactamente 'Madrid' (case-sensitive). where() no existe en MongoDB.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras documentos donde un campo específico existe?",
        "option_a": "db.coleccion.find({campo: {$exists: true}})",
        "option_b": "db.coleccion.find({campo: {$notNull: true}})",
        "option_c": "db.coleccion.find({campo: EXISTS})",
        "option_d": "db.coleccion.find({campo: IS NOT NULL})",
        "option_e": "db.coleccion.find({$has: 'campo'})",
        "correct_answer": "a",
        "explanation": "El operador $exists verifica si un campo existe en el documento. {campo: {$exists: true}} encuentra docs con el campo (incluso si es null). {$exists: false} encuentra docs sin el campo. Diferente de {campo: {$ne: null}} que excluye null.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo encuentras listings con precio mayor a 100?",
        "option_a": "db.listings_limpio.find({precio: {$gt: 100}})",
        "option_b": "db.listings_limpio.find({precio > 100})",
        "option_c": "db.listings_limpio.find({precio: '> 100'})",
        "option_d": "db.listings_limpio.find({precio: {gt: 100}})",
        "option_e": "db.listings_limpio.find().where(precio > 100)",
        "correct_answer": "a",
        "explanation": "El operador $gt (greater than) compara valores numéricos: {campo: {$gt: valor}}. Otros operadores: $lt (menor), $gte (mayor o igual), $lte (menor o igual), $eq (igual), $ne (diferente). No uses sintaxis tipo SQL.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras documentos donde un campo está en un conjunto de valores?",
        "option_a": "db.coleccion.find({campo: {$in: ['valor1', 'valor2', 'valor3']}})",
        "option_b": "db.coleccion.find({campo: ['valor1', 'valor2', 'valor3']})",
        "option_c": "db.coleccion.find({campo IN ('valor1', 'valor2', 'valor3')})",
        "option_d": "db.coleccion.find({campo: {$or: ['valor1', 'valor2', 'valor3']}})",
        "option_e": "db.coleccion.find({campo: {$anyOf: ['valor1', 'valor2', 'valor3']}})",
        "correct_answer": "a",
        "explanation": "El operador $in busca documentos donde el campo coincide con cualquier valor del array: {campo: {$in: [valores]}}. Es equivalente a múltiples $or pero más eficiente. $nin es el opuesto (not in).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo combinas múltiples condiciones con AND en una consulta?",
        "option_a": "db.coleccion.find({campo1: valor1, campo2: valor2})",
        "option_b": "db.coleccion.find({$and: [{campo1: valor1}, {campo2: valor2}]})",
        "option_c": "db.coleccion.find({campo1: valor1 AND campo2: valor2})",
        "option_d": "Tanto a como b son correctas",
        "option_e": "db.coleccion.find({campo1: valor1}).and({campo2: valor2})",
        "correct_answer": "d",
        "explanation": "Por defecto, múltiples campos en el filtro son AND implícito: {a: 1, b: 2}. También puedes usar $and explícito: {$and: [{a: 1}, {b: 2}]}. $and explícito es necesario cuando necesitas múltiples condiciones en el mismo campo.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo encuentras documentos donde precio está entre 50 y 100?",
        "option_a": "db.data_act_01_limpio.find({precio: {$gte: 50, $lte: 100}})",
        "option_b": "db.data_act_01_limpio.find({precio: {$between: [50, 100]}})",
        "option_c": "db.data_act_01_limpio.find({precio BETWEEN 50 AND 100})",
        "option_d": "db.data_act_01_limpio.find({precio: {$range: [50, 100]}})",
        "option_e": "db.data_act_01_limpio.find({$and: [{precio: {$gte: 50}}, {precio: {$lte: 100}}]})",
        "correct_answer": "a",
        "explanation": "Combina $gte y $lte en el mismo campo: {campo: {$gte: min, $lte: max}}. MongoDB permite múltiples operadores en el mismo campo. La opción 'e' también funciona pero 'a' es más concisa. No existe $between en MongoDB.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo limitas el número de resultados retornados?",
        "option_a": "db.coleccion.find().limit(10)",
        "option_b": "db.coleccion.find({}, {limit: 10})",
        "option_c": "db.coleccion.find().take(10)",
        "option_d": "db.coleccion.find({$limit: 10})",
        "option_e": "db.coleccion.find().max(10)",
        "correct_answer": "a",
        "explanation": "El método .limit(n) limita el número de documentos retornados por el cursor. Es un método de cursor, no parte del filtro. Ejemplo: find({...}).limit(10). Útil para paginación junto con .skip(). limit() debe ser después de find().",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo saltas los primeros N documentos en los resultados?",
        "option_a": "db.coleccion.find().skip(N)",
        "option_b": "db.coleccion.find().offset(N)",
        "option_c": "db.coleccion.find({$skip: N})",
        "option_d": "db.coleccion.find().ignore(N)",
        "option_e": "db.coleccion.find({}, {skip: N})",
        "correct_answer": "a",
        "explanation": "El método .skip(n) salta los primeros n documentos del resultado. Usado con .limit() para paginación: find().skip(pagina * tamaño).limit(tamaño). ADVERTENCIA: skip() es lento con valores grandes porque MongoDB debe recorrer los documentos saltados.",
        "difficulty": "easy"
    }
]

# Total Batch 2: 50 preguntas
# Categoría 2 (CRUD - Create): 40 preguntas (completando las 60 totales) ✅
# Categoría 3 (CRUD - Read): 10 de 80 preguntas

# ==================== BATCH 3: Preguntas 101-150 ====================
# Categoría 3: CRUD - Read (50 preguntas adicionales)

QUESTIONS_BATCH_3 = [
    # ==================== CATEGORÍA 3: CRUD - READ (continuación) ====================
    # Preguntas 101-150 (50 preguntas adicionales)

    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo ordenas los resultados por un campo en orden ascendente?",
        "option_a": "db.coleccion.find().sort({campo: 1})",
        "option_b": "db.coleccion.find().orderBy({campo: 'asc'})",
        "option_c": "db.coleccion.find().sort(campo, 1)",
        "option_d": "db.coleccion.find({}, {sort: {campo: 1}})",
        "option_e": "db.coleccion.find().ascending(campo)",
        "correct_answer": "a",
        "explanation": "El método .sort({campo: 1}) ordena en orden ascendente (1) o descendente (-1). Es un método de cursor. Ejemplo: find().sort({precio: 1}) ordena por precio de menor a mayor. Puedes ordenar por múltiples campos: sort({campo1: 1, campo2: -1}).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo ordenas los vuelos por precio de mayor a menor?",
        "option_a": "db.infovuelos_limpio.find().sort({precio: -1})",
        "option_b": "db.infovuelos_limpio.find().sort({precio: 'desc'})",
        "option_c": "db.infovuelos_limpio.find().sort({precio: 1})",
        "option_d": "db.infovuelos_limpio.find().orderBy({precio: -1})",
        "option_e": "db.infovuelos_limpio.find().descending('precio')",
        "correct_answer": "a",
        "explanation": "sort({campo: -1}) ordena en orden descendente (de mayor a menor). -1 significa descendente, 1 significa ascendente. Para precios de mayor a menor usa -1. sort() se encadena después de find().",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo cuentas el número total de documentos en una colección?",
        "option_a": "db.coleccion.count()",
        "option_b": "db.coleccion.countDocuments({})",
        "option_c": "db.coleccion.size()",
        "option_d": "db.coleccion.length()",
        "option_e": "db.coleccion.total()",
        "correct_answer": "b",
        "explanation": "countDocuments({}) es el método moderno para contar documentos. count() está deprecado. countDocuments({filtro}) cuenta docs que coinciden con el filtro. Para estimación rápida usa estimatedDocumentCount() (sin filtro, usa metadatos).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo seleccionas solo ciertos campos en los resultados (proyección)?",
        "option_a": "db.coleccion.find({}, {campo1: 1, campo2: 1})",
        "option_b": "db.coleccion.find().select('campo1', 'campo2')",
        "option_c": "db.coleccion.find({fields: ['campo1', 'campo2']})",
        "option_d": "db.coleccion.find().only(['campo1', 'campo2'])",
        "option_e": "SELECT campo1, campo2 FROM coleccion",
        "correct_answer": "a",
        "explanation": "La proyección se especifica como segundo parámetro de find(): find({filtro}, {proyección}). {campo: 1} incluye el campo, {campo: 0} lo excluye. _id se incluye por defecto, usa {_id: 0} para excluirlo. No puedes mezclar inclusiones y exclusiones excepto con _id.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo obtienes solo el nombre y precio, sin el _id?",
        "option_a": "db.listings_limpio.find({}, {nombre: 1, precio: 1, _id: 0})",
        "option_b": "db.listings_limpio.find({}, {nombre: true, precio: true, _id: false})",
        "option_c": "db.listings_limpio.find().select('nombre', 'precio')",
        "option_d": "db.listings_limpio.find({fields: {nombre: 1, precio: 1}})",
        "option_e": "db.listings_limpio.find({}, {_id: 0}).only(['nombre', 'precio'])",
        "correct_answer": "a",
        "explanation": "Proyección con {campo: 1} incluye campos específicos. _id se incluye automáticamente, para excluirlo usa {_id: 0}. Sintaxis: find({}, {campo1: 1, campo2: 1, _id: 0}). Solo valores 1 y 0 son válidos en proyecciones (no true/false).",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo usas OR para buscar documentos que cumplan al menos una de varias condiciones?",
        "option_a": "db.coleccion.find({$or: [{condicion1}, {condicion2}]})",
        "option_b": "db.coleccion.find({condicion1 OR condicion2})",
        "option_c": "db.coleccion.find({condicion1}).or({condicion2})",
        "option_d": "db.coleccion.find({$any: [{condicion1}, {condicion2}]})",
        "option_e": "db.coleccion.find().or([{condicion1}, {condicion2}])",
        "correct_answer": "a",
        "explanation": "El operador $or toma un array de condiciones: {$or: [{cond1}, {cond2}, ...]}. Retorna documentos que cumplen al menos una condición. Ejemplo: {$or: [{precio: {$lt: 50}}, {categoria: 'oferta'}]}. Puede combinarse con otras condiciones.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo encuentras vuelos con origen 'Madrid' O destino 'Barcelona'?",
        "option_a": "db.infovuelos_limpio.find({$or: [{origen: 'Madrid'}, {destino: 'Barcelona'}]})",
        "option_b": "db.infovuelos_limpio.find({origen: 'Madrid', destino: 'Barcelona'})",
        "option_c": "db.infovuelos_limpio.find({origen: 'Madrid' OR destino: 'Barcelona'})",
        "option_d": "db.infovuelos_limpio.find({$any: {origen: 'Madrid', destino: 'Barcelona'}})",
        "option_e": "db.infovuelos_limpio.find().or({origen: 'Madrid'}, {destino: 'Barcelona'})",
        "correct_answer": "a",
        "explanation": "Usa $or con array de condiciones: {$or: [{campo1: valor1}, {campo2: valor2}]}. Sin $or (opción b) sería AND (ambas condiciones simultáneamente). $or permite condiciones independientes.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo niegas una condición en MongoDB?",
        "option_a": "db.coleccion.find({campo: {$not: {$gt: 100}}})",
        "option_b": "db.coleccion.find({NOT campo: {$gt: 100}})",
        "option_c": "db.coleccion.find({campo: {!$gt: 100}})",
        "option_d": "db.coleccion.find().not({campo: {$gt: 100}})",
        "option_e": "db.coleccion.find({campo: {$ne: {$gt: 100}}})",
        "correct_answer": "a",
        "explanation": "$not niega una expresión: {campo: {$not: {operador: valor}}}. Ejemplo: {edad: {$not: {$gt: 18}}} encuentra personas con edad <= 18. $not funciona con operadores de comparación. Para negar igualdad simple usa $ne.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo NO está en un conjunto de valores?",
        "option_a": "db.coleccion.find({campo: {$nin: ['valor1', 'valor2']}})",
        "option_b": "db.coleccion.find({campo: {$not: {$in: ['valor1', 'valor2']}}})",
        "option_c": "db.coleccion.find({campo: {$notIn: ['valor1', 'valor2']}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find({campo NOT IN ['valor1', 'valor2']})",
        "correct_answer": "d",
        "explanation": "$nin (not in) es el opuesto de $in: {campo: {$nin: [valores]}}. También puedes usar {campo: {$not: {$in: [valores]}}} que es equivalente. $nin es más directo y preferido. Ambos excluyen documentos con el campo en el array.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo consultas un campo anidado usando dot notation?",
        "option_a": "db.coleccion.find({'direccion.ciudad': 'Madrid'})",
        "option_b": "db.coleccion.find({direccion: {ciudad: 'Madrid'}})",
        "option_c": "db.coleccion.find({direccion.ciudad: 'Madrid'})",
        "option_d": "db.coleccion.find({direccion->ciudad: 'Madrid'})",
        "option_e": "db.coleccion.find({direccion[ciudad]: 'Madrid'})",
        "correct_answer": "a",
        "explanation": "Dot notation con comillas: {'campo.subcampo': valor}. Las comillas son necesarias por el punto. Opción b buscaría un documento con SOLO el campo ciudad (match exacto del objeto completo). Dot notation permite consultar campos anidados específicos.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, si la ubicación es {ciudad: 'Madrid', barrio: 'Centro'}, ¿cómo buscas por barrio?",
        "option_a": "db.listings_limpio.find({'ubicacion.barrio': 'Centro'})",
        "option_b": "db.listings_limpio.find({ubicacion: {barrio: 'Centro'}})",
        "option_c": "db.listings_limpio.find({ubicacion.barrio: 'Centro'})",
        "option_d": "db.listings_limpio.find({ubicacion: {'barrio': 'Centro'}})",
        "option_e": "db.listings_limpio.find({ubicacion[barrio]: 'Centro'})",
        "correct_answer": "a",
        "explanation": "Usa dot notation con comillas: {'objeto.campo': valor}. Esto busca en el subcampo sin requerir match exacto del objeto completo. Opción b requeriría que ubicacion sea exactamente {barrio: 'Centro'}, sin ciudad ni otros campos.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo consultas elementos específicos de un array por posición?",
        "option_a": "db.coleccion.find({'array.0': 'valor'})",
        "option_b": "db.coleccion.find({array[0]: 'valor'})",
        "option_c": "db.coleccion.find({array: {$index: 0, $value: 'valor'}})",
        "option_d": "db.coleccion.find({array: {0: 'valor'}})",
        "option_e": "db.coleccion.find({array.at(0): 'valor'})",
        "correct_answer": "a",
        "explanation": "Usa dot notation con índice: {'array.0': valor} busca en el primer elemento, {'array.1': valor} en el segundo, etc. Los índices comienzan en 0. Las comillas son necesarias. Útil cuando conoces la posición exacta del elemento.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un array contiene un valor específico?",
        "option_a": "db.coleccion.find({tags: 'valor'})",
        "option_b": "db.coleccion.find({tags: {$contains: 'valor'}})",
        "option_c": "db.coleccion.find({tags: {$in: ['valor']}})",
        "option_d": "Opciones a y c son correctas",
        "option_e": "db.coleccion.find({tags: {$has: 'valor'}})",
        "correct_answer": "d",
        "explanation": "Para buscar un valor en un array, simplemente usa {array: valor}. MongoDB automáticamente busca en el array. También puedes usar {array: {$in: [valor]}} que es equivalente. Ambas sintaxis funcionan correctamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un array contiene TODOS los valores especificados?",
        "option_a": "db.coleccion.find({tags: {$all: ['valor1', 'valor2']}})",
        "option_b": "db.coleccion.find({tags: ['valor1', 'valor2']})",
        "option_c": "db.coleccion.find({tags: {$containsAll: ['valor1', 'valor2']}})",
        "option_d": "db.coleccion.find({tags: {$and: ['valor1', 'valor2']}})",
        "option_e": "db.coleccion.find({tags: {$in: ['valor1', 'valor2']}})",
        "correct_answer": "a",
        "explanation": "$all requiere que el array contenga TODOS los valores especificados (pero puede tener otros): {array: {$all: [v1, v2]}}. Opción b buscaría un array exactamente igual. $in busca al menos uno. $all es AND, $in es OR.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, si escalas es un array, ¿cómo buscas vuelos con escalas en 'MAD' Y 'BCN'?",
        "option_a": "db.infovuelos_limpio.find({escalas: {$all: ['MAD', 'BCN']}})",
        "option_b": "db.infovuelos_limpio.find({escalas: ['MAD', 'BCN']})",
        "option_c": "db.infovuelos_limpio.find({escalas: {$in: ['MAD', 'BCN']}})",
        "option_d": "db.infovuelos_limpio.find({escalas: 'MAD', escalas: 'BCN'})",
        "option_e": "db.infovuelos_limpio.find({escalas: {$and: ['MAD', 'BCN']}})",
        "correct_answer": "a",
        "explanation": "$all garantiza que el array contenga ambos valores: {escalas: {$all: ['MAD', 'BCN']}}. El orden no importa y puede haber otros valores. Opción b requiere array exacto. $in busca al menos uno, no ambos.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un array tiene un tamaño específico?",
        "option_a": "db.coleccion.find({array: {$size: 3}})",
        "option_b": "db.coleccion.find({array: {$length: 3}})",
        "option_c": "db.coleccion.find({array.length: 3})",
        "option_d": "db.coleccion.find({$where: 'this.array.length == 3'})",
        "option_e": "Opciones a y d son correctas",
        "correct_answer": "e",
        "explanation": "$size busca arrays con longitud exacta: {array: {$size: n}}. LIMITACIÓN: $size no soporta rangos, solo valores exactos. $where permite JavaScript pero es más lento. Para rangos de tamaño, almacena un campo de contador separado.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un elemento de un array de objetos cumple múltiples condiciones?",
        "option_a": "db.coleccion.find({array: {$elemMatch: {campo1: valor1, campo2: valor2}}})",
        "option_b": "db.coleccion.find({'array.campo1': valor1, 'array.campo2': valor2})",
        "option_c": "db.coleccion.find({array: {campo1: valor1, campo2: valor2}})",
        "option_d": "db.coleccion.find({$and: [{'array.campo1': valor1}, {'array.campo2': valor2}]})",
        "option_e": "db.coleccion.find({array: {$match: {campo1: valor1, campo2: valor2}}})",
        "correct_answer": "a",
        "explanation": "$elemMatch asegura que UN MISMO elemento del array cumpla todas las condiciones: {array: {$elemMatch: {cond1, cond2}}}. Sin $elemMatch (opción b/d), las condiciones pueden cumplirse en diferentes elementos del array, dando resultados incorrectos.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio con array reviews: [{autor: 'Juan', rating: 5}, {autor: 'Ana', rating: 3}], ¿cómo buscas listings con una review de 'Juan' con rating 5?",
        "option_a": "db.listings_limpio.find({reviews: {$elemMatch: {autor: 'Juan', rating: 5}}})",
        "option_b": "db.listings_limpio.find({'reviews.autor': 'Juan', 'reviews.rating': 5})",
        "option_c": "db.listings_limpio.find({reviews: {autor: 'Juan', rating: 5}})",
        "option_d": "db.listings_limpio.find({$and: [{'reviews.autor': 'Juan'}, {'reviews.rating': 5}]})",
        "option_e": "Opciones a y b son correctas",
        "correct_answer": "a",
        "explanation": "$elemMatch es necesario para asegurar que ambas condiciones se cumplan en el MISMO elemento del array. Opción b podría coincidir si un elemento tiene autor: 'Juan' y OTRO elemento tiene rating: 5, lo cual es incorrecto.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos usando expresiones regulares?",
        "option_a": "db.coleccion.find({campo: {$regex: /patron/i}})",
        "option_b": "db.coleccion.find({campo: {$regex: 'patron', $options: 'i'}})",
        "option_c": "db.coleccion.find({campo: /patron/i})",
        "option_d": "Todas las opciones anteriores son correctas",
        "option_e": "db.coleccion.find({campo LIKE '%patron%'})",
        "correct_answer": "d",
        "explanation": "MongoDB soporta tres sintaxis de regex: 1) $regex con regex literal: {$regex: /pattern/flags}, 2) $regex con string y $options: {$regex: 'pattern', $options: 'i'}, 3) regex directo: campo: /pattern/flags. Todas son válidas.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo buscas documentos donde nombre empieza con 'Mar' (case-insensitive)?",
        "option_a": "db.data_act_01_limpio.find({nombre: {$regex: /^Mar/i}})",
        "option_b": "db.data_act_01_limpio.find({nombre: {$regex: '^Mar', $options: 'i'}})",
        "option_c": "db.data_act_01_limpio.find({nombre: /^Mar/i})",
        "option_d": "Todas las opciones anteriores son correctas",
        "option_e": "db.data_act_01_limpio.find({nombre: {$startsWith: 'Mar'}})",
        "correct_answer": "d",
        "explanation": "^ indica inicio de string. Flag 'i' hace case-insensitive. Todas las sintaxis de regex son válidas. $startsWith no existe en MongoDB. Regex es poderoso pero puede ser lento sin índice apropiado (use índice text para búsquedas complejas).",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el operador $nor?",
        "option_a": "Busca documentos que NO cumplen NINGUNA de las condiciones",
        "option_b": "Busca documentos que cumplen todas las condiciones",
        "option_c": "Es lo mismo que $not",
        "option_d": "Normaliza los resultados",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$nor es el opuesto de $or: {$nor: [{cond1}, {cond2}]} retorna docs que NO cumplen NINGUNA condición (ni cond1 ni cond2). Es como NOT (cond1 OR cond2) = (NOT cond1) AND (NOT cond2). Útil para exclusiones múltiples.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes los valores únicos de un campo en toda la colección?",
        "option_a": "db.coleccion.distinct('campo')",
        "option_b": "db.coleccion.find().distinct('campo')",
        "option_c": "db.coleccion.find({}, {campo: 1}).unique()",
        "option_d": "db.coleccion.unique('campo')",
        "option_e": "SELECT DISTINCT campo FROM coleccion",
        "correct_answer": "a",
        "explanation": "distinct('campo') retorna un array con valores únicos del campo. Sintaxis: db.coleccion.distinct('campo', {filtro_opcional}). Útil para obtener listas de valores posibles. Puede usarse con filtro como segundo parámetro.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo obtienes la lista de ciudades de origen únicas?",
        "option_a": "db.infovuelos_limpio.distinct('origen')",
        "option_b": "db.infovuelos_limpio.find({}, {origen: 1}).unique()",
        "option_c": "db.infovuelos_limpio.aggregate([{$group: {_id: '$origen'}}])",
        "option_d": "Opciones a y c son correctas",
        "option_e": "db.infovuelos_limpio.find().distinct('origen')",
        "correct_answer": "d",
        "explanation": "distinct('campo') es la forma más simple. También puedes usar aggregation con $group para valores únicos. distinct() es método de colección, no de cursor (no va después de find()). Ambos enfoques funcionan, distinct es más directo.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre countDocuments() y estimatedDocumentCount()?",
        "option_a": "No hay diferencia",
        "option_b": "countDocuments() cuenta exacto con filtro; estimatedDocumentCount() es rápido pero aproximado sin filtro",
        "option_c": "estimatedDocumentCount() es más preciso",
        "option_d": "countDocuments() está deprecado",
        "option_e": "estimatedDocumentCount() soporta filtros",
        "correct_answer": "b",
        "explanation": "countDocuments({filtro}) cuenta documentos exactos que coinciden con el filtro (puede ser lento en colecciones grandes). estimatedDocumentCount() usa metadatos para estimación rápida de toda la colección (sin filtro, puede estar desactualizado). Elige según necesites precisión vs velocidad.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo verificas si un array está vacío en una consulta?",
        "option_a": "db.coleccion.find({array: {$size: 0}})",
        "option_b": "db.coleccion.find({array: []})",
        "option_c": "db.coleccion.find({array: {$eq: []}})",
        "option_d": "Todas las opciones anteriores son correctas",
        "option_e": "db.coleccion.find({array: null})",
        "correct_answer": "d",
        "explanation": "Tres formas válidas: {array: {$size: 0}} cuenta elementos, {array: []} y {array: {$eq: []}} buscan match exacto con array vacío. Todas funcionan. {array: null} buscaría null, no array vacío (son diferentes).",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo combinas limit() y skip() para implementar paginación?",
        "option_a": "db.coleccion.find().skip(pagina * tamaño).limit(tamaño)",
        "option_b": "db.coleccion.find().limit(tamaño).skip(pagina * tamaño)",
        "option_c": "db.coleccion.find({}, {skip: pagina * tamaño, limit: tamaño})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find().page(pagina, tamaño)",
        "correct_answer": "d",
        "explanation": "El orden de skip() y limit() en el código no importa, MongoDB los aplica en el orden correcto (skip antes de limit). Para página 0: skip(0).limit(10), página 1: skip(10).limit(10), etc. NOTA: skip() es ineficiente para valores grandes.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo obtienes los 10 listings más caros?",
        "option_a": "db.listings_limpio.find().sort({precio: -1}).limit(10)",
        "option_b": "db.listings_limpio.find().limit(10).sort({precio: -1})",
        "option_c": "db.listings_limpio.find({}, {sort: {precio: -1}, limit: 10})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.listings_limpio.find().top(10, 'precio')",
        "correct_answer": "d",
        "explanation": "El orden de los métodos de cursor en el código no afecta la ejecución: MongoDB optimiza automáticamente. sort({precio: -1}) ordena descendente (mayor primero), limit(10) toma los primeros 10. Ambos órdenes de escritura son válidos.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es un cursor en MongoDB?",
        "option_a": "Un puntero de mouse",
        "option_b": "Un iterador que apunta a los resultados de una consulta",
        "option_c": "Un tipo de índice",
        "option_d": "Una variable de sesión",
        "option_e": "Un método de ordenamiento",
        "correct_answer": "b",
        "explanation": "find() retorna un cursor, no los documentos directamente. El cursor es un iterador sobre los resultados. En el shell, el cursor itera automáticamente mostrando hasta 20 docs. En drivers, debes iterar explícitamente. Los cursores permiten operaciones eficientes con grandes resultados.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo conviertes un cursor a un array en el shell?",
        "option_a": "db.coleccion.find().toArray()",
        "option_b": "db.coleccion.find().array()",
        "option_c": "Array.from(db.coleccion.find())",
        "option_d": "db.coleccion.find().collect()",
        "option_e": "db.coleccion.find().list()",
        "correct_answer": "a",
        "explanation": "El método .toArray() convierte un cursor en un array JavaScript con todos los documentos. PRECAUCIÓN: En colecciones grandes, esto puede consumir mucha memoria. Usa .toArray() solo cuando necesites todos los resultados en memoria simultáneamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo es de un tipo específico?",
        "option_a": "db.coleccion.find({campo: {$type: 'string'}})",
        "option_b": "db.coleccion.find({campo: {$type: 2}})",
        "option_c": "db.coleccion.find({campo: {$instanceof: String}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find({typeof campo: 'string'})",
        "correct_answer": "d",
        "explanation": "$type filtra por tipo BSON: {campo: {$type: 'string'}} o {campo: {$type: 2}} (número de tipo BSON). Tipos comunes: 'string' (2), 'int' (16), 'long' (18), 'double' (1), 'array' (4), 'object' (3). Útil en esquemas flexibles.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo buscas documentos donde precio es un número (no string)?",
        "option_a": "db.data_act_01_limpio.find({precio: {$type: 'number'}})",
        "option_b": "db.data_act_01_limpio.find({precio: {$type: [1, 16, 18]}})",
        "option_c": "db.data_act_01_limpio.find({precio: {$type: 'double'}})",
        "option_d": "Opción b es la más correcta (incluye double, int, long)",
        "option_e": "db.data_act_01_limpio.find({precio: {$isNumeric: true}})",
        "correct_answer": "d",
        "explanation": "'number' no es un alias válido en $type. Los tipos numéricos BSON son: double (1), int (16), long (18), decimal (19). Para buscar cualquier número usa array: {$type: [1, 16, 18, 19]}. Esto captura todos los tipos numéricos.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos con texto en un campo usando búsqueda de texto completo?",
        "option_a": "db.coleccion.find({$text: {$search: 'palabra clave'}})",
        "option_b": "db.coleccion.find({campo: {$contains: 'texto'}})",
        "option_c": "db.coleccion.find({campo: {$fulltext: 'texto'}})",
        "option_d": "db.coleccion.fullTextSearch('texto')",
        "option_e": "db.coleccion.find({campo MATCH 'texto'})",
        "correct_answer": "a",
        "explanation": "$text requiere un índice de texto previamente creado: db.coleccion.createIndex({campo: 'text'}). Luego usa {$text: {$search: 'términos'}}. Soporta búsqueda de palabras, frases (con comillas), y negación (con -). Más eficiente que regex para búsquedas de texto.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es mejor para búsquedas de texto: $regex o $text?",
        "option_a": "$regex siempre es mejor",
        "option_b": "$text es mejor para búsqueda de palabras completas en lenguaje natural; $regex para patrones exactos",
        "option_c": "Son equivalentes",
        "option_d": "$text no existe",
        "option_e": "$regex es más rápido",
        "correct_answer": "b",
        "explanation": "$text (con índice text) es optimizado para búsqueda de palabras, soporta stemming, stop words, y puntuación de relevancia. $regex es para patrones exactos pero puede ser lento sin índice. Para búsqueda en lenguaje natural usa $text, para patrones específicos usa $regex.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo contiene null O no existe?",
        "option_a": "db.coleccion.find({campo: null})",
        "option_b": "db.coleccion.find({campo: {$in: [null]}})",
        "option_c": "db.coleccion.find({$or: [{campo: null}, {campo: {$exists: false}}]})",
        "option_d": "Opciones a y b retornan documentos con null O sin el campo",
        "option_e": "db.coleccion.find({campo: {$eq: null, $exists: false}})",
        "correct_answer": "d",
        "explanation": "{campo: null} encuentra documentos donde el campo es null O no existe. Para buscar SOLO null (campo existe pero es null): {campo: {$type: 10}}. Para buscar SOLO campo inexistente: {campo: {$exists: false}}.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo buscas vuelos con precio entre 100 y 200, ordenados por fecha?",
        "option_a": "db.infovuelos_limpio.find({precio: {$gte: 100, $lte: 200}}).sort({fecha: 1})",
        "option_b": "db.infovuelos_limpio.find({$and: [{precio: {$gte: 100}}, {precio: {$lte: 200}}]}).sort({fecha: 1})",
        "option_c": "db.infovuelos_limpio.find({precio: {$between: [100, 200]}}).orderBy({fecha: 1})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.infovuelos_limpio.find().where(precio >= 100 && precio <= 200).sort({fecha: 1})",
        "correct_answer": "d",
        "explanation": "Ambas sintaxis son válidas. La opción 'a' es más concisa combinando operadores en el mismo campo. Opción 'b' usa $and explícito. sort({fecha: 1}) ordena ascendente por fecha. No existe $between ni .where() en MongoDB.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es un 'covered query' en MongoDB?",
        "option_a": "Una consulta encriptada",
        "option_b": "Una consulta que puede responderse completamente usando solo el índice, sin leer documentos",
        "option_c": "Una consulta con múltiples condiciones",
        "option_d": "Una consulta en una transacción",
        "option_e": "Una consulta con proyección",
        "correct_answer": "b",
        "explanation": "Un covered query es respondido completamente por el índice sin acceder a los documentos. Requisitos: 1) todos los campos consultados están en el índice, 2) todos los campos proyectados están en el índice, 3) _id no se proyecta (o está en índice). Muy rápido.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo excluyes campos específicos de los resultados?",
        "option_a": "db.coleccion.find({}, {campo1: 0, campo2: 0})",
        "option_b": "db.coleccion.find({}, {campo1: false, campo2: false})",
        "option_c": "db.coleccion.find().exclude('campo1', 'campo2')",
        "option_d": "db.coleccion.find({}, {$exclude: ['campo1', 'campo2']})",
        "option_e": "db.coleccion.find().without(['campo1', 'campo2'])",
        "correct_answer": "a",
        "explanation": "Proyección de exclusión: {campo: 0} excluye campos. Puedes excluir múltiples campos: {campo1: 0, campo2: 0}. REGLA: No puedes mezclar inclusión (1) y exclusión (0) excepto con _id. Solo 0 y 1 son válidos (no false/true).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo obtienes todos los campos EXCEPTO las reviews?",
        "option_a": "db.listings_limpio.find({}, {reviews: 0})",
        "option_b": "db.listings_limpio.find({}, {reviews: false})",
        "option_c": "db.listings_limpio.find().exclude('reviews')",
        "option_d": "db.listings_limpio.find({}, {$not: 'reviews'})",
        "option_e": "db.listings_limpio.find().without('reviews')",
        "correct_answer": "a",
        "explanation": "Proyección de exclusión {reviews: 0} retorna todos los campos excepto reviews. Es más simple que listar todos los campos a incluir cuando solo quieres excluir pocos. MongoDB retorna todos los demás campos automáticamente.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo limitas los elementos retornados de un array en la proyección?",
        "option_a": "db.coleccion.find({}, {array: {$slice: 5}})",
        "option_b": "db.coleccion.find({}, {array: {$limit: 5}})",
        "option_c": "db.coleccion.find({}, {'array.0-5': 1})",
        "option_d": "db.coleccion.find().slice('array', 5)",
        "option_e": "db.coleccion.find({}, {array: {$take: 5}})",
        "correct_answer": "a",
        "explanation": "$slice en proyección limita elementos del array: {array: {$slice: n}} retorna primeros n elementos. {$slice: -n} últimos n. {$slice: [skip, limit]} para rango. Útil para arrays grandes donde solo necesitas algunos elementos.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo de fecha es posterior a una fecha específica?",
        "option_a": "db.coleccion.find({fecha: {$gt: new Date('2024-01-01')}})",
        "option_b": "db.coleccion.find({fecha: {$gt: ISODate('2024-01-01')}})",
        "option_c": "db.coleccion.find({fecha: {$after: '2024-01-01'}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find({fecha > '2024-01-01'})",
        "correct_answer": "d",
        "explanation": "Usa operadores de comparación con objetos Date: {fecha: {$gt: new Date('ISO8601')}} o ISODate('ISO8601') en shell. $gt funciona con fechas porque BSON Date es comparable. Asegúrate que el campo sea tipo Date, no string.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Por qué es importante que los campos de fecha se almacenen como BSON Date y no como strings?",
        "option_a": "Ocupan menos espacio",
        "option_b": "Permiten comparaciones cronológicas correctas y operaciones de fecha eficientes",
        "option_c": "Son más fáciles de leer",
        "option_d": "No hay diferencia práctica",
        "option_e": "Strings son mejores para fechas",
        "correct_answer": "b",
        "explanation": "BSON Date permite comparaciones cronológicas ($gt, $lt) y operaciones de fecha en agregación ($year, $month, etc.). Strings se comparan lexicográficamente (alfabéticamente), lo que falla con formatos como 'DD/MM/YYYY'. Usa siempre Date para timestamps y fechas.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo cuentas cuántos documentos tienen precio mayor a 50?",
        "option_a": "db.data_act_01_limpio.countDocuments({precio: {$gt: 50}})",
        "option_b": "db.data_act_01_limpio.find({precio: {$gt: 50}}).count()",
        "option_c": "db.data_act_01_limpio.count({precio: {$gt: 50}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.data_act_01_limpio.find({precio: {$gt: 50}}).length()",
        "correct_answer": "d",
        "explanation": "countDocuments({filtro}) es el método moderno recomendado. cursor.count() también funciona pero está deprecado en favor de countDocuments(). count() como método de colección está deprecado. length() no existe.",
        "difficulty": "easy",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes un documento aleatorio de una colección?",
        "option_a": "db.coleccion.aggregate([{$sample: {size: 1}}])",
        "option_b": "db.coleccion.find().random()",
        "option_c": "db.coleccion.findOne().random()",
        "option_d": "db.coleccion.find().sort({$random: 1}).limit(1)",
        "option_e": "db.coleccion.getRandom()",
        "correct_answer": "a",
        "explanation": "$sample en aggregation retorna n documentos aleatorios: [{$sample: {size: n}}]. Es eficiente incluso en colecciones grandes. No hay método .random(). Para un documento aleatorio, $sample con size: 1 es la forma correcta.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuándo es más eficiente usar aggregation framework en lugar de find()?",
        "option_a": "Siempre usar aggregation",
        "option_b": "Para transformaciones complejas, agrupaciones, joins, y procesamiento de datos multi-etapa",
        "option_c": "find() siempre es más rápido",
        "option_d": "Solo para consultas de texto",
        "option_e": "No hay diferencia",
        "correct_answer": "b",
        "explanation": "Usa find() para consultas simples de lectura. Usa aggregation para: transformaciones de datos, agrupaciones ($group), joins ($lookup), cálculos complejos, pipelines multi-etapa. Aggregation es más poderoso pero con más overhead para consultas simples.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos con múltiples condiciones en el mismo campo?",
        "option_a": "db.coleccion.find({precio: {$gte: 100, $lt: 200, $ne: 150}})",
        "option_b": "db.coleccion.find({$and: [{precio: {$gte: 100}}, {precio: {$lt: 200}}, {precio: {$ne: 150}}]})",
        "option_c": "db.coleccion.find({precio: {$gte: 100}, precio: {$lt: 200}, precio: {$ne: 150}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "No es posible",
        "correct_answer": "d",
        "explanation": "Puedes combinar múltiples operadores en el mismo campo: {campo: {$op1: v1, $op2: v2}}. MongoDB aplica AND implícito. También funciona con $and explícito. Opción c es inválida (solo la última clave 'precio' prevalecería en JavaScript).",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'explain' y para qué sirve en consultas?",
        "option_a": "Documenta la consulta",
        "option_b": "Muestra el plan de ejecución de la consulta, índices usados, y estadísticas de performance",
        "option_c": "Traduce la consulta a SQL",
        "option_d": "Valida la sintaxis",
        "option_e": "Formatea los resultados",
        "correct_answer": "b",
        "explanation": ".explain() muestra cómo MongoDB ejecuta la consulta: índices usados, documentos examinados, tiempo de ejecución. Modos: 'queryPlanner' (plan), 'executionStats' (estadísticas), 'allPlansExecution' (todos los planes). Esencial para optimizar queries.",
        "difficulty": "medium"
    }
]

# Total Batch 3: 50 preguntas
# Categoría 3 (CRUD - Read): 60 de 80 preguntas (10 del batch anterior + 50 de este batch)

# ==================== BATCH 4: Preguntas 151-200 ====================
# Categoría 3: CRUD - Read (20 preguntas finales)
# Categoría 4: CRUD - Update (30 preguntas iniciales)

QUESTIONS_BATCH_4 = [
    # ==================== CATEGORÍA 3: CRUD - READ (últimas 20 preguntas) ====================
    # Preguntas 151-170

    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos dentro de un radio geográfico desde un punto (consulta geoespacial)?",
        "option_a": "db.coleccion.find({ubicacion: {$near: {$geometry: {type: 'Point', coordinates: [lon, lat]}, $maxDistance: metros}}})",
        "option_b": "db.coleccion.find({ubicacion: {$near: [lat, lon], $maxDistance: metros}})",
        "option_c": "db.coleccion.find({ubicacion: {$within: {radius: metros, center: [lat, lon]}}})",
        "option_d": "db.coleccion.find({ubicacion: {$geoNear: [lat, lon, metros]}})",
        "option_e": "db.coleccion.nearSphere([lat, lon], metros)",
        "correct_answer": "a",
        "explanation": "$near busca documentos cercanos a un punto. Sintaxis con GeoJSON: {$near: {$geometry: {type: 'Point', coordinates: [lon, lat]}, $maxDistance: m}}. Requiere índice geoespacial 2dsphere. IMPORTANTE: longitud primero, luego latitud en GeoJSON.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué tipo de índice necesitas para consultas geoespaciales con GeoJSON?",
        "option_a": "Índice normal",
        "option_b": "Índice 2d",
        "option_c": "Índice 2dsphere",
        "option_d": "Índice text",
        "option_e": "No se necesita índice",
        "correct_answer": "c",
        "explanation": "Para consultas geoespaciales con GeoJSON (formato moderno con type y coordinates), necesitas índice 2dsphere: db.coleccion.createIndex({ubicacion: '2dsphere'}). El índice 2d es para coordenadas planas legacy. 2dsphere soporta geometrías esféricas en el modelo WGS84.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio con coordenadas GeoJSON, ¿cómo buscas listings dentro de un polígono?",
        "option_a": "db.listings_limpio.find({ubicacion: {$geoWithin: {$geometry: {type: 'Polygon', coordinates: [[[lon1,lat1], [lon2,lat2], ...]]}}}})",
        "option_b": "db.listings_limpio.find({ubicacion: {$within: {polygon: [[lat1,lon1], [lat2,lon2], ...]}}})",
        "option_c": "db.listings_limpio.find({ubicacion: {$inside: {type: 'Polygon', points: [...]}})",
        "option_d": "db.listings_limpio.withinPolygon([[lon1,lat1], [lon2,lat2], ...])",
        "option_e": "db.listings_limpio.find({ubicacion: {$polygon: [...]}})",
        "correct_answer": "a",
        "explanation": "$geoWithin encuentra documentos dentro de un área geográfica. Con GeoJSON Polygon: {$geoWithin: {$geometry: {type: 'Polygon', coordinates: [[[array de puntos]]]}}}. El polígono debe cerrarse (primer y último punto iguales). Requiere índice 2dsphere.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo usas $where para consultas con JavaScript arbitrario?",
        "option_a": "db.coleccion.find({$where: 'this.campo1 > this.campo2'})",
        "option_b": "db.coleccion.find({$where: function() { return this.campo1 > this.campo2; }})",
        "option_c": "db.coleccion.where('this.campo1 > this.campo2')",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find({$js: 'this.campo1 > this.campo2'})",
        "correct_answer": "d",
        "explanation": "$where permite JavaScript arbitrario: string o función. ADVERTENCIA: $where es lento porque ejecuta JS y no usa índices. Úsalo solo cuando otros operadores no funcionen. Alternativa moderna: $expr para expresiones que comparan campos.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo comparas dos campos del mismo documento en una consulta?",
        "option_a": "db.coleccion.find({$expr: {$gt: ['$campo1', '$campo2']}})",
        "option_b": "db.coleccion.find({campo1: {$gt: campo2}})",
        "option_c": "db.coleccion.find({$where: 'this.campo1 > this.campo2'})",
        "option_d": "Opciones a y c son correctas",
        "option_e": "No es posible comparar campos",
        "correct_answer": "d",
        "explanation": "$expr permite comparar campos usando operadores de agregación: {$expr: {$gt: ['$campo1', '$campo2']}}. Nota el $ antes del nombre de campo. $where también funciona pero es más lento. $expr es preferido y puede usar índices en algunos casos.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo buscas vuelos donde el precio_descuento es menor que precio_original?",
        "option_a": "db.infovuelos_limpio.find({$expr: {$lt: ['$precio_descuento', '$precio_original']}})",
        "option_b": "db.infovuelos_limpio.find({precio_descuento: {$lt: '$precio_original'}})",
        "option_c": "db.infovuelos_limpio.find({$where: 'this.precio_descuento < this.precio_original'})",
        "option_d": "Opciones a y c son correctas",
        "option_e": "db.infovuelos_limpio.find({$compare: ['precio_descuento', '<', 'precio_original']})",
        "correct_answer": "d",
        "explanation": "$expr con $lt es la forma moderna y eficiente: {$expr: {$lt: ['$campo1', '$campo2']}}. $where también funciona pero es más lento. Opción b no funciona porque no puedes referenciar campos directamente en operadores de comparación normales.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es el operador $mod y cuándo lo usarías?",
        "option_a": "Modifica valores",
        "option_b": "Busca documentos donde campo % divisor == resto",
        "option_c": "Calcula el módulo",
        "option_d": "Es un operador de agregación",
        "option_e": "No existe en MongoDB",
        "correct_answer": "b",
        "explanation": "$mod busca valores donde el resto de dividir por un número es específico: {campo: {$mod: [divisor, resto]}}. Ejemplo: {edad: {$mod: [2, 0]}} encuentra edades pares (divisible por 2 con resto 0). Útil para patrones numéricos.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un número es divisible por 5?",
        "option_a": "db.coleccion.find({numero: {$mod: [5, 0]}})",
        "option_b": "db.coleccion.find({numero: {$divisibleBy: 5}})",
        "option_c": "db.coleccion.find({numero % 5: 0})",
        "option_d": "db.coleccion.find({$where: 'this.numero % 5 == 0'})",
        "option_e": "Opciones a y d son correctas",
        "correct_answer": "e",
        "explanation": "$mod con resto 0 verifica divisibilidad: {campo: {$mod: [divisor, 0]}}. $where también funciona pero es menos eficiente. No existe $divisibleBy. Opción c tiene sintaxis inválida.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un array está vacío o el campo no existe?",
        "option_a": "db.coleccion.find({$or: [{array: {$size: 0}}, {array: {$exists: false}}]})",
        "option_b": "db.coleccion.find({array: []})",
        "option_c": "db.coleccion.find({array: {$in: [[], null]}})",
        "option_d": "Opción a es la más correcta",
        "option_e": "db.coleccion.find({array: {$empty: true}})",
        "correct_answer": "d",
        "explanation": "Para buscar array vacío O campo inexistente usa $or: {$or: [{campo: {$size: 0}}, {campo: {$exists: false}}]}. {array: []} solo encuentra arrays vacíos, no campos inexistentes. Esta distinción es importante en esquemas flexibles.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite por defecto de documentos retornados por el cursor en el shell?",
        "option_a": "10 documentos",
        "option_b": "20 documentos",
        "option_c": "50 documentos",
        "option_d": "100 documentos",
        "option_e": "No hay límite",
        "correct_answer": "b",
        "explanation": "El shell de MongoDB muestra 20 documentos por defecto al iterar un cursor. Escribe 'it' (iterate) para ver los siguientes 20. Este límite es solo del shell; en drivers puedes iterar todos. Para obtener todos usa .toArray() o especifica .limit().",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes solo el primer documento que coincide con el filtro sin retornar un cursor?",
        "option_a": "db.coleccion.findOne({filtro})",
        "option_b": "db.coleccion.find({filtro}).limit(1)",
        "option_c": "db.coleccion.find({filtro}).first()",
        "option_d": "db.coleccion.find({filtro})[0]",
        "option_e": "db.coleccion.getOne({filtro})",
        "correct_answer": "a",
        "explanation": "findOne() retorna el primer documento directamente (no un cursor) o null si no hay coincidencias. find().limit(1) retorna un cursor con un doc. findOne() es más simple cuando solo necesitas un documento. No existen .first() ni getOne().",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es la 'collation' en MongoDB?",
        "option_a": "Un método de compresión",
        "option_b": "Reglas de comparación de strings para sorting y matching (locale, case sensitivity, etc.)",
        "option_c": "Una técnica de indexación",
        "option_d": "Un tipo de agregación",
        "option_e": "No existe en MongoDB",
        "correct_answer": "b",
        "explanation": "Collation define reglas para comparar strings: locale, case sensitivity, accent sensitivity, etc. Ejemplo: {locale: 'es', strength: 2} para español case-insensitive. Aplica a ordenamiento, comparaciones y text search. Se especifica en find(), aggregate(), createIndex().",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo buscas nombres case-insensitive usando collation?",
        "option_a": "db.data_act_01_limpio.find({nombre: 'JUAN'}).collation({locale: 'en', strength: 2})",
        "option_b": "db.data_act_01_limpio.find({nombre: {$regex: /juan/i}})",
        "option_c": "db.data_act_01_limpio.find({nombre: 'juan'}, {collation: {locale: 'en', strength: 2}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.data_act_01_limpio.find({nombre: {$caseInsensitive: 'JUAN'}})",
        "correct_answer": "d",
        "explanation": "Collation con strength: 2 ignora case: .collation({locale: 'en', strength: 2}). Regex con flag 'i' también funciona. Collation es más eficiente con índices apropiados. Regex puede ser lento sin índice. Ambos métodos son válidos.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes el número de documentos escaneados vs documentos retornados (para diagnóstico)?",
        "option_a": "db.coleccion.find({filtro}).explain('executionStats')",
        "option_b": "db.coleccion.find({filtro}).stats()",
        "option_c": "db.coleccion.find({filtro}).count()",
        "option_d": "db.coleccion.analyze({filtro})",
        "option_e": "db.coleccion.find({filtro}).performance()",
        "correct_answer": "a",
        "explanation": "explain('executionStats') muestra: totalDocsExamined (escaneados), nReturned (retornados), executionTimeMillis, índices usados. Ideal para optimizar queries. Si totalDocsExamined >> nReturned, necesitas mejor índice. explain('queryPlanner') solo muestra el plan.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué indica si una consulta hace un COLLSCAN en explain()?",
        "option_a": "Uso eficiente de índice",
        "option_b": "Collection scan (escaneo completo de la colección) - ineficiente para colecciones grandes",
        "option_c": "Búsqueda de colisiones",
        "option_d": "Consulta colaborativa",
        "option_e": "Error en la consulta",
        "correct_answer": "b",
        "explanation": "COLLSCAN significa collection scan: MongoDB escanea TODOS los documentos de la colección sin usar índice. Es lento en colecciones grandes. Si ves COLLSCAN en explain(), considera agregar un índice apropiado. IXSCAN indica uso de índice (eficiente).",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo especificas un hint para forzar el uso de un índice específico?",
        "option_a": "db.coleccion.find({filtro}).hint({campo: 1})",
        "option_b": "db.coleccion.find({filtro}).forceIndex('nombre_indice')",
        "option_c": "db.coleccion.find({filtro}, {hint: {campo: 1}})",
        "option_d": "Opciones a y c son correctas",
        "option_e": "db.coleccion.find({filtro}).useIndex({campo: 1})",
        "correct_answer": "d",
        "explanation": ".hint({campos_del_indice}) o .hint('nombre_indice') fuerza el uso de un índice específico. Útil cuando MongoDB elige un índice subóptimo o para testing. Sintaxis: find().hint({campo: 1}) o como opción: find({}, {hint: {campo: 1}}).",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuándo deberías usar hint() para forzar un índice?",
        "option_a": "Siempre",
        "option_b": "Cuando el query planner de MongoDB elige un índice subóptimo o para testing",
        "option_c": "Nunca, MongoDB siempre elige el mejor índice",
        "option_d": "Solo en producción",
        "option_e": "Solo en MongoDB Atlas",
        "correct_answer": "b",
        "explanation": "Normalmente MongoDB elige bien el índice. Usa hint() cuando: 1) testing de performance con diferentes índices, 2) el planner elige mal (raro, pero sucede con estadísticas desactualizadas), 3) necesitas consistencia en plan de ejecución. No abuses de hint(), el planner suele ser correcto.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo limitas el tiempo máximo de ejecución de una consulta a 2 segundos?",
        "option_a": "db.listings_limpio.find({filtro}).maxTimeMS(2000)",
        "option_b": "db.listings_limpio.find({filtro}, {timeout: 2000})",
        "option_c": "db.listings_limpio.find({filtro}).timeout(2000)",
        "option_d": "db.listings_limpio.find({filtro}, {maxTime: 2000})",
        "option_e": "No es posible limitar el tiempo",
        "correct_answer": "a",
        "explanation": ".maxTimeMS(milisegundos) establece timeout para la query. Si excede el tiempo, MongoDB cancela con error. Útil para prevenir queries lentas que bloqueen recursos. Ejemplo: .maxTimeMS(2000) para 2 segundos. También disponible en aggregate(), updateOne(), etc.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'read preference' en MongoDB?",
        "option_a": "El orden preferido de lectura de campos",
        "option_b": "De qué nodo del replica set leer (primary, secondary, nearest, etc.)",
        "option_c": "La prioridad de índices",
        "option_d": "El formato de retorno preferido",
        "option_e": "No existe en MongoDB",
        "correct_answer": "b",
        "explanation": "Read preference determina de qué nodo leer en un replica set: 'primary' (solo primario, default), 'secondary' (solo secundarios), 'primaryPreferred', 'secondaryPreferred', 'nearest' (menor latencia). Permite distribuir carga de lectura y optimizar latencia.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo iteras manualmente sobre un cursor en el shell?",
        "option_a": "var cursor = db.coleccion.find(); while(cursor.hasNext()) { print(cursor.next()); }",
        "option_b": "db.coleccion.find().forEach(doc => print(doc))",
        "option_c": "for(var doc of db.coleccion.find()) { print(doc); }",
        "option_d": "Todas las opciones anteriores son correctas",
        "option_e": "db.coleccion.find().iterate()",
        "correct_answer": "d",
        "explanation": "Tres formas válidas de iterar cursores: 1) hasNext()/next() estilo tradicional, 2) forEach() con función callback, 3) for...of loop (JavaScript moderno). Todas funcionan en mongosh. Elige según preferencia de estilo.",
        "difficulty": "medium"
    },

    # ==================== CATEGORÍA 4: CRUD - UPDATE ====================
    # Preguntas 171-200 (30 de 60 totales)

    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para actualizar un único documento?",
        "option_a": "db.coleccion.updateOne({filtro}, {$set: {campo: 'nuevo_valor'}})",
        "option_b": "db.coleccion.update({filtro}, {campo: 'nuevo_valor'})",
        "option_c": "UPDATE coleccion SET campo = 'nuevo_valor' WHERE filtro",
        "option_d": "db.coleccion.update({filtro}, {$set: {campo: 'nuevo_valor'}}, {multi: false})",
        "option_e": "db.coleccion.modify({filtro}, {campo: 'nuevo_valor'})",
        "correct_answer": "a",
        "explanation": "updateOne({filtro}, {operadores_update}) actualiza el primer documento que coincide. Debes usar operadores de update como $set, no reemplazar el objeto completo (a menos que uses replaceOne). update() está deprecado, usa updateOne/updateMany.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cuál es la diferencia entre updateOne() y updateMany()?",
        "option_a": "No hay diferencia",
        "option_b": "updateOne() actualiza solo el primer documento que coincide; updateMany() actualiza todos los que coinciden",
        "option_c": "updateMany() es más rápido",
        "option_d": "updateOne() requiere _id",
        "option_e": "updateMany() está deprecado",
        "correct_answer": "b",
        "explanation": "updateOne() actualiza solo el PRIMER documento que coincide con el filtro. updateMany() actualiza TODOS los documentos que coinciden. Elige según necesites actualizar uno o múltiples. Ambos retornan matchedCount y modifiedCount.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $set?",
        "option_a": "Establece o crea un campo con un valor",
        "option_b": "Incrementa un valor",
        "option_c": "Agrega un elemento a un array",
        "option_d": "Elimina un campo",
        "option_e": "Valida el esquema",
        "correct_answer": "a",
        "explanation": "$set actualiza el valor de un campo o lo crea si no existe. Sintaxis: {$set: {campo: valor}}. Es el operador de update más común. Puedes actualizar múltiples campos: {$set: {campo1: v1, campo2: v2}}. Sin $set, reemplazarías el documento completo.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo actualizas el precio de un vuelo específico por su _id?",
        "option_a": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$set: {precio: 150}})",
        "option_b": "db.infovuelos_limpio.update({_id: '...'}, {precio: 150})",
        "option_c": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {precio: 150})",
        "option_d": "UPDATE infovuelos_limpio SET precio = 150 WHERE _id = '...'",
        "option_e": "db.infovuelos_limpio.modify({_id: ObjectId('...')}, {$set: {precio: 150}})",
        "correct_answer": "a",
        "explanation": "updateOne() con filtro por _id y $set: {_id: ObjectId('id_string')} identifica el documento, {$set: {precio: 150}} actualiza el campo. Usa ObjectId() si el _id es ObjectId, no string plano. $set es necesario para actualizar campos específicos.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas múltiples campos en una sola operación?",
        "option_a": "db.coleccion.updateOne({filtro}, {$set: {campo1: v1, campo2: v2, campo3: v3}})",
        "option_b": "db.coleccion.updateOne({filtro}, {$set: {campo1: v1}}); db.coleccion.updateOne({filtro}, {$set: {campo2: v2}})",
        "option_c": "db.coleccion.updateOne({filtro}, {campo1: v1, campo2: v2})",
        "option_d": "db.coleccion.updateOne({filtro}, [{$set: {campo1: v1}}, {$set: {campo2: v2}}])",
        "option_e": "db.coleccion.update({filtro}, {$setAll: {campo1: v1, campo2: v2}})",
        "correct_answer": "a",
        "explanation": "$set puede actualizar múltiples campos simultáneamente: {$set: {c1: v1, c2: v2, ...}}. Es más eficiente que múltiples updates separados (una sola operación al servidor). Todos los campos se actualizan atómicamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $unset?",
        "option_a": "Elimina un campo del documento",
        "option_b": "Establece un campo a null",
        "option_c": "Elimina el documento completo",
        "option_d": "Deshacer un update anterior",
        "option_e": "Limpia el valor del campo",
        "correct_answer": "a",
        "explanation": "$unset elimina un campo completamente del documento: {$unset: {campo: ''}}. El valor después del campo no importa (comúnmente se usa '' o 1). El campo desaparece del documento. Diferente de {$set: {campo: null}} que mantiene el campo con valor null.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo eliminas el campo 'descripcion_temporal' de un documento?",
        "option_a": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$unset: {descripcion_temporal: ''}})",
        "option_b": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$delete: {descripcion_temporal: true}})",
        "option_c": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$remove: 'descripcion_temporal'})",
        "option_d": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$set: {descripcion_temporal: null}})",
        "option_e": "db.listings_limpio.deleteField({_id: ObjectId('...')}, 'descripcion_temporal')",
        "correct_answer": "a",
        "explanation": "$unset elimina el campo: {$unset: {campo: valor}}. El valor puede ser cualquier cosa ('' es común). El campo se elimina completamente. Opción d establece el campo a null (el campo sigue existiendo). No existen $delete, $remove ni deleteField.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $inc?",
        "option_a": "Incluye un campo en la proyección",
        "option_b": "Incrementa (o decrementa) el valor numérico de un campo",
        "option_c": "Incrementa el contador de documentos",
        "option_d": "Inicializa un campo",
        "option_e": "Indexa un campo",
        "correct_answer": "b",
        "explanation": "$inc incrementa/decrementa un valor numérico: {$inc: {campo: cantidad}}. Valor positivo incrementa, negativo decrementa. Ejemplo: {$inc: {vistas: 1}} incrementa en 1, {$inc: {stock: -5}} decrementa en 5. Atómico y eficiente.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo incrementas el contador de vistas de un producto en 1?",
        "option_a": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$inc: {vistas: 1}})",
        "option_b": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$set: {vistas: vistas + 1}})",
        "option_c": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$increment: {vistas: 1}})",
        "option_d": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$add: {vistas: 1}})",
        "option_e": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {vistas: {$plus: 1}})",
        "correct_answer": "a",
        "explanation": "$inc es el operador correcto para incrementar: {$inc: {campo: cantidad}}. Es atómico y no requiere leer el valor actual. Opción b tiene sintaxis inválida (no puedes referenciar el valor actual así). No existen $increment, $add ni $plus.",
        "difficulty": "easy",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $mul?",
        "option_a": "Multiplica el valor de un campo por un número",
        "option_b": "Suma múltiples valores",
        "option_c": "Actualiza múltiples documentos",
        "option_d": "Multiplica arrays",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$mul multiplica el valor de un campo por un número: {$mul: {campo: multiplicador}}. Ejemplo: {$mul: {precio: 1.1}} aumenta el precio 10%. Si el campo no existe, se crea con valor 0. Útil para ajustes porcentuales.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo reduces todos los precios en listings_limpio en un 20% (aplicar descuento)?",
        "option_a": "db.listings_limpio.updateMany({}, {$mul: {precio: 0.8}})",
        "option_b": "db.listings_limpio.updateMany({}, {$mul: {precio: 0.2}})",
        "option_c": "db.listings_limpio.updateMany({}, {$dec: {precio: 0.2}})",
        "option_d": "db.listings_limpio.updateMany({}, {$set: {precio: precio * 0.8}})",
        "option_e": "db.listings_limpio.updateMany({}, {$inc: {precio: -0.2}})",
        "correct_answer": "a",
        "explanation": "Para reducir 20%, multiplica por 0.8 (80% del valor original): {$mul: {precio: 0.8}}. updateMany({}) sin filtro actualiza TODOS los documentos. $mul es el operador correcto para cambios porcentuales. 0.2 sería reducir a 20% (incorrecto).",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $min?",
        "option_a": "Actualiza el campo solo si el nuevo valor es MENOR que el actual",
        "option_b": "Encuentra el valor mínimo",
        "option_c": "Reduce el valor al mínimo permitido",
        "option_d": "Elimina el valor menor",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$min actualiza el campo solo si el nuevo valor es menor que el actual: {$min: {campo: valor}}. Si el campo no existe, lo crea con el valor. Útil para mantener el valor mínimo. $max es el opuesto (actualiza si el nuevo es mayor).",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $max?",
        "option_a": "Actualiza el campo solo si el nuevo valor es MAYOR que el actual",
        "option_b": "Encuentra el valor máximo",
        "option_c": "Aumenta el valor al máximo permitido",
        "option_d": "Elimina el valor mayor",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$max actualiza el campo solo si el nuevo valor es mayor que el actual: {$max: {campo: valor}}. Si el campo no existe, lo crea con el valor. Útil para mantener el valor máximo histórico. Ejemplo: {$max: {precio_max: 200}} mantiene el precio más alto visto.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo actualizas el precio_minimo solo si el nuevo precio es menor?",
        "option_a": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$min: {precio_minimo: 120}})",
        "option_b": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$set: {precio_minimo: Math.min(precio_minimo, 120)}})",
        "option_c": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$setMin: {precio_minimo: 120}})",
        "option_d": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$min: {precio_minimo: {$lt: 120}}})",
        "option_e": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$update: {precio_minimo: 'min', value: 120}})",
        "correct_answer": "a",
        "explanation": "$min compara y actualiza automáticamente: {$min: {campo: valor}}. Si 120 < precio_minimo actual, actualiza a 120. Si 120 >= actual, no hace nada. Es atómico y no requiere leer primero. Opción b tiene sintaxis inválida.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $rename?",
        "option_a": "Renombra un campo",
        "option_b": "Renombra la colección",
        "option_c": "Renombra la base de datos",
        "option_d": "Cambia el valor de un campo",
        "option_e": "Renombra el _id",
        "correct_answer": "a",
        "explanation": "$rename cambia el nombre de un campo: {$rename: {nombreViejo: 'nombreNuevo'}}. El valor se mantiene. Si el campo de destino ya existe, se sobrescribe. Si el campo origen no existe, no hace nada. Útil para refactorizaciones de esquema.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo renombras el campo 'titulo' a 'nombre' en todos los documentos de listings_limpio?",
        "option_a": "db.listings_limpio.updateMany({}, {$rename: {titulo: 'nombre'}})",
        "option_b": "db.listings_limpio.updateMany({}, {$rename: {titulo: {$to: 'nombre'}}})",
        "option_c": "db.listings_limpio.renameField('titulo', 'nombre')",
        "option_d": "db.listings_limpio.updateMany({}, {$set: {nombre: '$titulo'}, $unset: {titulo: ''}})",
        "option_e": "ALTER TABLE listings_limpio RENAME COLUMN titulo TO nombre",
        "correct_answer": "a",
        "explanation": "$rename con updateMany actualiza todos: {$rename: {viejoNombre: 'nuevoNombre'}}. Cambia el nombre del campo en todos los documentos que lo tienen. El valor se preserva. No existe renameField() ni sintaxis SQL en MongoDB.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $currentDate?",
        "option_a": "Establece un campo con la fecha/hora actual del servidor",
        "option_b": "Filtra por fecha actual",
        "option_c": "Valida que una fecha sea actual",
        "option_d": "Formatea la fecha actual",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$currentDate establece un campo con la fecha/hora actual del servidor: {$currentDate: {campo: true}} (Date) o {campo: {$type: 'timestamp'}} (Timestamp). Útil para campos lastModified, updatedAt. Usa la hora del servidor, no del cliente.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas un documento y estableces automáticamente el campo 'ultima_modificacion' con la fecha actual?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {campo: valor}, $currentDate: {ultima_modificacion: true}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {campo: valor, ultima_modificacion: new Date()}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {campo: valor}, $timestamp: {ultima_modificacion: true}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {campo: valor}, $now: 'ultima_modificacion'})",
        "correct_answer": "d",
        "explanation": "Ambas funcionan: $currentDate usa fecha del servidor: {$currentDate: {campo: true}}. $set con new Date() usa fecha del cliente. $currentDate es preferible para consistencia (todos los nodos usan la misma hora). Puedes combinar múltiples operadores: {$set: {...}, $currentDate: {...}}.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $push en arrays?",
        "option_a": "Agrega un elemento al final de un array",
        "option_b": "Elimina un elemento del array",
        "option_c": "Ordena el array",
        "option_d": "Busca en el array",
        "option_e": "Invierte el array",
        "correct_answer": "a",
        "explanation": "$push agrega un elemento al final de un array: {$push: {array: valor}}. Si el array no existe, lo crea. Permite duplicados. Para evitar duplicados usa $addToSet. $push puede combinarse con modificadores como $each, $slice, $sort, $position.",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo agregas un nuevo comentario al array de comentarios?",
        "option_a": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$push: {comentarios: {autor: 'Juan', texto: 'Excelente'}}})",
        "option_b": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$add: {comentarios: {autor: 'Juan', texto: 'Excelente'}}})",
        "option_c": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$append: {comentarios: {autor: 'Juan', texto: 'Excelente'}}})",
        "option_d": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$set: {comentarios: [...comentarios, {autor: 'Juan'}]}})",
        "option_e": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$insert: {comentarios: {autor: 'Juan', texto: 'Excelente'}}})",
        "correct_answer": "a",
        "explanation": "$push agrega al array: {$push: {array: valor}}. El valor puede ser cualquier tipo, incluyendo objetos. $push funciona atómicamente sin necesidad de leer primero el array. No existen $add, $append ni $insert para arrays.",
        "difficulty": "easy",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $addToSet?",
        "option_a": "Agrega un elemento al array solo si no existe (evita duplicados)",
        "option_b": "Crea un nuevo conjunto",
        "option_c": "Agrega múltiples elementos",
        "option_d": "Es lo mismo que $push",
        "option_e": "Elimina elementos del array",
        "correct_answer": "a",
        "explanation": "$addToSet agrega un elemento al array solo si no existe ya: {$addToSet: {array: valor}}. Evita duplicados. Si el valor ya está en el array, no hace nada. Útil para conjuntos de valores únicos como tags. Si el array no existe, lo crea.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia principal entre $push y $addToSet?",
        "option_a": "No hay diferencia",
        "option_b": "$push permite duplicados; $addToSet evita duplicados",
        "option_c": "$addToSet es más rápido",
        "option_d": "$push solo funciona con números",
        "option_e": "$addToSet está deprecado",
        "correct_answer": "b",
        "explanation": "$push SIEMPRE agrega el elemento, permitiendo duplicados. $addToSet agrega solo si el valor NO existe, evitando duplicados. Usa $push para listas con orden (ej: comentarios cronológicos). Usa $addToSet para conjuntos únicos (ej: tags).",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo agregas un tag 'wifi' solo si no existe ya?",
        "option_a": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$addToSet: {tags: 'wifi'}})",
        "option_b": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$push: {tags: 'wifi'}})",
        "option_c": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$pushUnique: {tags: 'wifi'}})",
        "option_d": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$addIfNotExists: {tags: 'wifi'}})",
        "option_e": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$set: {tags: {$unique: 'wifi'}}})",
        "correct_answer": "a",
        "explanation": "$addToSet garantiza unicidad: {$addToSet: {array: valor}}. Si 'wifi' ya está en tags, no hace nada. Si no está, lo agrega. Ideal para tags, categorías, conjuntos. $push agregaría el duplicado. No existen $pushUnique ni $addIfNotExists.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $pull?",
        "option_a": "Elimina todos los elementos de un array que coinciden con una condición",
        "option_b": "Extrae un elemento del array",
        "option_c": "Obtiene valores del array",
        "option_d": "Tira elementos al final",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$pull elimina TODOS los elementos del array que coinciden con la condición: {$pull: {array: valor}} o {$pull: {array: {condición}}}. Elimina múltiples coincidencias en una operación. Para eliminar por posición usa $pop o $unset con índice.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas todos los comentarios de un usuario específico del array de comentarios?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pull: {comentarios: {autor: 'Juan'}}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$remove: {comentarios: {autor: 'Juan'}}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$delete: {comentarios: {autor: 'Juan'}}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$unset: {'comentarios.autor': 'Juan'}})",
        "option_e": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pop: {comentarios: {autor: 'Juan'}}})",
        "correct_answer": "a",
        "explanation": "$pull con condición elimina todos los elementos que coinciden: {$pull: {array: {campo: valor}}}. Elimina todos los subdocumentos donde autor === 'Juan'. Muy útil para arrays de objetos. No existen $remove ni $delete.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $pop?",
        "option_a": "Elimina el primer elemento (con -1) o el último (con 1) de un array",
        "option_b": "Elimina elementos por valor",
        "option_c": "Elimina duplicados",
        "option_d": "Elimina todos los elementos",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$pop elimina elementos por posición: {$pop: {array: 1}} elimina el último, {$pop: {array: -1}} elimina el primero. Solo acepta 1 o -1. Para eliminar por valor usa $pull. Para eliminar por índice usa $unset con dot notation.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas el último elemento de un array de tags?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pop: {tags: 1}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pop: {tags: -1}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pop: {tags: 'last'}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$removeLast: {tags: true}})",
        "option_e": "db.coleccion.updateOne({_id: ObjectId('...')}, {$shift: {tags: 1}})",
        "correct_answer": "a",
        "explanation": "$pop con 1 elimina el ÚLTIMO elemento: {$pop: {array: 1}}. Con -1 elimina el PRIMERO: {$pop: {array: -1}}. Solo acepta estos valores. Recuerda: 1 = último (como array.pop()), -1 = primero (como array.shift()).",
        "difficulty": "easy"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo agregas múltiples elementos a un array en una sola operación?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: {$each: ['elem1', 'elem2', 'elem3']}}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pushAll: {array: ['elem1', 'elem2', 'elem3']}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: ['elem1', 'elem2', 'elem3']}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$addMany: {array: ['elem1', 'elem2', 'elem3']}})",
        "option_e": "db.coleccion.updateOne({_id: ObjectId('...')}, {$insertMany: {array: ['elem1', 'elem2', 'elem3']}})",
        "correct_answer": "a",
        "explanation": "$push con modificador $each agrega múltiples elementos: {$push: {array: {$each: [valores]}}}. $pushAll está deprecado. Sin $each, opción c agregaría el array completo como un solo elemento (array anidado). $each es el método correcto.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo agregas múltiples escalas de una vez al array escalas?",
        "option_a": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$push: {escalas: {$each: ['MAD', 'BCN', 'PAR']}}})",
        "option_b": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$push: {escalas: ['MAD', 'BCN', 'PAR']}})",
        "option_c": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$pushMany: {escalas: ['MAD', 'BCN', 'PAR']}})",
        "option_d": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$addAll: {escalas: ['MAD', 'BCN', 'PAR']}})",
        "option_e": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$set: {escalas: {$concat: ['MAD', 'BCN', 'PAR']}}})",
        "correct_answer": "a",
        "explanation": "$push con $each agrega múltiples elementos individualmente: {$push: {array: {$each: [v1, v2, v3]}}}. Opción b agregaría el array completo como un elemento (escalas tendría [['MAD', 'BCN', 'PAR']]). $each es esencial para agregar múltiples elementos.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    }
]

# Total Batch 4: 50 preguntas
# Categoría 3 (CRUD - Read): 20 preguntas finales (completando las 80) ✅
# Categoría 4 (CRUD - Update): 30 de 60 preguntas

# ==================== BATCH 5: Preguntas 201-250 ====================
# Categoría 4: CRUD - Update (30 preguntas finales)
# Categoría 5: CRUD - Delete (20 preguntas iniciales)

QUESTIONS_BATCH_5 = [
    # ==================== CATEGORÍA 4: CRUD - UPDATE (últimas 30 preguntas) ====================
    # Preguntas 201-230

    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas un elemento específico de un array por su posición?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {'array.2': 'nuevo_valor'}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {array[2]: 'nuevo_valor'}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$updateAt: {array: {index: 2, value: 'nuevo_valor'}}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {array: {2: 'nuevo_valor'}}})",
        "option_e": "db.coleccion.updateOne({_id: ObjectId('...')}, {$arrayUpdate: {array: [2, 'nuevo_valor']}})",
        "correct_answer": "a",
        "explanation": "Usa dot notation con índice: {'array.índice': valor}. Las comillas son necesarias. Índices comienzan en 0. Ejemplo: {'tags.0': 'nuevo'} actualiza el primer elemento. No puedes usar sintaxis [índice] de JavaScript.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador posicional $ en updates de arrays?",
        "option_a": "Actualiza el primer elemento del array que coincide con la condición de filtro",
        "option_b": "Actualiza todos los elementos del array",
        "option_c": "Actualiza el último elemento",
        "option_d": "Elimina el elemento",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "El operador posicional $ actualiza el PRIMER elemento del array que coincide con el filtro de la query: {$set: {'array.$': valor}}. Ejemplo: find({tags: 'viejo'}).update({$set: {'tags.$': 'nuevo'}}) actualiza el primer 'viejo' encontrado.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para listings_limpio con array tags, ¿cómo cambias 'piscina' a 'alberca' si existe?",
        "option_a": "db.listings_limpio.updateOne({tags: 'piscina'}, {$set: {'tags.$': 'alberca'}})",
        "option_b": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$replace: {tags: {'piscina': 'alberca'}}})",
        "option_c": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$set: {tags: {$replace: ['piscina', 'alberca']}}})",
        "option_d": "db.listings_limpio.updateOne({tags: 'piscina'}, {$pull: {tags: 'piscina'}, $push: {tags: 'alberca'}})",
        "option_e": "db.listings_limpio.updateOne({tags: 'piscina'}, {$rename: {'tags.piscina': 'alberca'}})",
        "correct_answer": "a",
        "explanation": "El operador posicional $ actualiza el elemento que coincide con el filtro: {tags: 'piscina'} identifica el doc y el elemento, {'tags.$': 'alberca'} actualiza ese elemento específico. Más eficiente que $pull + $push.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $[] (all positional)?",
        "option_a": "Actualiza TODOS los elementos de un array",
        "option_b": "Actualiza el primer elemento",
        "option_c": "Actualiza el último elemento",
        "option_d": "Filtra elementos del array",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$[] actualiza TODOS los elementos de un array: {$set: {'array.$[]': valor}}. Útil cuando quieres aplicar el mismo cambio a todos los elementos. Diferente de $ que actualiza solo el primero que coincide.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas todos los elementos de un array que cumplen una condición específica?",
        "option_a": "db.coleccion.updateOne({}, {$set: {'array.$[elem]': valor}}, {arrayFilters: [{'elem': condición}]})",
        "option_b": "db.coleccion.updateOne({}, {$set: {'array.*': valor}}, {where: condición})",
        "option_c": "db.coleccion.updateOne({}, {$setAll: {array: valor}})",
        "option_d": "db.coleccion.updateOne({}, {$set: {'array.$each': valor}})",
        "option_e": "No es posible actualizar con condiciones",
        "correct_answer": "a",
        "explanation": "$[identificador] con arrayFilters actualiza elementos que cumplen condición: {$set: {'array.$[elem]': valor}}, {arrayFilters: [{'elem.campo': condición}]}. Muy poderoso para updates condicionales en arrays. Introducido en MongoDB 3.6.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio con array de precios [{tipo: 'normal', valor: 100}, {tipo: 'descuento', valor: 80}], ¿cómo incrementas solo los precios tipo 'normal' en 10?",
        "option_a": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$inc: {'precios.$[elem].valor': 10}}, {arrayFilters: [{'elem.tipo': 'normal'}]})",
        "option_b": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$inc: {'precios.normal.valor': 10}})",
        "option_c": "db.data_act_01_limpio.updateOne({'precios.tipo': 'normal'}, {$inc: {'precios.$.valor': 10}})",
        "option_d": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$inc: {'precios.*.valor': 10}})",
        "option_e": "No es posible con una sola query",
        "correct_answer": "a",
        "explanation": "arrayFilters permite actualizar elementos específicos basados en condición: {$inc: {'array.$[id].campo': valor}}, {arrayFilters: [{'id.campo': condición}]}. 'elem' es un identificador personalizado. Muy útil para arrays de objetos complejos.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace el operador $pullAll?",
        "option_a": "Elimina todos los valores especificados de un array",
        "option_b": "Elimina todos los elementos del array",
        "option_c": "Extrae todos los valores únicos",
        "option_d": "Es lo mismo que $pull",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$pullAll elimina múltiples valores específicos de un array: {$pullAll: {array: [valor1, valor2, ...]}}. Diferente de $pull que usa condiciones. $pullAll es para eliminar valores exactos. Ejemplo: {$pullAll: {tags: ['viejo1', 'viejo2']}}.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas múltiples tags específicos de un array en una sola operación?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pullAll: {tags: ['tag1', 'tag2', 'tag3']}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pull: {tags: ['tag1', 'tag2', 'tag3']}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$removeAll: {tags: ['tag1', 'tag2', 'tag3']}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$deleteMany: {tags: ['tag1', 'tag2', 'tag3']}})",
        "option_e": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pull: {tags: {$in: ['tag1', 'tag2', 'tag3']}}})",
        "correct_answer": "a",
        "explanation": "$pullAll es la forma directa: {$pullAll: {array: [valores]}}. Opción e también funciona: {$pull: {array: {$in: [valores]}}} pero es más verbosa. $pullAll es más clara para eliminar múltiples valores exactos.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un elemento en una posición específica de un array?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: {$each: ['nuevo'], $position: 2}}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$insertAt: {array: {value: 'nuevo', index: 2}}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {'array.2': 'nuevo'}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: {value: 'nuevo', position: 2}}})",
        "option_e": "No es posible insertar en posición específica",
        "correct_answer": "a",
        "explanation": "$push con modificador $position inserta en posición específica: {$push: {array: {$each: [valores], $position: índice}}}. $position: 0 inserta al inicio, $position: -1 o sin $position inserta al final. $each es requerido incluso para un elemento.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo limitas el tamaño de un array mientras agregas elementos?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: {$each: ['nuevo'], $slice: -10}}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: 'nuevo'}, $maxSize: 10})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: {value: 'nuevo', limit: 10}}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pushLimited: {array: {value: 'nuevo', max: 10}}})",
        "option_e": "No es posible limitar el tamaño automáticamente",
        "correct_answer": "a",
        "explanation": "$push con modificador $slice mantiene tamaño limitado: {$push: {array: {$each: [valores], $slice: n}}}. $slice: -10 mantiene últimos 10 elementos, $slice: 10 mantiene primeros 10. Útil para mantener historial limitado (ej: últimas 10 compras).",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo agregas una nueva escala manteniendo solo las últimas 5?",
        "option_a": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$push: {escalas: {$each: ['MAD'], $slice: -5}}})",
        "option_b": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$push: {escalas: 'MAD'}, $keepLast: 5})",
        "option_c": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$pushAndTrim: {escalas: {value: 'MAD', max: 5}}})",
        "option_d": "db.infovuelos_limpio.updateOne({_id: ObjectId('...')}, {$push: {escalas: 'MAD'}, $limit: 5})",
        "option_e": "Necesitas dos operaciones: push y luego trim",
        "correct_answer": "a",
        "explanation": "$slice: -5 mantiene los últimos 5 elementos después del push: {$push: {escalas: {$each: ['MAD'], $slice: -5}}}. Operación atómica. $each es requerido incluso para un elemento cuando usas modificadores como $slice.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo ordenas un array mientras agregas elementos?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: {$each: [valores], $sort: 1}}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: [valores]}, $orderBy: 1})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$pushAndSort: {array: {values: [valores], order: 'asc'}}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$push: {array: [valores]}, $sort: {asc: true}})",
        "option_e": "No es posible ordenar automáticamente",
        "correct_answer": "a",
        "explanation": "$push con modificador $sort ordena el array después de agregar: {$push: {array: {$each: [valores], $sort: 1}}} (ascendente) o {$sort: -1} (descendente). Para arrays de objetos: {$sort: {campo: 1}}. Útil para mantener arrays ordenados.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué operadores se pueden combinar con $push?",
        "option_a": "$each, $position, $slice, $sort",
        "option_b": "Solo $each",
        "option_c": "$each, $where, $limit",
        "option_d": "$append, $prepend, $sort",
        "option_e": "No se pueden combinar operadores",
        "correct_answer": "a",
        "explanation": "$push soporta modificadores: $each (múltiples), $position (posición), $slice (limitar tamaño), $sort (ordenar). Puedes combinarlos: {$push: {array: {$each: [...], $position: 0, $sort: 1, $slice: 10}}}. Se aplican en orden: push → position → sort → slice.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace replaceOne()?",
        "option_a": "Reemplaza completamente un documento con uno nuevo (mantiene solo el _id)",
        "option_b": "Es lo mismo que updateOne()",
        "option_c": "Actualiza campos específicos",
        "option_d": "Reemplaza un campo por otro",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "replaceOne({filtro}, {documento_nuevo}) reemplaza TODO el documento excepto _id: el nuevo documento reemplaza completamente al anterior. Diferente de updateOne que usa operadores como $set. replaceOne es útil cuando quieres reconstruir el documento completo.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre updateOne con $set y replaceOne?",
        "option_a": "No hay diferencia",
        "option_b": "updateOne con $set actualiza campos específicos; replaceOne reemplaza el documento completo",
        "option_c": "replaceOne es más rápido",
        "option_d": "updateOne está deprecado",
        "option_e": "replaceOne solo funciona con _id",
        "correct_answer": "b",
        "explanation": "updateOne({filtro}, {$set: {campos}}) actualiza solo campos especificados, preserva otros campos. replaceOne({filtro}, {nuevo_doc}) reemplaza TODO el documento (excepto _id), elimina campos no incluidos. Usa replaceOne cuando quieres redefinir completamente el documento.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué hace la opción {upsert: true} en updates?",
        "option_a": "Inserta el documento si no existe, actualiza si existe",
        "option_b": "Actualiza solo si existe",
        "option_c": "Inserta múltiples documentos",
        "option_d": "Encripta la actualización",
        "option_e": "Valida el esquema",
        "correct_answer": "a",
        "explanation": "upsert (update + insert) inserta si no hay match, actualiza si hay match: updateOne({filtro}, {update}, {upsert: true}). Útil para operaciones idempotentes. Si no existe doc con el filtro, crea uno con el filtro + update. Si existe, actualiza normalmente.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo creas un contador de vistas que se incrementa, creando el documento si no existe?",
        "option_a": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$inc: {vistas: 1}}, {upsert: true})",
        "option_b": "db.listings_limpio.insertOrUpdate({_id: ObjectId('...')}, {$inc: {vistas: 1}})",
        "option_c": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$inc: {vistas: 1}}, {createIfNotExists: true})",
        "option_d": "db.listings_limpio.upsert({_id: ObjectId('...')}, {vistas: 1})",
        "option_e": "Necesitas verificar existencia primero con findOne",
        "correct_answer": "a",
        "explanation": "{upsert: true} con $inc crea el documento si no existe (con vistas: 1) o incrementa si existe. Es atómico y no requiere dos operaciones. Patrón común para contadores. Sin upsert, el update fallaría si no existe el documento.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué operador se usa para establecer un valor solo si el campo no existe?",
        "option_a": "$setOnInsert",
        "option_b": "$setIfNotExists",
        "option_c": "$initField",
        "option_d": "$default",
        "option_e": "$createIfMissing",
        "correct_answer": "a",
        "explanation": "$setOnInsert establece valores solo cuando se realiza un insert (con upsert): {$setOnInsert: {campo: valor}}. Si el doc ya existe y se actualiza, $setOnInsert no hace nada. Útil para campos de inicialización como createdAt que solo se establecen al crear.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo estableces createdAt solo al crear un documento con upsert, y updatedAt siempre?",
        "option_a": "db.coleccion.updateOne({_id: id}, {$set: {campo: valor}, $setOnInsert: {createdAt: new Date()}, $currentDate: {updatedAt: true}}, {upsert: true})",
        "option_b": "db.coleccion.updateOne({_id: id}, {$set: {campo: valor, createdAt: new Date(), updatedAt: new Date()}}, {upsert: true})",
        "option_c": "db.coleccion.upsert({_id: id}, {campo: valor, createdAt: new Date(), updatedAt: new Date()})",
        "option_d": "db.coleccion.updateOne({_id: id}, {$init: {createdAt: new Date()}, $set: {updatedAt: new Date()}})",
        "option_e": "No es posible en una sola operación",
        "correct_answer": "a",
        "explanation": "Combina operadores: $setOnInsert para campos de creación (solo al insertar), $currentDate/$set para campos que siempre se actualizan. Si es insert: aplica ambos. Si es update: solo aplica $set/$currentDate. Patrón común para timestamps.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué retorna updateOne() tras una actualización exitosa?",
        "option_a": "Un objeto con matchedCount, modifiedCount, y acknowledged",
        "option_b": "El documento actualizado",
        "option_c": "true o false",
        "option_d": "El número de documentos actualizados",
        "option_e": "Nada (void)",
        "correct_answer": "a",
        "explanation": "updateOne() retorna: {acknowledged: true/false, matchedCount: n, modifiedCount: m, upsertedId: id}. matchedCount: docs que coinciden con filtro. modifiedCount: docs realmente modificados (puede ser 0 si el valor ya era el mismo). upsertedId solo si hizo insert con upsert.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "conceptual",
        "question_text": "¿Por qué matchedCount puede ser 1 pero modifiedCount 0?",
        "option_a": "Es un error",
        "option_b": "El documento ya tenía el valor que intentaste establecer (no hubo cambio real)",
        "option_c": "El update falló parcialmente",
        "option_d": "El documento está bloqueado",
        "option_e": "matchedCount siempre es igual a modifiedCount",
        "correct_answer": "b",
        "explanation": "Si haces updateOne({_id: id}, {$set: {status: 'active'}}) pero status ya era 'active', matchedCount = 1 (encontró el doc) pero modifiedCount = 0 (no cambió nada). modifiedCount cuenta cambios REALES en los datos.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas un campo anidado profundo usando dot notation?",
        "option_a": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {'nivel1.nivel2.nivel3.campo': 'valor'}})",
        "option_b": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {nivel1: {nivel2: {nivel3: {campo: 'valor'}}}}})",
        "option_c": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {nivel1->nivel2->nivel3->campo: 'valor'}})",
        "option_d": "db.coleccion.updateOne({_id: ObjectId('...')}, {$set: {nivel1[nivel2][nivel3][campo]: 'valor'}})",
        "option_e": "No es posible actualizar campos anidados profundos",
        "correct_answer": "a",
        "explanation": "Dot notation con comillas actualiza campos anidados: {'nivel1.nivel2.campo': valor}. No reemplaza el objeto completo, solo actualiza el campo específico. Opción b reemplazaría toda la estructura, eliminando otros campos de nivel1, nivel2, nivel3.",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio con estructura {detalles: {envio: {direccion: {...}}}}, ¿cómo actualizas solo la calle?",
        "option_a": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$set: {'detalles.envio.direccion.calle': 'Nueva Calle'}})",
        "option_b": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$set: {detalles: {envio: {direccion: {calle: 'Nueva Calle'}}}}})",
        "option_c": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$set: {detalles.envio.direccion.calle: 'Nueva Calle'}})",
        "option_d": "db.data_act_01_limpio.updateOne({_id: ObjectId('...')}, {$update: {'detalles.envio.direccion.calle': 'Nueva Calle'}})",
        "option_e": "Necesitas usar aggregate pipeline",
        "correct_answer": "a",
        "explanation": "Dot notation permite actualizar campos anidados profundos sin afectar otros: {'objeto.subobjeto.campo': valor}. Las comillas son obligatorias. Opción b sobrescribiría toda la estructura detalles, eliminando otros campos.",
        "difficulty": "easy",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 4,
        "question_type": "conceptual",
        "question_text": "¿Los updates en MongoDB son atómicos?",
        "option_a": "No, nunca son atómicos",
        "option_b": "Sí, cada operación updateOne/updateMany es atómica a nivel de documento",
        "option_c": "Solo con transacciones",
        "option_d": "Depende del motor de almacenamiento",
        "option_e": "Solo updateOne es atómico, updateMany no",
        "correct_answer": "b",
        "explanation": "Los updates son atómicos A NIVEL DE DOCUMENTO: todo el update se aplica o nada. Nadie puede ver el documento en estado intermedio. updateMany es atómico por cada documento, pero no entre documentos. Para atomicidad entre múltiples docs, usa transacciones (MongoDB 4.0+).",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo combinas múltiples operadores de update en una sola operación?",
        "option_a": "db.coleccion.updateOne({_id: id}, {$set: {campo1: v1}, $inc: {campo2: 1}, $push: {array: 'valor'}})",
        "option_b": "db.coleccion.updateOne({_id: id}, [$set: {campo1: v1}, $inc: {campo2: 1}])",
        "option_c": "Necesitas múltiples updateOne() separados",
        "option_d": "db.coleccion.updateOne({_id: id}, {$operations: [{$set: {...}}, {$inc: {...}}]})",
        "option_e": "Solo puedes usar un operador por update",
        "correct_answer": "a",
        "explanation": "Puedes combinar múltiples operadores en un update: {$set: {...}, $inc: {...}, $push: {...}, ...}. Todos se aplican atómicamente en una operación. Más eficiente que múltiples updates. Operadores se aplican en orden específico (ej: $set antes de $inc).",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Qué es un aggregation pipeline update?",
        "option_a": "Usar pipeline de agregación en el update para transformaciones complejas",
        "option_b": "Un tipo de índice",
        "option_c": "Un método de importación de datos",
        "option_d": "Una técnica de replicación",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "MongoDB 4.2+ permite usar aggregation pipeline en updates: updateOne({filtro}, [{$set: {campo: {$expr}}}]). Nota los corchetes []. Permite transformaciones complejas como calcular nuevos valores basados en otros campos. Más poderoso que operadores estándar.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo calculas un campo basado en otros campos del mismo documento durante un update?",
        "option_a": "db.coleccion.updateOne({_id: id}, [{$set: {total: {$add: ['$precio', '$impuesto']}}}])",
        "option_b": "db.coleccion.updateOne({_id: id}, {$set: {total: '$precio + $impuesto'}})",
        "option_c": "db.coleccion.updateOne({_id: id}, {$calc: {total: {precio: '+', impuesto: true}}})",
        "option_d": "db.coleccion.updateOne({_id: id}, {$set: {total: {$compute: 'precio + impuesto'}}})",
        "option_e": "No es posible, necesitas leer primero",
        "correct_answer": "a",
        "explanation": "Aggregation pipeline update permite cálculos: [{$set: {campo: {expresión_agregación}}}]. Usa operadores de agregación como $add, $multiply, $concat. Los campos se referencian con '$campo'. Es atómico, no necesitas leer primero.",
        "difficulty": "hard"
    },
    {
        "category_id": 4,
        "question_type": "conceptual",
        "question_text": "¿Cuándo deberías usar aggregation pipeline update en lugar de operadores estándar?",
        "option_a": "Siempre",
        "option_b": "Cuando necesitas calcular valores basados en otros campos, transformaciones complejas, o lógica condicional",
        "option_c": "Nunca, están deprecados",
        "option_d": "Solo para updates masivos",
        "option_e": "Solo en MongoDB Atlas",
        "correct_answer": "b",
        "explanation": "Usa pipeline update cuando: 1) calculas valores basados en otros campos del doc, 2) necesitas lógica condicional ($cond), 3) transformaciones complejas de strings/arrays. Para updates simples ($set, $inc), usa operadores estándar (más simples y directos).",
        "difficulty": "medium"
    },
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo calculas y estableces el campo precio_con_iva como precio * 1.21 en un update?",
        "option_a": "db.listings_limpio.updateOne({_id: ObjectId('...')}, [{$set: {precio_con_iva: {$multiply: ['$precio', 1.21]}}}])",
        "option_b": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$set: {precio_con_iva: '$precio * 1.21'}})",
        "option_c": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$calc: {precio_con_iva: {$mul: ['precio', 1.21]}}})",
        "option_d": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$set: {precio_con_iva: {$eval: 'precio * 1.21'}}})",
        "option_e": "Necesitas aggregate y luego $merge",
        "correct_answer": "a",
        "explanation": "Aggregation pipeline update con $multiply: [{$set: {campo: {$multiply: ['$otrocampo', valor]}}}]. Nota: array [] para pipeline, '$campo' para referenciar campos. Es atómico y eficiente. No necesitas aggregate + $merge.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },

    # ==================== CATEGORÍA 5: CRUD - DELETE ====================
    # Preguntas 231-250 (20 de 50 totales)

    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para eliminar un único documento?",
        "option_a": "db.coleccion.deleteOne({filtro})",
        "option_b": "db.coleccion.remove({filtro})",
        "option_c": "DELETE FROM coleccion WHERE filtro",
        "option_d": "db.coleccion.delete({filtro})",
        "option_e": "db.coleccion.removeOne({filtro})",
        "correct_answer": "a",
        "explanation": "deleteOne({filtro}) elimina el PRIMER documento que coincide con el filtro. remove() está deprecado, usa deleteOne/deleteMany. deleteOne es más explícito y seguro que remove. Retorna el número de documentos eliminados.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cuál es la diferencia entre deleteOne() y deleteMany()?",
        "option_a": "No hay diferencia",
        "option_b": "deleteOne() elimina solo el primer documento que coincide; deleteMany() elimina todos los que coinciden",
        "option_c": "deleteMany() es más rápido",
        "option_d": "deleteOne() requiere _id",
        "option_e": "deleteMany() está deprecado",
        "correct_answer": "b",
        "explanation": "deleteOne() elimina solo el PRIMER documento que coincide. deleteMany() elimina TODOS los documentos que coinciden con el filtro. Usa deleteOne cuando quieres eliminar un documento específico (ej: por _id). Usa deleteMany para eliminación masiva.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo eliminas un vuelo específico por su _id?",
        "option_a": "db.infovuelos_limpio.deleteOne({_id: ObjectId('...')})",
        "option_b": "db.infovuelos_limpio.remove({_id: ObjectId('...')})",
        "option_c": "DELETE FROM infovuelos_limpio WHERE _id = '...'",
        "option_d": "db.infovuelos_limpio.delete({_id: ObjectId('...')})",
        "option_e": "db.infovuelos_limpio.drop({_id: ObjectId('...')})",
        "correct_answer": "a",
        "explanation": "deleteOne({_id: ObjectId('id_string')}) elimina el documento con ese _id. Si el _id es ObjectId, usa ObjectId(), no solo el string. deleteOne es el método moderno. remove() está deprecado. drop() elimina la colección completa.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas todos los documentos que cumplen una condición?",
        "option_a": "db.coleccion.deleteMany({condición})",
        "option_b": "db.coleccion.deleteAll({condición})",
        "option_c": "db.coleccion.removeAll({condición})",
        "option_d": "db.coleccion.delete({condición}, {multi: true})",
        "option_e": "db.coleccion.deleteOne({condición}).all()",
        "correct_answer": "a",
        "explanation": "deleteMany({filtro}) elimina TODOS los documentos que coinciden. PRECAUCIÓN: deleteMany({}) sin filtro elimina TODOS los documentos de la colección (pero no la colección misma). Verifica tu filtro antes de ejecutar.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo eliminas todos los listings con precio mayor a 1000?",
        "option_a": "db.listings_limpio.deleteMany({precio: {$gt: 1000}})",
        "option_b": "db.listings_limpio.deleteAll({precio: {$gt: 1000}})",
        "option_c": "db.listings_limpio.removeMany({precio: {$gt: 1000}})",
        "option_d": "DELETE FROM listings_limpio WHERE precio > 1000",
        "option_e": "db.listings_limpio.delete({precio: {$gt: 1000}}, {multiple: true})",
        "correct_answer": "a",
        "explanation": "deleteMany() con operador de comparación: {precio: {$gt: 1000}}. Elimina todos los documentos que cumplen la condición. PRECAUCIÓN: Verifica el filtro primero con find() para ver qué se eliminará. No hay deshacer.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Qué hace db.coleccion.deleteMany({}) sin filtro?",
        "option_a": "No hace nada",
        "option_b": "Elimina TODOS los documentos de la colección (pero mantiene la colección e índices)",
        "option_c": "Genera un error",
        "option_d": "Elimina la colección completa",
        "option_e": "Elimina la base de datos",
        "correct_answer": "b",
        "explanation": "deleteMany({}) sin filtro coincide con TODOS los documentos y los elimina. La colección permanece con sus índices intactos. Para eliminar la colección completa usa drop(). PRECAUCIÓN: Siempre verifica tu filtro, {} puede ser peligroso.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Qué retorna deleteOne() tras eliminar un documento?",
        "option_a": "Un objeto con deletedCount y acknowledged",
        "option_b": "El documento eliminado",
        "option_c": "true o false",
        "option_d": "El número de documentos eliminados",
        "option_e": "Nada (void)",
        "correct_answer": "a",
        "explanation": "deleteOne() retorna: {acknowledged: true/false, deletedCount: n}. deletedCount es 0 si no encontró documentos que coincidieran, 1 si eliminó uno. No retorna el documento eliminado (usa findOneAndDelete() si necesitas el doc).",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Cómo puedes obtener el documento antes de eliminarlo?",
        "option_a": "db.coleccion.findOneAndDelete({filtro})",
        "option_b": "db.coleccion.deleteOne({filtro}, {returnDocument: true})",
        "option_c": "db.coleccion.deleteOne({filtro}).getDeleted()",
        "option_d": "Necesitas hacer findOne() y luego deleteOne()",
        "option_e": "No es posible",
        "correct_answer": "a",
        "explanation": "findOneAndDelete({filtro}) elimina el documento Y lo retorna en una operación atómica. Útil cuando necesitas el documento eliminado (ej: para auditoría, deshacer, o procesar datos antes de eliminar). Alternativa: findOne + deleteOne pero no es atómico.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas un documento y obtienes sus datos en la misma operación?",
        "option_a": "db.coleccion.findOneAndDelete({filtro})",
        "option_b": "db.coleccion.deleteOne({filtro}, {return: true})",
        "option_c": "var doc = db.coleccion.findOne({filtro}); db.coleccion.deleteOne({filtro}); return doc;",
        "option_d": "db.coleccion.deleteAndReturn({filtro})",
        "option_e": "db.coleccion.removeOne({filtro}, {returnDeleted: true})",
        "correct_answer": "a",
        "explanation": "findOneAndDelete() es atómico: encuentra, elimina y retorna el documento en una operación. Si no encuentra nada, retorna null. Opción c funciona pero no es atómica (otro proceso podría modificar/eliminar entre findOne y deleteOne).",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo eliminas un producto y obtienes su información para auditoría?",
        "option_a": "var deleted = db.data_act_01_limpio.findOneAndDelete({_id: ObjectId('...')})",
        "option_b": "db.data_act_01_limpio.deleteOne({_id: ObjectId('...')}, {returnDocument: true})",
        "option_c": "db.data_act_01_limpio.removeAndGet({_id: ObjectId('...')})",
        "option_d": "var doc = db.data_act_01_limpio.findOne({_id: ObjectId('...')}); db.data_act_01_limpio.deleteOne({_id: ObjectId('...')});",
        "option_e": "db.data_act_01_limpio.deleteOne({_id: ObjectId('...')}).getDeleted()",
        "correct_answer": "a",
        "explanation": "findOneAndDelete() retorna el documento eliminado. Guárdalo en una variable para auditoría o procesamiento. Es atómico y seguro. Opción d funciona pero no es atómica. El documento retornado incluye todos sus campos.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas la primera colección completa incluyendo todos sus documentos e índices?",
        "option_a": "db.coleccion.drop()",
        "option_b": "db.coleccion.deleteMany({})",
        "option_c": "db.dropCollection('coleccion')",
        "option_d": "Opciones a y c son correctas",
        "option_e": "DROP TABLE coleccion",
        "correct_answer": "d",
        "explanation": "db.coleccion.drop() o db.dropCollection('nombre') eliminan la colección completa: documentos, índices, todo. deleteMany({}) solo elimina documentos, mantiene colección e índices. drop() es más rápido para limpiar completamente. PRECAUCIÓN: drop() es irreversible.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Cuál es más eficiente para eliminar todos los documentos de una colección: deleteMany({}) o drop()?",
        "option_a": "Son equivalentes",
        "option_b": "drop() es mucho más rápido porque elimina la colección completa sin escanear documentos",
        "option_c": "deleteMany({}) es más rápido",
        "option_d": "Depende del número de documentos",
        "option_e": "No hay diferencia de performance",
        "correct_answer": "b",
        "explanation": "drop() es MUY más rápido: simplemente elimina la colección sin escanear documentos. deleteMany({}) debe escanear y eliminar cada documento. Si quieres vaciar completamente una colección, usa drop() y recrear. Si necesitas mantener índices, usa deleteMany({}).",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Las operaciones de eliminación son recuperables en MongoDB?",
        "option_a": "Sí, hay un comando UNDELETE",
        "option_b": "No, las eliminaciones son permanentes e irreversibles",
        "option_c": "Solo con transacciones",
        "option_d": "Solo si usas soft deletes",
        "option_e": "MongoDB mantiene una papelera de reciclaje",
        "correct_answer": "b",
        "explanation": "Las eliminaciones son PERMANENTES e IRREVERSIBLES. No hay undo. Soluciones: 1) backups regulares, 2) soft deletes (marcar como eliminado sin borrar), 3) findOneAndDelete para auditoría, 4) transacciones (puedes rollback antes de commit). Siempre verifica filtros.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué es un 'soft delete' y cuándo usarlo?",
        "option_a": "Eliminar documentos lentamente",
        "option_b": "Marcar documentos como eliminados (ej: deleted: true) sin borrarlos físicamente",
        "option_c": "Eliminar solo campos, no documentos",
        "option_d": "Un tipo de índice",
        "option_e": "No existe en MongoDB",
        "correct_answer": "b",
        "explanation": "Soft delete: marcar como eliminado sin borrar: {deleted: true, deletedAt: date}. Ventajas: recuperable, auditoría, cumplimiento legal. Desventajas: crecimiento de DB, queries más complejas (debes filtrar deleted: false). Usa cuando necesites historial o recuperación.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo implementarías un soft delete para listings_limpio?",
        "option_a": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$set: {deleted: true, deletedAt: new Date()}})",
        "option_b": "db.listings_limpio.deleteOne({_id: ObjectId('...')})",
        "option_c": "db.listings_limpio.softDelete({_id: ObjectId('...')})",
        "option_d": "db.listings_limpio.updateOne({_id: ObjectId('...')}, {$delete: {soft: true}})",
        "option_e": "db.listings_limpio.remove({_id: ObjectId('...')}, {soft: true})",
        "correct_answer": "a",
        "explanation": "Soft delete es simplemente un update que marca el documento: {$set: {deleted: true, deletedAt: date}}. Luego en queries filtra {deleted: {$ne: true}}. No es una función nativa, es un patrón de diseño que implementas tú.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas documentos más antiguos que cierta fecha?",
        "option_a": "db.coleccion.deleteMany({fecha: {$lt: new Date('2024-01-01')}})",
        "option_b": "db.coleccion.deleteOlderThan(new Date('2024-01-01'))",
        "option_c": "db.coleccion.deleteMany({fecha < '2024-01-01'})",
        "option_d": "db.coleccion.purge({before: new Date('2024-01-01')})",
        "option_e": "db.coleccion.expire({fecha: '2024-01-01'})",
        "correct_answer": "a",
        "explanation": "deleteMany con operador de comparación de fechas: {fecha: {$lt: fecha}}. Asegúrate que el campo sea tipo Date, no string. Para automatizar limpieza periódica, considera índices TTL (Time To Live) que eliminan automáticamente docs viejos.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué es un índice TTL (Time To Live)?",
        "option_a": "Un índice que mejora performance de queries",
        "option_b": "Un índice que automáticamente elimina documentos después de cierto tiempo",
        "option_c": "Un índice temporal",
        "option_d": "Un índice de texto",
        "option_e": "No existe en MongoDB",
        "correct_answer": "b",
        "explanation": "Índice TTL elimina automáticamente documentos después de tiempo especificado: createIndex({fecha: 1}, {expireAfterSeconds: 86400}). Útil para sesiones, logs, cache temporal. MongoDB ejecuta un proceso background que elimina docs expirados periódicamente (~60s).",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un índice TTL para eliminar documentos automáticamente después de 24 horas?",
        "option_a": "db.coleccion.createIndex({createdAt: 1}, {expireAfterSeconds: 86400})",
        "option_b": "db.coleccion.createIndex({createdAt: 1}, {ttl: 86400})",
        "option_c": "db.coleccion.addTTL({createdAt: 1}, {expires: '24h'})",
        "option_d": "db.coleccion.createIndex({createdAt: 1}, {autoDelete: 86400})",
        "option_e": "db.coleccion.setExpiration({field: 'createdAt', seconds: 86400})",
        "correct_answer": "a",
        "explanation": "Índice TTL: createIndex({campo_fecha: 1}, {expireAfterSeconds: segundos}). El campo debe ser tipo Date. 86400 segundos = 24 horas. Docs se eliminan automáticamente cuando (campo_fecha + expireAfterSeconds) < hora_actual. Solo un TTL por colección.",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Cuándo deberías usar índices TTL en lugar de deleteMany() manual?",
        "option_a": "Siempre",
        "option_b": "Para datos que naturalmente expiran (sesiones, cache, logs temporales) y quieres limpieza automática",
        "option_c": "Nunca, TTL es menos eficiente",
        "option_d": "Solo en producción",
        "option_e": "Solo en MongoDB Atlas",
        "correct_answer": "b",
        "explanation": "TTL es ideal para: sesiones de usuario, tokens temporales, logs que no necesitas mantener largo tiempo, cache. Ventaja: automático, no necesitas cron jobs. Desventaja: menos control, ~60s de delay. Para limpieza controlada o con lógica compleja, usa deleteMany() manual.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo verificas cuántos documentos se eliminarían antes de ejecutar deleteMany()?",
        "option_a": "db.coleccion.countDocuments({filtro})",
        "option_b": "db.coleccion.deleteMany({filtro}, {dryRun: true})",
        "option_c": "db.coleccion.simulateDelete({filtro})",
        "option_d": "db.coleccion.deleteMany({filtro}, {preview: true})",
        "option_e": "No es posible verificar",
        "correct_answer": "a",
        "explanation": "Siempre verifica primero con countDocuments({filtro}) o find({filtro}).limit(10) para ver qué se eliminará. No hay opción dryRun en MongoDB. MEJOR PRÁCTICA: 1) count/find para verificar, 2) deleteMany en transacción si es crítico, 3) tener backup.",
        "difficulty": "easy"
    },
    # Continuación Categoría 5 (CRUD - Delete) - 30 preguntas restantes
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas vuelos de infovuelos_limpio con más de 2 escalas?",
        "option_a": "db.infovuelos_limpio.deleteMany({NumEscalas: {$gt: 2}})",
        "option_b": "db.infovuelos_limpio.deleteMany({NumEscalas > 2})",
        "option_c": "db.infovuelos_limpio.remove({NumEscalas: {$gt: 2}})",
        "option_d": "db.infovuelos_limpio.delete({NumEscalas: {$greaterThan: 2}})",
        "option_e": "db.infovuelos_limpio.dropMany({NumEscalas: {$gt: 2}})",
        "correct_answer": "a",
        "explanation": "deleteMany({campo: {$gt: valor}}) para eliminar múltiples documentos que cumplen condición. $gt = greater than. remove() está deprecado, usa deleteMany(). delete() y dropMany() no existen. Siempre verifica primero con find().count().",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué diferencia hay entre drop() y deleteMany({})?",
        "option_a": "Son idénticos",
        "option_b": "drop() elimina la colección completa (incluyendo índices y metadata), deleteMany({}) solo los documentos",
        "option_c": "drop() es más lento",
        "option_d": "deleteMany({}) elimina índices, drop() no",
        "option_e": "drop() solo funciona si la colección está vacía",
        "correct_answer": "b",
        "explanation": "drop() elimina TODA la colección: documentos, índices, metadata. deleteMany({}) elimina solo documentos, índices se mantienen. drop() es MUCHO más rápido para limpiar colección completa. Usa drop() si vas a recrear la colección, deleteMany() si solo limpias datos.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas una colección completa incluyendo índices?",
        "option_a": "db.coleccion.drop()",
        "option_b": "db.coleccion.deleteMany({})",
        "option_c": "db.coleccion.remove()",
        "option_d": "db.dropCollection('coleccion')",
        "option_e": "db.coleccion.destroy()",
        "correct_answer": "a",
        "explanation": "drop() elimina la colección completa: documentos, índices, configuración. Retorna true si existía, false si no. También puedes usar db.dropDatabase() para eliminar toda la base. CUIDADO: es irreversible. Verifica primero con db.getCollectionNames().",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas listings con price mayor a 500 y availability menor a 30?",
        "option_a": "db.listings_limpio.deleteMany({price: {$gt: 500}, availability_365: {$lt: 30}})",
        "option_b": "db.listings_limpio.deleteMany({price > 500 AND availability_365 < 30})",
        "option_c": "db.listings_limpio.deleteMany({$and: [{price: {$gt: 500}}, {availability_365: {$lt: 30}}]})",
        "option_d": "Tanto a como c son correctas",
        "option_e": "db.listings_limpio.remove({price: {$gt: 500}, availability_365: {$lt: 30}})",
        "correct_answer": "d",
        "explanation": "Múltiples condiciones AND: simplemente separa por comas {cond1, cond2} o usa $and. Ambas funcionan igual. En práctica, comas es más legible. $and es útil cuando tienes condiciones sobre mismo campo. remove() deprecado.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'write concern' y cómo afecta a deleteMany()?",
        "option_a": "Un tipo de validación",
        "option_b": "Nivel de confirmación requerido antes de considerar la operación exitosa (ej: w:1, w:'majority')",
        "option_c": "Un método de encriptación",
        "option_d": "Control de acceso",
        "option_e": "No aplica a operaciones de delete",
        "correct_answer": "b",
        "explanation": "Write concern controla cuántos nodos deben confirmar la escritura: w:1 (solo primary), w:'majority' (mayoría de réplicas), w:0 (no espera confirmación). Para deletes críticos usa {w:'majority', j:true} (mayoría + journal). Mayor seguridad = mayor latencia.",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo usas write concern 'majority' en deleteMany()?",
        "option_a": "db.coleccion.deleteMany({filtro}, {writeConcern: {w: 'majority'}})",
        "option_b": "db.coleccion.deleteMany({filtro}, {w: 'majority'})",
        "option_c": "db.coleccion.deleteMany({filtro}).writeConcern('majority')",
        "option_d": "db.coleccion.deleteMany({filtro}, {majority: true})",
        "option_e": "No es posible especificar write concern en deletes",
        "correct_answer": "a",
        "explanation": "Write concern en segundo parámetro: {writeConcern: {w: 'majority', j: true, wtimeout: 5000}}. w:'majority' espera confirmación de mayoría de réplicas. j:true espera journal. wtimeout: milisegundos máximo de espera.",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas documentos usando expresiones regulares en infovuelos_limpio?",
        "option_a": "db.infovuelos_limpio.deleteMany({Origen: /^MAD/})",
        "option_b": "db.infovuelos_limpio.deleteMany({Origen: {$regex: '^MAD'}})",
        "option_c": "db.infovuelos_limpio.deleteMany({Origen: {$regex: '^MAD', $options: 'i'}})",
        "option_d": "Todas las anteriores son correctas",
        "option_e": "No se pueden usar regex en deleteMany()",
        "correct_answer": "d",
        "explanation": "Regex en filtros: /patrón/ o {$regex: 'patrón', $options: 'i'}. Funciona igual en find(), deleteMany(), updateMany(). CUIDADO: regex sin índice es lento. Para deletes masivos con regex, considera primero verificar con count().",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede con los índices cuando eliminas muchos documentos?",
        "option_a": "Se eliminan automáticamente",
        "option_b": "Los índices se mantienen, pero pueden quedar fragmentados y menos eficientes",
        "option_c": "Se reconstruyen automáticamente",
        "option_d": "Los índices no se ven afectados",
        "option_e": "MongoDB los optimiza en tiempo real",
        "correct_answer": "b",
        "explanation": "Índices se mantienen pero pueden fragmentarse tras muchos deletes. Síntomas: queries lentas, índice ocupa mucho espacio. Solución: reIndex() para reconstruir (BLOQUEA COLECCIÓN), o dropIndex()+createIndex(). En producción, mejor createIndex en background.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo reconstruyes índices después de eliminar masivamente documentos?",
        "option_a": "db.coleccion.reIndex()",
        "option_b": "db.coleccion.rebuildIndexes()",
        "option_c": "db.coleccion.optimizeIndexes()",
        "option_d": "db.coleccion.compactIndexes()",
        "option_e": "Los índices se reconstruyen automáticamente",
        "correct_answer": "a",
        "explanation": "reIndex() reconstruye todos los índices de la colección. CUIDADO: BLOQUEA la colección (escrituras y lecturas). En producción: 1) usa replica set, 2) reIndex en secundario, 3) promueve a primary. Alternativa: dropIndex + createIndex con {background:true} (deprecado en 4.2+, ahora siempre background).",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué es un 'cascading delete' y MongoDB lo soporta nativamente?",
        "option_a": "Eliminar documentos en cascada como SQL; sí, con $cascade",
        "option_b": "Eliminar documentos relacionados automáticamente; NO, debes implementarlo manualmente",
        "option_c": "Eliminar colecciones en cascada; sí, con dropDatabase()",
        "option_d": "Un tipo de índice para deletes",
        "option_e": "Una función de backup automático",
        "correct_answer": "b",
        "explanation": "MongoDB NO tiene cascading deletes automático (no hay foreign keys con ON DELETE CASCADE). Debes implementarlo: 1) Change streams para detectar deletes, 2) Transacciones multi-documento, 3) Application logic. Diseña schema para minimizar necesidad (embedded docs, arrays).",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo implementarías un cascading delete manual con transacciones?",
        "option_a": "const session = client.startSession(); session.startTransaction(); db.usuarios.deleteOne({_id: userId}, {session}); db.pedidos.deleteMany({userId: userId}, {session}); session.commitTransaction();",
        "option_b": "db.usuarios.deleteOne({_id: userId, cascade: true})",
        "option_c": "db.usuarios.deleteWithCascade({_id: userId}, {collections: ['pedidos']})",
        "option_d": "MongoDB lo hace automáticamente",
        "option_e": "No es posible hacer cascading deletes en MongoDB",
        "correct_answer": "a",
        "explanation": "Cascading delete manual: 1) startSession, 2) startTransaction, 3) delete padre con {session}, 4) delete hijos con {session}, 5) commitTransaction o abortTransaction si falla. ATOMICIDAD garantizada. Requiere replica set. En app logic: try/catch para rollback.",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas documentos de data_act_01_limpio donde Age es null o no existe?",
        "option_a": "db.data_act_01_limpio.deleteMany({Age: {$exists: false}})",
        "option_b": "db.data_act_01_limpio.deleteMany({Age: null})",
        "option_c": "db.data_act_01_limpio.deleteMany({$or: [{Age: null}, {Age: {$exists: false}}]})",
        "option_d": "db.data_act_01_limpio.deleteMany({Age: {$in: [null, undefined]}})",
        "option_e": "Todas excepto d son correctas",
        "correct_answer": "e",
        "explanation": "{Age: null} encuentra null Y missing. {$exists: false} solo missing. $or combinado es explícito pero redundante. undefined NO es valor válido en MongoDB (se convierte a null). Mejor práctica: {Age: null} es suficiente para ambos casos.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre deleteMany() sin filtro y vaciar una base de datos?",
        "option_a": "deleteMany({}) elimina documentos de UNA colección, vaciar DB afecta TODAS las colecciones",
        "option_b": "Son equivalentes",
        "option_c": "deleteMany({}) es más rápido",
        "option_d": "Vaciar DB solo elimina índices",
        "option_e": "No hay forma de vaciar una base de datos completa",
        "correct_answer": "a",
        "explanation": "deleteMany({}) en UNA colección. Para toda la DB: db.dropDatabase() elimina TODO. Para vaciar sin borrar: db.getCollectionNames().forEach(c => db[c].deleteMany({})). dropDatabase() es mucho más rápido. CUIDADO: ambos irreversibles.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas una base de datos completa?",
        "option_a": "use dbName; db.dropDatabase()",
        "option_b": "db.drop()",
        "option_c": "mongo.dropDatabase('dbName')",
        "option_d": "db.delete()",
        "option_e": "dropDB('dbName')",
        "correct_answer": "a",
        "explanation": "dropDatabase() elimina la base de datos actual (seleccionada con 'use'). Retorna {ok: 1} si exitoso. Elimina TODAS las colecciones, índices, metadata. EXTREMADAMENTE PELIGROSO. Verifica primero con db.getName(). No hay confirmación ni undo.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo usarías bulkWrite() para múltiples deletes eficientemente?",
        "option_a": "db.coleccion.bulkWrite([{deleteOne: {filter: {campo: valor1}}}, {deleteMany: {filter: {campo: valor2}}}])",
        "option_b": "db.coleccion.bulkWrite([{delete: {campo: valor1}}, {delete: {campo: valor2}}])",
        "option_c": "db.coleccion.deleteMany([{campo: valor1}, {campo: valor2}])",
        "option_d": "db.coleccion.bulkDelete([{campo: valor1}, {campo: valor2}])",
        "option_e": "No es posible hacer bulk deletes",
        "correct_answer": "a",
        "explanation": "bulkWrite acepta array de operaciones: deleteOne, deleteMany, insertOne, updateOne, etc. Más eficiente que múltiples llamadas individuales (un solo round-trip). Ordered:true (default) para a falla, ordered:false continúa si falla. Retorna {deletedCount, insertedCount, ...}.",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Cuándo usarías bulkWrite() para deletes en lugar de deleteMany()?",
        "option_a": "Siempre, es más rápido",
        "option_b": "Cuando necesitas eliminar con diferentes filtros en una sola operación eficiente",
        "option_c": "Nunca, deleteMany() es mejor",
        "option_d": "Solo en producción",
        "option_e": "Son idénticos",
        "correct_answer": "b",
        "explanation": "bulkWrite útil cuando: 1) múltiples filtros diferentes, 2) mezclas deletes con inserts/updates, 3) necesitas atomicidad de grupo (ordered:true). Un solo deleteMany() con un filtro es más simple. bulkWrite reduce round-trips al servidor.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas duplicados de listings_limpio basándote en name, manteniendo el primero?",
        "option_a": "db.listings_limpio.aggregate([{$group: {_id: '$name', ids: {$push: '$_id'}}}, {$project: {toDelete: {$slice: ['$ids', 1, {$size: '$ids'}]}}}]); luego deleteMany con esos _ids",
        "option_b": "db.listings_limpio.deleteDuplicates({field: 'name'})",
        "option_c": "db.listings_limpio.deleteMany({name: {$duplicate: true}})",
        "option_d": "db.listings_limpio.distinct('name').forEach(n => db.listings_limpio.deleteMany({name: n}, {limit: -1}))",
        "option_e": "MongoDB elimina duplicados automáticamente",
        "correct_answer": "a",
        "explanation": "Eliminar duplicados: 1) aggregate para encontrar duplicados: $group por campo, $push _ids, 2) $slice para tomar todos excepto primero, 3) $out a colección temp o array, 4) deleteMany({_id: {$in: arrayIds}}). No hay función nativa. Índice unique previene futuros duplicados.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué impacto tiene eliminar documentos en el tamaño del archivo de la base de datos?",
        "option_a": "El archivo se reduce inmediatamente",
        "option_b": "El espacio queda marcado como reutilizable pero el archivo no se reduce automáticamente",
        "option_c": "El archivo crece",
        "option_d": "No tiene impacto",
        "option_e": "Se reduce solo en MongoDB Atlas",
        "correct_answer": "b",
        "explanation": "Deletes marcan espacio como libre para reutilizar, pero archivo NO se reduce automáticamente (fragmentación). Para recuperar espacio: compact() (bloquea colección, solo standalone/secondary), o mongodump+mongorestore. En producción: monitorea tamaño con db.stats(), planea compact en ventanas de mantenimiento.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo recuperas espacio en disco después de muchos deletes?",
        "option_a": "db.coleccion.compact()",
        "option_b": "db.runCommand({compact: 'coleccion'})",
        "option_c": "mongodump + drop + mongorestore",
        "option_d": "Todas las anteriores funcionan",
        "option_e": "No es posible recuperar espacio",
        "correct_answer": "d",
        "explanation": "Opciones: 1) compact() o runCommand({compact: 'col'}) desfragmenta y recupera espacio (BLOQUEA colección), 2) dump+restore reconstruye desde cero (sin fragmentación). compact() requiere espacio libre (2x tamaño col). En replica set, compact secundarios primero.",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo limitas la cantidad de documentos eliminados por segundo (rate limiting)?",
        "option_a": "No hay función nativa, debes implementarlo en application code con sleep entre batches",
        "option_b": "db.coleccion.deleteMany({filtro}, {rateLimit: 100})",
        "option_c": "db.coleccion.deleteMany({filtro}, {maxRate: 100})",
        "option_d": "MongoDB lo hace automáticamente",
        "option_e": "db.setDeleteRate(100)",
        "correct_answer": "a",
        "explanation": "No hay rate limiting nativo en deletes. Implementa en app: while loop con deleteMany({filtro}, {limit}) pequeño + sleep. Útil para: 1) evitar sobrecargar servidor, 2) permitir que replicación catch up, 3) mantener performance para otros usuarios.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué es mejor para eliminar millones de documentos: deleteMany() o drop()+recreate?",
        "option_a": "deleteMany() siempre",
        "option_b": "drop()+recreate es MUCHO más rápido si eliminas >80% de documentos",
        "option_c": "Son igual de rápidos",
        "option_d": "drop() no funciona con millones de docs",
        "option_e": "Depende del tipo de índices",
        "correct_answer": "b",
        "explanation": "Para eliminar mayoría/todos los docs: drop() es órdenes de magnitud más rápido (operación metadata vs iterar millones docs). Luego createCollection + createIndexes. deleteMany() mejor si: 1) eliminas <50% docs, 2) necesitas selectividad precisa, 3) no puedes permitir downtime.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo verificas el resultado de deleteMany() y manejas errores?",
        "option_a": "try { const result = db.coleccion.deleteMany({filtro}); print(result.deletedCount); } catch(e) { print(e); }",
        "option_b": "db.coleccion.deleteMany({filtro}).getStatus()",
        "option_c": "if (db.coleccion.deleteMany({filtro}).ok) { ... }",
        "option_d": "MongoDB siempre retorna success",
        "option_e": "No se pueden capturar errores en mongo shell",
        "correct_answer": "a",
        "explanation": "deleteMany() retorna {acknowledged: true, deletedCount: N}. En mongo shell usa try/catch. En drivers: await/promises con catch. Errores comunes: timeout, write concern, disk full. SIEMPRE verifica deletedCount matches expected. Log para auditoría.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas documentos de infovuelos_limpio basándote en array contains?",
        "option_a": "db.infovuelos_limpio.deleteMany({tags: 'retraso'}) si tags es array",
        "option_b": "db.infovuelos_limpio.deleteMany({tags: {$in: ['retraso']}})",
        "option_c": "db.infovuelos_limpio.deleteMany({tags: {$elemMatch: {$eq: 'retraso'}}})",
        "option_d": "a y b son correctas",
        "option_e": "No se puede filtrar por arrays en deleteMany()",
        "correct_answer": "d",
        "explanation": "Para array contains: {campo: valor} funciona si campo es array. {campo: {$in: [valores]}} también. $elemMatch para objetos complejos en array. Para 'no contiene': {campo: {$ne: valor}} o {$not: {campo: valor}}. Arrays soportan todos los operadores de query.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede si intentas deleteMany() en una colección que no existe?",
        "option_a": "Error fatal",
        "option_b": "Retorna {acknowledged: true, deletedCount: 0} sin crear la colección",
        "option_c": "Crea la colección vacía",
        "option_d": "Warning pero no error",
        "option_e": "MongoDB crashea",
        "correct_answer": "b",
        "explanation": "Operaciones en colecciones inexistentes: read/delete retornan 0 resultados sin error. Insert/update SÍ crean la colección. Útil: no necesitas verificar existencia antes de delete. Cuidado: typo en nombre no dará error, solo 0 deletes.",
        "difficulty": "easy"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo usarías findOneAndDelete() para logging antes de eliminar?",
        "option_a": "const doc = db.coleccion.findOneAndDelete({filtro}); if(doc) { auditLog.insertOne({deleted: doc, timestamp: new Date()}); }",
        "option_b": "db.coleccion.findOneAndDelete({filtro}, {log: true})",
        "option_c": "db.coleccion.deleteOne({filtro}, {returnDoc: true})",
        "option_d": "No es posible obtener el documento eliminado",
        "option_e": "db.coleccion.logAndDelete({filtro})",
        "correct_answer": "a",
        "explanation": "findOneAndDelete retorna el documento ANTES de eliminarlo. Perfecto para auditoría: 1) guarda doc retornado en log collection, 2) procesa cleanup, 3) notificaciones. Opciones: {projection, sort} para controlar qué doc eliminar si múltiples matches.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas documentos de listings_limpio donde un campo embedded es específico?",
        "option_a": "db.listings_limpio.deleteMany({'host.host_name': 'John'})",
        "option_b": "db.listings_limpio.deleteMany({host: {host_name: 'John'}})",
        "option_c": "db.listings_limpio.deleteMany({host.host_name: 'John'})",
        "option_d": "db.listings_limpio.deleteMany({$where: 'this.host.host_name == \"John\"'})",
        "option_e": "a y d son correctas",
        "correct_answer": "e",
        "explanation": "Dot notation para embedded docs: {'parent.child': valor}. DEBE ir entre comillas. {parent: {child: valor}} requiere EXACT match de TODO el objeto. $where funciona pero es LENTO (eval JavaScript). Mejor: dot notation con índice en campo embedded.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la mejor práctica para deletes masivos en producción?",
        "option_a": "Ejecutar deleteMany() con millones de docs de una vez",
        "option_b": "Batches pequeños (1000-10000) con pausa entre batches, monitoring, y posibilidad de cancelar",
        "option_c": "Usar drop() siempre",
        "option_d": "Hacerlo durante horario peak para detectar problemas",
        "option_e": "No hay diferencia",
        "correct_answer": "b",
        "explanation": "Deletes masivos en producción: 1) batches pequeños (evita lock prolongado), 2) pausa entre batches (permite replicación catch up), 3) ventana de mantenimiento, 4) monitoring de replication lag, 5) backup antes, 6) posibilidad de cancelar, 7) dry run primero. NUNCA millones de docs de golpe.",
        "difficulty": "medium"
    },
    {
        "category_id": 5,
        "question_type": "syntax",
        "question_text": "¿Cómo implementarías un delete con límite de batch y pausa?",
        "option_a": "while(db.coleccion.deleteMany({filtro}, {limit: 1000}).deletedCount > 0) { sleep(1000); }",
        "option_b": "db.coleccion.deleteMany({filtro}, {batchSize: 1000, pauseMs: 1000})",
        "option_c": "db.coleccion.deleteInBatches({filtro}, {size: 1000, pause: 1000})",
        "option_d": "MongoDB lo hace automáticamente",
        "option_e": "No es posible en mongo shell",
        "correct_answer": "a",
        "explanation": "No hay limit en deleteMany ni batch automático. Implementa manualmente: while loop, deleteMany sin limit (elimina todos los que matchean en ese momento), sleep(ms), repite hasta deletedCount=0. NOTA: en shell sleep() puede no existir, usa drivers o script.",
        "difficulty": "hard"
    },
    {
        "category_id": 5,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'oplog' y cómo se relaciona con deletes?",
        "option_a": "Un log de errores",
        "option_b": "Log de operaciones en replica set; cada delete se registra para replicación",
        "option_c": "Un tipo de índice",
        "option_d": "Sistema de backup",
        "option_e": "Solo aplica a inserts",
        "correct_answer": "b",
        "explanation": "Oplog (operations log): capped collection que registra TODAS las operaciones de escritura (insert/update/delete) en primary. Secondaries leen oplog para replicar. Deletes masivos generan muchas entradas oplog. Si oplog se llena antes de replicarse, secondary queda stale. Monitorea replication lag.",
        "difficulty": "hard"
    }
]

# Total Batch 5: 78 preguntas ✅
# Categoría 4 (CRUD - Update): 58 preguntas
# Categoría 5 (CRUD - Delete): 49 preguntas
# Total acumulado: 271 preguntas de 520

# ============================================================================
# BATCH 6: CATEGORÍA 6 - AGREGACIÓN (Primera parte: 50/100 preguntas)
# ============================================================================

QUESTIONS_BATCH_6 = [
    # ==================== CATEGORÍA 6: AGREGACIÓN ====================
    # Conceptos básicos y pipeline

    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es el Aggregation Pipeline en MongoDB?",
        "option_a": "Una función para sumar documentos",
        "option_b": "Un framework que procesa documentos a través de múltiples etapas transformándolos paso a paso",
        "option_c": "Un tipo de índice",
        "option_d": "Una herramienta de backup",
        "option_e": "Un método de replicación",
        "correct_answer": "b",
        "explanation": "Aggregation Pipeline procesa documentos a través de etapas (stages) secuenciales. Cada stage transforma los documentos y pasa resultados al siguiente. Similar a Unix pipes. Stages comunes: $match, $group, $project, $sort. Muy potente para análisis y transformaciones complejas.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis básica de aggregate()?",
        "option_a": "db.coleccion.aggregate([{$stage1: {...}}, {$stage2: {...}}])",
        "option_b": "db.coleccion.aggregate($stage1, $stage2)",
        "option_c": "db.coleccion.pipeline([{stage1}, {stage2}])",
        "option_d": "db.aggregate(coleccion, [{stage1}, {stage2}])",
        "option_e": "db.coleccion.agg([stage1, stage2])",
        "correct_answer": "a",
        "explanation": "aggregate() recibe un ARRAY de stages: [{$stage1: {}}, {$stage2: {}}]. Orden importa: stages se ejecutan secuencialmente. Cada stage recibe output del anterior. Retorna cursor (como find). Puede incluir opciones como segundo parámetro: {allowDiskUse: true}.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $match en aggregation pipeline?",
        "option_a": "Combina documentos",
        "option_b": "Filtra documentos (similar a find, pero dentro del pipeline)",
        "option_c": "Agrupa documentos",
        "option_d": "Ordena documentos",
        "option_e": "Cuenta documentos",
        "correct_answer": "b",
        "explanation": "$match filtra documentos igual que find(). MEJOR PRÁCTICA: usa $match TEMPRANO en pipeline para reducir documentos procesados (performance). Puede usar índices si está al inicio. Sintaxis: {$match: {campo: valor}}. Soporta todos los operadores de query.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo filtras vuelos de infovuelos_limpio con NumEscalas > 1 usando aggregate?",
        "option_a": "db.infovuelos_limpio.aggregate([{$match: {NumEscalas: {$gt: 1}}}])",
        "option_b": "db.infovuelos_limpio.aggregate({$match: {NumEscalas > 1}})",
        "option_c": "db.infovuelos_limpio.aggregate([{$filter: {NumEscalas: {$gt: 1}}}])",
        "option_d": "db.infovuelos_limpio.find({NumEscalas: {$gt: 1}}).aggregate()",
        "option_e": "db.infovuelos_limpio.aggregate([{$where: 'NumEscalas > 1'}])",
        "correct_answer": "a",
        "explanation": "$match usa misma sintaxis que find(): {$match: {campo: {operador: valor}}}. Debe estar dentro de array de pipeline. Soporta $gt, $lt, $in, $regex, etc. Coloca $match temprano para mejor performance.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $group?",
        "option_a": "Filtra documentos",
        "option_b": "Agrupa documentos por un campo y permite calcular agregaciones (sum, avg, count, etc.)",
        "option_c": "Ordena documentos",
        "option_d": "Proyecta campos",
        "option_e": "Une colecciones",
        "correct_answer": "b",
        "explanation": "$group agrupa docs por _id especificado y calcula acumuladores: $sum, $avg, $min, $max, $count, $push, $addToSet. Fundamental para análisis. Cada grupo produce UN documento. _id: null agrupa TODOS los documentos en uno.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo cuentas el total de vuelos por Origen en infovuelos_limpio?",
        "option_a": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', total: {$sum: 1}}}])",
        "option_b": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', total: {$count: 1}}}])",
        "option_c": "db.infovuelos_limpio.aggregate([{$count: {by: '$Origen'}}])",
        "option_d": "db.infovuelos_limpio.group({key: {Origen: 1}, reduce: function() {}})",
        "option_e": "db.infovuelos_limpio.aggregate([{$group: {Origen: '$Origen', count: 1}}])",
        "correct_answer": "a",
        "explanation": "$group con _id: '$campo' agrupa por ese campo. $sum: 1 cuenta documentos (incrementa en 1 por cada doc). El $ antes del campo referencia su valor. total es el nombre del campo resultado. Retorna array de {_id: valor_campo, total: N}.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué significa el símbolo $ antes de un nombre de campo en aggregation?",
        "option_a": "Es un operador de comparación",
        "option_b": "Referencia el VALOR del campo (field path expression)",
        "option_c": "Indica un campo obligatorio",
        "option_d": "Es sintaxis de regex",
        "option_e": "No tiene significado especial",
        "correct_answer": "b",
        "explanation": "$ antes de campo: field path expression, referencia su valor. Ejemplo: '$price' obtiene valor de price. Sin $: es literal string 'price'. FUNDAMENTAL en aggregation. También para campos nested: '$address.city'. Arrays: '$tags' referencia todo el array.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo calculas el precio promedio de listings_limpio?",
        "option_a": "db.listings_limpio.aggregate([{$group: {_id: null, avgPrice: {$avg: '$price'}}}])",
        "option_b": "db.listings_limpio.aggregate([{$avg: '$price'}])",
        "option_c": "db.listings_limpio.find().avg('price')",
        "option_d": "db.listings_limpio.aggregate([{$group: {_id: '$price', avg: {$average: 1}}}])",
        "option_e": "db.listings_limpio.average({field: 'price'})",
        "correct_answer": "a",
        "explanation": "$avg dentro de $group calcula promedio. _id: null agrupa TODOS los docs en un solo grupo (para stats globales). $avg: '$precio' calcula promedio de ese campo. Otros acumuladores: $sum, $min, $max, $stdDevPop.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre $sum: 1 y $sum: '$campo'?",
        "option_a": "No hay diferencia",
        "option_b": "$sum: 1 cuenta documentos, $sum: '$campo' suma los valores del campo",
        "option_c": "$sum: 1 es inválido",
        "option_d": "$sum: '$campo' es más rápido",
        "option_e": "Solo funciona en versiones antiguas",
        "correct_answer": "b",
        "explanation": "$sum: 1 incrementa contador por cada doc (cuenta docs). $sum: '$campo' suma valores numéricos del campo. Ejemplo: {$sum: '$ventas'} suma todas las ventas. $sum: 1 equivale a COUNT(*) en SQL. $sum: '$campo' equivale a SUM(campo).",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes el price máximo y mínimo de listings_limpio?",
        "option_a": "db.listings_limpio.aggregate([{$group: {_id: null, maxPrice: {$max: '$price'}, minPrice: {$min: '$price'}}}])",
        "option_b": "db.listings_limpio.aggregate([{$max: '$price'}, {$min: '$price'}])",
        "option_c": "db.listings_limpio.find().sort({price: -1}).limit(1)",
        "option_d": "db.listings_limpio.aggregate([{$group: {_id: '$price', max: 1, min: 1}}])",
        "option_e": "db.listings_limpio.stats('price')",
        "correct_answer": "a",
        "explanation": "Múltiples acumuladores en mismo $group: {maxPrice: {$max: '$campo'}, minPrice: {$min: '$campo'}}. _id: null para un solo grupo con todas las stats. Retorna UN documento con ambos valores. Mucho más eficiente que múltiples queries.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $project?",
        "option_a": "Crea una nueva colección",
        "option_b": "Selecciona, excluye, renombra campos o crea campos calculados (reshape documents)",
        "option_c": "Filtra documentos",
        "option_d": "Agrupa documentos",
        "option_e": "Ordena documentos",
        "correct_answer": "b",
        "explanation": "$project controla forma del output: incluir (1), excluir (0), renombrar, campos calculados con expresiones. Similar a SELECT en SQL. Útil para limpiar output, calcular campos derivados, reestructurar docs. Reduce datos transferidos.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo proyectas solo name y price de listings_limpio en aggregate?",
        "option_a": "db.listings_limpio.aggregate([{$project: {name: 1, price: 1}}])",
        "option_b": "db.listings_limpio.aggregate([{$project: {name: true, price: true}}])",
        "option_c": "db.listings_limpio.aggregate([{$select: ['name', 'price']}])",
        "option_d": "db.listings_limpio.aggregate([{$project: ['name', 'price']}])",
        "option_e": "db.listings_limpio.aggregate([{$fields: {name: 1, price: 1}}])",
        "correct_answer": "a",
        "explanation": "$project con 1 incluye campo, 0 excluye. _id SIEMPRE incluido por default (usa _id: 0 para excluir). No puedes mezclar inclusión/exclusión (excepto _id). Sintaxis: {campo: 1} incluir, {campo: 0} excluir, {nuevo: '$viejo'} renombrar/calcular.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un campo calculado en $project?",
        "option_a": "db.coleccion.aggregate([{$project: {total: {$multiply: ['$price', '$quantity']}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {total: '$price * $quantity'}}])",
        "option_c": "db.coleccion.aggregate([{$project: {total: function() { return price * quantity }}}])",
        "option_d": "db.coleccion.aggregate([{$addField: {total: '$price * $quantity'}}])",
        "option_e": "db.coleccion.aggregate([{$compute: {total: ['$price', '*', '$quantity']}}])",
        "correct_answer": "a",
        "explanation": "Campos calculados con operadores de expresión: {$multiply: ['$campo1', '$campo2']}, {$add: [...]}, {$subtract: [...]}, etc. Array de operandos. Para strings: $concat, $substr. Para fechas: $year, $month. Muy potente para transformaciones.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué diferencia hay entre $project y $addFields?",
        "option_a": "No hay diferencia",
        "option_b": "$project puede incluir/excluir campos; $addFields solo AGREGA campos nuevos manteniendo todos los existentes",
        "option_c": "$addFields es más rápido",
        "option_d": "$project es deprecado",
        "option_e": "$addFields no existe",
        "correct_answer": "b",
        "explanation": "$project: control total (incluir/excluir campos). $addFields ($set desde 4.2): AGREGA/modifica campos, mantiene todos los existentes. $addFields más simple cuando solo quieres agregar campos calculados sin reestructurar todo el documento.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo ordenas resultados en aggregation pipeline?",
        "option_a": "db.coleccion.aggregate([{$match: {...}}, {$sort: {campo: 1}}])",
        "option_b": "db.coleccion.aggregate([{$match: {...}}]).sort({campo: 1})",
        "option_c": "db.coleccion.aggregate([{$orderBy: {campo: 1}}])",
        "option_d": "db.coleccion.aggregate([{$match: {...}}], {sort: {campo: 1}})",
        "option_e": "No se puede ordenar en aggregation",
        "correct_answer": "a",
        "explanation": "$sort dentro del pipeline: {$sort: {campo: 1}} ascendente, {campo: -1} descendente. Puede ordenar por múltiples campos. POSICIÓN IMPORTA: antes de $limit para top-N, después de $group para ordenar grupos. Puede usar índices si está al inicio.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes los 10 listings más caros de listings_limpio con aggregate?",
        "option_a": "db.listings_limpio.aggregate([{$sort: {price: -1}}, {$limit: 10}])",
        "option_b": "db.listings_limpio.aggregate([{$limit: 10}, {$sort: {price: -1}}])",
        "option_c": "db.listings_limpio.aggregate([{$top: {field: 'price', n: 10}}])",
        "option_d": "db.listings_limpio.aggregate([{$match: {price: {$top: 10}}}])",
        "option_e": "db.listings_limpio.find().sort({price: -1}).limit(10)",
        "correct_answer": "a",
        "explanation": "Top-N: PRIMERO $sort (orden correcto), LUEGO $limit (cantidad). ORDEN IMPORTA. $sort: {price: -1} descendente (mayor primero). $limit: 10 toma primeros 10. Opción e funciona pero pregunta es sobre aggregate. $top existe en MongoDB 5.2+ pero sintaxis diferente.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Para qué sirve $skip en aggregation?",
        "option_a": "Omitir errores",
        "option_b": "Saltar los primeros N documentos (útil para paginación)",
        "option_c": "Saltar etapas del pipeline",
        "option_d": "Ignorar campos",
        "option_e": "No existe en MongoDB",
        "correct_answer": "b",
        "explanation": "$skip: N salta primeros N documentos. Útil con $limit para paginación: página 1: skip(0).limit(10), página 2: skip(10).limit(10). CUIDADO: skip grande es costoso (debe escanear todos los docs anteriores). Para paginación eficiente, usa range queries.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo implementas paginación con aggregate (página 3, 20 items por página)?",
        "option_a": "db.coleccion.aggregate([{$skip: 40}, {$limit: 20}])",
        "option_b": "db.coleccion.aggregate([{$limit: 20}, {$skip: 40}])",
        "option_c": "db.coleccion.aggregate([{$page: 3, $size: 20}])",
        "option_d": "db.coleccion.aggregate([{$skip: 60}, {$limit: 20}])",
        "option_e": "db.coleccion.aggregate([{$offset: 40, $limit: 20}])",
        "correct_answer": "a",
        "explanation": "Paginación: página 3, skip = (página-1) * tamaño = 2*20 = 40. PRIMERO $skip, LUEGO $limit. $skip: 40 salta primeros 40 docs (páginas 1 y 2), $limit: 20 toma siguientes 20 (página 3). ORDEN: skip luego limit.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el acumulador $push en $group?",
        "option_a": "Inserta nuevos documentos",
        "option_b": "Crea un array con todos los valores del campo de cada documento del grupo",
        "option_c": "Suma valores",
        "option_d": "Cuenta documentos",
        "option_e": "Ordena resultados",
        "correct_answer": "b",
        "explanation": "$push en $group: crea array con valores. Cada valor del grupo se agrega al array (permite duplicados). Útil para agrupar datos relacionados. Ejemplo: agrupar pedidos por cliente: {$push: '$pedido'}. Para array sin duplicados usa $addToSet.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo agrupas vuelos por Origen y obtienes array de Destinos en infovuelos_limpio?",
        "option_a": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', destinos: {$push: '$Destino'}}}])",
        "option_b": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', destinos: '$Destino'}}])",
        "option_c": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', destinos: {$array: '$Destino'}}}])",
        "option_d": "db.infovuelos_limpio.aggregate([{$push: {by: '$Origen', field: '$Destino'}}])",
        "option_e": "db.infovuelos_limpio.group({key: {Origen: 1}, values: ['Destino']})",
        "correct_answer": "a",
        "explanation": "$push: '$campo' crea array con valores de ese campo para cada doc del grupo. Agrupa por Origen (_id: '$Origen'), por cada grupo crea array destinos con todos los Destino. INCLUYE DUPLICADOS. Para únicos usa $addToSet.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre $push y $addToSet?",
        "option_a": "$push es más rápido",
        "option_b": "$push permite duplicados en el array, $addToSet solo valores únicos",
        "option_c": "$addToSet ordena el array",
        "option_d": "No hay diferencia",
        "option_e": "$push es para números, $addToSet para strings",
        "correct_answer": "b",
        "explanation": "$push: agrega todos los valores (permite duplicados). $addToSet: solo valores únicos (como Set). $addToSet más lento (debe verificar duplicados) pero útil para obtener valores distintos. Ambos crean arrays en $group.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes destinos únicos por Origen en infovuelos_limpio?",
        "option_a": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', destinos: {$addToSet: '$Destino'}}}])",
        "option_b": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', destinos: {$push: '$Destino'}}}, {$uniq: 'destinos'}])",
        "option_c": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', destinos: {$unique: '$Destino'}}}])",
        "option_d": "db.infovuelos_limpio.distinct('Destino', {groupBy: 'Origen'})",
        "option_e": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', destinos: {$push: {$distinct: '$Destino'}}}}])",
        "correct_answer": "a",
        "explanation": "$addToSet automáticamente elimina duplicados. Perfecto para obtener valores únicos por grupo. No ordena (para ordenar agrega $sort después). Más eficiente que $push + array deduplication manual.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $unwind?",
        "option_a": "Ordena documentos",
        "option_b": "Descompone un array en documentos separados (uno por elemento del array)",
        "option_c": "Combina arrays",
        "option_d": "Elimina duplicados",
        "option_e": "Agrupa documentos",
        "correct_answer": "b",
        "explanation": "$unwind descompone array: doc con array de N elementos → N documentos (uno por elemento). Opuesto a $push. Útil para procesar elementos de array individualmente. Ejemplo: doc {tags: ['a','b','c']} → 3 docs con tags: 'a', tags: 'b', tags: 'c'.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "Si tienes {_id: 1, tags: ['MongoDB', 'NoSQL']}, ¿qué produce $unwind?",
        "option_a": "db.coleccion.aggregate([{$unwind: '$tags'}]) produce 2 docs: {_id: 1, tags: 'MongoDB'} y {_id: 1, tags: 'NoSQL'}",
        "option_b": "db.coleccion.aggregate([{$unwind: 'tags'}]) produce 1 doc con tags separados",
        "option_c": "Error porque tags es array",
        "option_d": "Mismo documento sin cambios",
        "option_e": "$unwind no funciona con strings",
        "correct_answer": "a",
        "explanation": "$unwind: '$arrayField' descompone array. DEBE incluir $. Un doc con array de N elementos se convierte en N docs (uno por elemento). Todos los demás campos se duplican. Útil para luego hacer $group por elemento de array.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Qué pasa si $unwind encuentra un campo que no es array?",
        "option_a": "Error por default",
        "option_b": "Error por default; usa {$unwind: {path: '$campo', preserveNullAndEmptyArrays: true}} para no eliminar docs",
        "option_c": "Ignora el documento",
        "option_d": "Convierte el campo en array de un elemento",
        "option_e": "$unwind siempre funciona",
        "correct_answer": "b",
        "explanation": "$unwind en campo no-array o null o missing: ERROR por default. Opciones: {path: '$campo', preserveNullAndEmptyArrays: true} mantiene docs con null/missing/array-vacío. {includeArrayIndex: 'idx'} agrega índice del elemento en array original.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $lookup?",
        "option_a": "Busca duplicados",
        "option_b": "Realiza un LEFT JOIN entre colecciones",
        "option_c": "Busca índices",
        "option_d": "Optimiza queries",
        "option_e": "Valida documentos",
        "correct_answer": "b",
        "explanation": "$lookup: LEFT JOIN SQL-like entre colecciones. Une docs de otra colección basándose en campo común. Agrega array con docs encontrados. MongoDB es NoSQL pero a veces necesitas relacionar datos de diferentes colecciones.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis básica de $lookup?",
        "option_a": "{$lookup: {from: 'otraColeccion', localField: 'miCampo', foreignField: 'suCampo', as: 'resultado'}}",
        "option_b": "{$lookup: {collection: 'otra', on: 'campo', as: 'resultado'}}",
        "option_c": "{$join: {from: 'otra', field: 'campo'}}",
        "option_d": "{$lookup: ['otraColeccion', 'campo']}",
        "option_e": "{$lookup: {from: 'otra', where: {campo: '$campo'}}}",
        "correct_answer": "a",
        "explanation": "$lookup: from (colección a unir), localField (campo de esta colección), foreignField (campo de otra colección), as (nombre array resultado). Resultado es array (puede estar vacío si no match). Para pipelines complejos usa sintaxis con let y pipeline.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Por qué $match temprano en el pipeline mejora performance?",
        "option_a": "No mejora performance",
        "option_b": "Reduce documentos procesados por stages posteriores y puede usar índices",
        "option_c": "Solo por legibilidad",
        "option_d": "MongoDB lo requiere",
        "option_e": "$match siempre es lento",
        "correct_answer": "b",
        "explanation": "$match al INICIO del pipeline: 1) puede usar ÍNDICES (mucho más rápido), 2) reduce docs procesados por stages posteriores (menos trabajo). MEJOR PRÁCTICA: filtra lo antes posible. $match después de $group NO puede usar índices.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo cuentas documentos totales con aggregate?",
        "option_a": "db.coleccion.aggregate([{$count: 'total'}])",
        "option_b": "db.coleccion.aggregate([{$group: {_id: null, total: {$sum: 1}}}])",
        "option_c": "Ambas a y b son correctas",
        "option_d": "db.coleccion.aggregate([{$total: 'count'}])",
        "option_e": "db.coleccion.count()",
        "correct_answer": "c",
        "explanation": "Dos formas: {$count: 'nombreCampo'} (MongoDB 3.4+) es shortcut, retorna {nombreCampo: N}. {$group: {_id: null, total: {$sum: 1}}} es más verbose pero compatible con versiones antiguas. Ambas funcionan igual. $count útil después de filtros.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes estadísticas agrupadas de price por neighbourhood en listings_limpio?",
        "option_a": "db.listings_limpio.aggregate([{$group: {_id: '$neighbourhood', avgPrice: {$avg: '$price'}, maxPrice: {$max: '$price'}, minPrice: {$min: '$price'}, count: {$sum: 1}}}])",
        "option_b": "db.listings_limpio.aggregate([{$stats: {by: '$neighbourhood', field: '$price'}}])",
        "option_c": "db.listings_limpio.group({key: {neighbourhood: 1}, stats: {price: 1}})",
        "option_d": "db.listings_limpio.aggregate([{$match: {neighbourhood: {$exists: true}}}, {$stats: '$price'}])",
        "option_e": "db.listings_limpio.stats('price', {groupBy: 'neighbourhood'})",
        "correct_answer": "a",
        "explanation": "Múltiples acumuladores en $group: $avg, $max, $min, $sum en mismo stage. _id: '$neighbourhood' agrupa por barrio. Cada barrio produce un doc con sus estadísticas. Muy potente para análisis agregado. count con {$sum: 1}.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es allowDiskUse en aggregate?",
        "option_a": "Un tipo de índice",
        "option_b": "Opción que permite usar disco temporal si agregación excede 100MB de RAM",
        "option_c": "Método de backup",
        "option_d": "Configuración de storage engine",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "allowDiskUse: true permite aggregate usar disco temporal si excede límite de RAM (100MB por default). Útil para agregaciones grandes. Sintaxis: aggregate([...], {allowDiskUse: true}). Sin esto, agregaciones grandes fallan con error de memoria. Costo: más lento.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo usas allowDiskUse?",
        "option_a": "db.coleccion.aggregate([{$group: {...}}], {allowDiskUse: true})",
        "option_b": "db.coleccion.aggregate([{$group: {...}}, {$allowDiskUse: true}])",
        "option_c": "db.coleccion.aggregate([{$group: {...}}]).allowDiskUse()",
        "option_d": "db.setParameter('allowDiskUse', true); db.coleccion.aggregate([...])",
        "option_e": "MongoDB lo usa automáticamente",
        "correct_answer": "a",
        "explanation": "allowDiskUse es OPCIÓN (segundo parámetro) de aggregate, NO un stage del pipeline: aggregate([pipeline], {allowDiskUse: true, ...otrasOpciones}). Otras opciones: cursor: {batchSize: N}, maxTimeMS, collation.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Para qué sirven los operadores de expresión como $multiply, $add, $concat?",
        "option_a": "Para filtrar documentos",
        "option_b": "Para calcular valores derivados en $project, $addFields o acumuladores",
        "option_c": "Para crear índices",
        "option_d": "Para ordenar documentos",
        "option_e": "Solo funcionan en $group",
        "correct_answer": "b",
        "explanation": "Operadores de expresión transforman/calculan valores: aritméticos ($add, $multiply, $divide), strings ($concat, $substr, $toUpper), fechas ($year, $month), condicionales ($cond, $ifNull). Usados en $project, $addFields, dentro de acumuladores. Muy potentes para transformaciones.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo concatenas dos campos de string en aggregate?",
        "option_a": "db.coleccion.aggregate([{$project: {fullName: {$concat: ['$firstName', ' ', '$lastName']}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {fullName: '$firstName + $lastName'}}])",
        "option_c": "db.coleccion.aggregate([{$project: {fullName: {$merge: ['$firstName', '$lastName']}}}])",
        "option_d": "db.coleccion.aggregate([{$concat: {fields: ['firstName', 'lastName'], as: 'fullName'}}])",
        "option_e": "No se pueden concatenar strings en aggregate",
        "correct_answer": "a",
        "explanation": "$concat: [array de strings y field references]. Puede incluir literales: ['$campo', ' - ', '$otro']. Para campos que pueden ser null usa $ifNull. Otros operadores string: $substr, $toUpper, $toLower, $split, $trim.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo extraes el año de un campo fecha en aggregate?",
        "option_a": "db.coleccion.aggregate([{$project: {year: {$year: '$fecha'}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {year: '$fecha.getFullYear()'}}])",
        "option_c": "db.coleccion.aggregate([{$project: {year: {$extract: {field: 'year', from: '$fecha'}}}}])",
        "option_d": "db.coleccion.aggregate([{$dateExtract: {field: '$fecha', part: 'year'}}])",
        "option_e": "No se puede extraer año en aggregate",
        "correct_answer": "a",
        "explanation": "Operadores de fecha: $year, $month, $dayOfMonth, $dayOfWeek, $hour, etc. Extraen partes de fecha. Campo debe ser tipo Date. También: $dateToString para formatear, $dateTrunc (5.0+), $dateAdd, $dateDiff.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo calculas price_per_night * 7 en listings_limpio para obtener precio semanal?",
        "option_a": "db.listings_limpio.aggregate([{$project: {weeklyPrice: {$multiply: ['$price', 7]}}}])",
        "option_b": "db.listings_limpio.aggregate([{$project: {weeklyPrice: '$price * 7'}}])",
        "option_c": "db.listings_limpio.aggregate([{$addFields: {weeklyPrice: {$multiply: ['$price', 7]}}}])",
        "option_d": "Tanto a como c son correctas",
        "option_e": "db.listings_limpio.aggregate([{$calculate: {weeklyPrice: {price: 7}}}])",
        "correct_answer": "d",
        "explanation": "$multiply: ['$campo', número] multiplica. Puede ser en $project (reestructura doc) o $addFields (agrega campo, mantiene resto). Ambas funcionan. $addFields más simple si solo agregas campo. Otros operadores: $add, $subtract, $divide, $mod.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $cond?",
        "option_a": "Filtra documentos",
        "option_b": "Operador ternario: if-then-else (evalúa condición y retorna valor según resultado)",
        "option_c": "Cuenta documentos",
        "option_d": "Concatena strings",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$cond: operador ternario {$cond: {if: condición, then: valor_true, else: valor_false}} o array: {$cond: [condición, then, else]}. Útil para campos calculados condicionales. Ejemplo: categoría por precio, descuento según condición.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un campo 'category' que sea 'expensive' si price > 100, sino 'cheap'?",
        "option_a": "db.listings_limpio.aggregate([{$project: {category: {$cond: {if: {$gt: ['$price', 100]}, then: 'expensive', else: 'cheap'}}}}])",
        "option_b": "db.listings_limpio.aggregate([{$project: {category: {$if: {$gt: ['$price', 100]}, 'expensive', 'cheap'}}}])",
        "option_c": "db.listings_limpio.aggregate([{$project: {category: '$price > 100 ? expensive : cheap'}}])",
        "option_d": "db.listings_limpio.aggregate([{$case: {when: {price: {$gt: 100}}, then: 'expensive', else: 'cheap'}}])",
        "option_e": "No se pueden hacer condicionales en aggregate",
        "correct_answer": "a",
        "explanation": "$cond con $gt para comparación: {if: {$gt: ['$campo', valor]}, then: ..., else: ...}. $gt retorna boolean. then/else pueden ser valores literales o expresiones. Para múltiples condiciones usa $switch (como switch/case).",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es $facet y para qué sirve?",
        "option_a": "Un tipo de índice",
        "option_b": "Stage que ejecuta múltiples pipelines en paralelo sobre los mismos documentos",
        "option_c": "Método de filtrado",
        "option_d": "Operador de comparación",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$facet ejecuta múltiples sub-pipelines en paralelo sobre mismos docs. Útil para: obtener resultados + metadata (count, stats) en una query, o diferentes agrupaciones simultáneas. Retorna objeto con resultado de cada facet. Eficiente: un solo escaneo de datos.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes resultados paginados Y count total en una sola query?",
        "option_a": "db.coleccion.aggregate([{$facet: {results: [{$skip: 0}, {$limit: 10}], totalCount: [{$count: 'total'}]}}])",
        "option_b": "db.coleccion.aggregate([{$limit: 10}, {$count: 'total'}])",
        "option_c": "Requiere dos queries separadas",
        "option_d": "db.coleccion.aggregate([{$skip: 0}, {$limit: 10}, {$totalCount: true}])",
        "option_e": "No es posible",
        "correct_answer": "a",
        "explanation": "$facet con dos sub-pipelines: 'results' con paginación ($skip+$limit), 'totalCount' con $count. Un solo aggregate retorna {results: [...], totalCount: [{total: N}]}. Mucho más eficiente que dos queries. Perfecto para pagination con count total.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué operadores de comparación existen en aggregation expressions?",
        "option_a": "Solo $eq",
        "option_b": "$eq, $ne, $gt, $gte, $lt, $lte (similares a query pero sintaxis diferente)",
        "option_c": "==, !=, >, <",
        "option_d": "No hay operadores de comparación",
        "option_e": "equals(), greaterThan()",
        "correct_answer": "b",
        "explanation": "Operadores de comparación en expressions: $eq, $ne, $gt, $gte, $lt, $lte, $cmp. Sintaxis: {$gt: ['$campo', valor]}. Retornan boolean. Úsalos en $cond, $switch, $filter. DIFERENTE sintaxis que en queries (queries: {campo: {$gt: valor}}).",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo renombras un campo en aggregate?",
        "option_a": "db.coleccion.aggregate([{$project: {nuevoNombre: '$viejoNombre'}}])",
        "option_b": "db.coleccion.aggregate([{$rename: {viejoNombre: 'nuevoNombre'}}])",
        "option_c": "db.coleccion.aggregate([{$project: {viejoNombre: {$rename: 'nuevoNombre'}}}])",
        "option_d": "db.coleccion.aggregate([{$set: {nuevoNombre: '$viejoNombre'}}, {$unset: 'viejoNombre'}])",
        "option_e": "Tanto a como d son correctas",
        "correct_answer": "e",
        "explanation": "Renombrar: {$project: {nuevo: '$viejo'}} (si quieres solo ese campo), o {$set: {nuevo: '$viejo'}}, {$unset: 'viejo'} (mantiene otros campos). $rename existe en update, NO en aggregation. $set es alias de $addFields.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es $bucket y para qué sirve?",
        "option_a": "Un tipo de storage",
        "option_b": "Stage que categoriza documentos en grupos (buckets) basándose en rangos de valores",
        "option_c": "Método de backup",
        "option_d": "Un operador de comparación",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$bucket agrupa docs en rangos: ej. prices 0-50, 50-100, 100+. Defines boundaries (límites) y opcionalmente default bucket. Útil para histogramas, distribuciones, categorización por rangos. Alternativa: $bucketAuto calcula buckets automáticamente.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo categorizas listings_limpio por rangos de precio (0-100, 100-200, 200+)?",
        "option_a": "db.listings_limpio.aggregate([{$bucket: {groupBy: '$price', boundaries: [0, 100, 200, Infinity], default: 'Other'}}])",
        "option_b": "db.listings_limpio.aggregate([{$group: {_id: {$bucket: '$price', ranges: [0, 100, 200]}}}])",
        "option_c": "db.listings_limpio.aggregate([{$categorize: {field: '$price', ranges: [[0,100], [100,200], [200,Infinity]]}}])",
        "option_d": "db.listings_limpio.aggregate([{$bucket: {field: 'price', buckets: [0, 100, 200]}}])",
        "option_e": "No es posible categorizar por rangos",
        "correct_answer": "a",
        "explanation": "$bucket: groupBy (campo a evaluar), boundaries (array límites ascendentes), default (bucket para valores fuera de boundaries). Cada bucket cuenta docs + puede tener acumuladores (output). boundaries debe incluir límite superior (usa Infinity para sin límite).",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Cuándo usarías aggregation pipeline en lugar de find()?",
        "option_a": "Nunca, find() es mejor",
        "option_b": "Cuando necesitas transformaciones complejas, cálculos, agrupaciones, joins que find() no puede hacer",
        "option_c": "Solo para grandes volúmenes de datos",
        "option_d": "Solo en MongoDB Atlas",
        "option_e": "Son equivalentes",
        "correct_answer": "b",
        "explanation": "find() para queries simples (filtrar, proyectar, ordenar, limitar). aggregate() para: groupBy, cálculos agregados (sum/avg/count), joins ($lookup), transformaciones complejas, múltiples stages, análisis de datos. aggregate más potente pero más complejo y potencialmente más lento.",
        "difficulty": "medium"
    }
]

# Total Batch 6: 45 preguntas
# Categoría 6 (Agregación): 45 de 100 preguntas
# Total acumulado: 316 preguntas de 520

# ============================================================================
# BATCH 7: CATEGORÍA 6 - AGREGACIÓN (Segunda parte: 55/100 preguntas)
# ============================================================================

QUESTIONS_BATCH_7 = [
    # ==================== CATEGORÍA 6: AGREGACIÓN AVANZADA ====================

    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $filter en arrays?",
        "option_a": "Filtra documentos",
        "option_b": "Filtra elementos de un array basándose en una condición",
        "option_c": "Crea índices",
        "option_d": "Ordena arrays",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$filter opera sobre arrays dentro de documentos: {$filter: {input: '$array', as: 'item', cond: {condición con $$item}}}. Retorna nuevo array solo con elementos que cumplan condición. Útil cuando array contiene objetos y quieres filtrar por propiedades.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo filtras un array de tags para obtener solo los que empiezan con 'mongo'?",
        "option_a": "db.coleccion.aggregate([{$project: {filteredTags: {$filter: {input: '$tags', as: 'tag', cond: {$regexMatch: {input: '$$tag', regex: /^mongo/i}}}}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {filteredTags: {$filter: {array: '$tags', condition: {$regex: '^mongo'}}}}}])",
        "option_c": "db.coleccion.aggregate([{$match: {tags: {$filter: {$regex: '^mongo'}}}}])",
        "option_d": "db.coleccion.aggregate([{$project: {filteredTags: '$tags.filter(t => t.startsWith(\"mongo\"))'}}])",
        "option_e": "No es posible filtrar arrays en aggregate",
        "correct_answer": "a",
        "explanation": "$filter: input (array origen), as (variable temporal), cond (condición usando $$variable). $regexMatch para pattern matching. NOTA: $$ para referenciar variable de $filter (diferente de $ que referencia campos). Retorna array filtrado.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $map en arrays?",
        "option_a": "Crea mapas geográficos",
        "option_b": "Transforma cada elemento de un array aplicando una expresión",
        "option_c": "Agrupa documentos",
        "option_d": "Filtra arrays",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$map transforma arrays: {$map: {input: '$array', as: 'item', in: {expresión con $$item}}}. Similar a Array.map() en JavaScript. Retorna nuevo array con elementos transformados. Ejemplo: multiplicar cada precio por 1.21 para IVA.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo multiplicas por 1.1 cada elemento de un array de precios?",
        "option_a": "db.coleccion.aggregate([{$project: {newPrices: {$map: {input: '$prices', as: 'p', in: {$multiply: ['$$p', 1.1]}}}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {newPrices: {$map: {array: '$prices', multiply: 1.1}}}}])",
        "option_c": "db.coleccion.aggregate([{$project: {newPrices: '$prices * 1.1'}}])",
        "option_d": "db.coleccion.aggregate([{$multiply: {field: '$prices', by: 1.1}}])",
        "option_e": "No se pueden transformar arrays en aggregate",
        "correct_answer": "a",
        "explanation": "$map con in: {$multiply: ['$$variable', valor]} transforma cada elemento. $$ referencia variable definida en 'as'. Muy útil para transformaciones element-wise. Puede combinar con operadores: $add, $concat, $cond, etc.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $reduce?",
        "option_a": "Reduce el tamaño de documentos",
        "option_b": "Reduce un array a un único valor aplicando una expresión acumulativa",
        "option_c": "Reduce la velocidad de queries",
        "option_d": "Elimina duplicados",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$reduce: procesa array elemento por elemento acumulando resultado: {$reduce: {input: '$array', initialValue: valor, in: {expresión con $$value y $$this}}}. Similar a Array.reduce(). $$value: acumulador, $$this: elemento actual. Ejemplo: sumar array manualmente.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo sumas todos los elementos de un array de números?",
        "option_a": "db.coleccion.aggregate([{$project: {total: {$reduce: {input: '$numbers', initialValue: 0, in: {$add: ['$$value', '$$this']}}}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {total: {$sum: '$numbers'}}}])",
        "option_c": "Ambas a y b son correctas",
        "option_d": "db.coleccion.aggregate([{$project: {total: {$reduce: {array: '$numbers', operation: 'sum'}}}}])",
        "option_e": "No es posible",
        "correct_answer": "c",
        "explanation": "$sum: '$arrayField' suma elementos directamente (más simple). $reduce más flexible para operaciones complejas. $reduce: $$value es acumulador (empieza en initialValue), $$this es elemento actual. Ambos funcionan para suma simple.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $switch?",
        "option_a": "Cambia de base de datos",
        "option_b": "Operador multi-condicional (como switch/case), evalúa múltiples condiciones y retorna valor según match",
        "option_c": "Alterna entre colecciones",
        "option_d": "Cambia tipos de datos",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$switch: múltiples condiciones (más legible que $cond anidados): {$switch: {branches: [{case: cond1, then: val1}, {case: cond2, then: val2}], default: valDefault}}. Evalúa cada case en orden, retorna then del primero que cumple. Útil para categorizaciones complejas.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo categorizas precios en 'low' (<50), 'medium' (50-150), 'high' (>150)?",
        "option_a": "db.listings_limpio.aggregate([{$project: {category: {$switch: {branches: [{case: {$lt: ['$price', 50]}, then: 'low'}, {case: {$lte: ['$price', 150]}, then: 'medium'}], default: 'high'}}}}])",
        "option_b": "db.listings_limpio.aggregate([{$project: {category: {$case: {when: {$lt: ['$price', 50]}, then: 'low', when: {$lte: ['$price', 150]}, then: 'medium', else: 'high'}}}}])",
        "option_c": "db.listings_limpio.aggregate([{$categorize: {field: '$price', ranges: [[0,50,'low'], [50,150,'medium'], [150,Infinity,'high']]}}])",
        "option_d": "db.listings_limpio.aggregate([{$project: {category: {$cond: [{$lt: ['$price', 50]}, 'low', {$cond: [{$lte: ['$price', 150]}, 'medium', 'high']}]}}}])",
        "option_e": "Tanto a como d son correctas",
        "correct_answer": "e",
        "explanation": "$switch más legible para múltiples condiciones. $cond anidados funcionan pero menos legible. branches: array de {case, then}. Evalúa en orden, primero que cumple retorna. default obligatorio. Opción d usa $cond anidados (válido pero complejo).",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $out?",
        "option_a": "Envía output a stdout",
        "option_b": "Escribe el resultado del pipeline en una colección (reemplaza si existe)",
        "option_c": "Exporta a archivo",
        "option_d": "Crea backup",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$out: último stage que escribe resultados en colección: {$out: 'nombreColeccion'}. REEMPLAZA colección si existe (borra contenido anterior). Útil para materializar resultados de agregación compleja. CUIDADO: destructivo. Para append usa $merge.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo guardas resultado de agregación en nueva colección 'vuelos_stats'?",
        "option_a": "db.infovuelos_limpio.aggregate([{$group: {...}}, {$out: 'vuelos_stats'}])",
        "option_b": "db.infovuelos_limpio.aggregate([{$group: {...}}]).save('vuelos_stats')",
        "option_c": "db.infovuelos_limpio.aggregate([{$group: {...}}, {$save: {collection: 'vuelos_stats'}}])",
        "option_d": "db.infovuelos_limpio.aggregate([{$group: {...}}, {$export: 'vuelos_stats'}])",
        "option_e": "No es posible guardar resultados",
        "correct_answer": "a",
        "explanation": "$out debe ser ÚLTIMO stage. Crea colección si no existe, REEMPLAZA si existe. Mismo DB por default, usa {$out: {db: 'otherDB', coll: 'name'}} para otra DB. MongoDB 4.4+ permite $out con ON clause para sharded collections.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué diferencia hay entre $out y $merge?",
        "option_a": "No hay diferencia",
        "option_b": "$out reemplaza toda la colección, $merge puede hacer upsert, append o custom merge",
        "option_c": "$merge es más rápido",
        "option_d": "$out es más nuevo",
        "option_e": "$merge no existe",
        "correct_answer": "b",
        "explanation": "$out: REEMPLAZA colección completa (destructivo). $merge (4.2+): flexible, puede: 1) insert nuevos docs, 2) update existentes, 3) replace, 4) merge campos, 5) keepExisting. $merge mejor para updates incrementales. $out más simple para replace completo.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo usas $merge para hacer upsert de resultados?",
        "option_a": "db.coleccion.aggregate([{$group: {...}}, {$merge: {into: 'target', on: '_id', whenMatched: 'replace', whenNotMatched: 'insert'}}])",
        "option_b": "db.coleccion.aggregate([{$group: {...}}, {$merge: 'target'}])",
        "option_c": "Ambas a y b son correctas (b usa defaults)",
        "option_d": "db.coleccion.aggregate([{$group: {...}}, {$upsert: {collection: 'target'}}])",
        "option_e": "$merge no soporta upsert",
        "correct_answer": "c",
        "explanation": "$merge: into (colección destino), on (campo para match, default '_id'), whenMatched (merge/replace/keepExisting/fail/pipeline), whenNotMatched (insert/discard/fail). Sin opciones usa defaults: on:'_id', matched:merge, notMatched:insert. Muy potente.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $arrayElemAt?",
        "option_a": "Elimina elementos de array",
        "option_b": "Retorna el elemento en la posición especificada de un array",
        "option_c": "Cuenta elementos de array",
        "option_d": "Ordena arrays",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$arrayElemAt: [array, índice] retorna elemento en posición (0-indexed). Índice negativo cuenta desde el final (-1 = último). Útil para obtener primer/último elemento: {$arrayElemAt: ['$array', 0]} primero, {$arrayElemAt: ['$array', -1]} último.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes el primer y último elemento de un array 'scores'?",
        "option_a": "db.coleccion.aggregate([{$project: {first: {$arrayElemAt: ['$scores', 0]}, last: {$arrayElemAt: ['$scores', -1]}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {first: '$scores[0]', last: '$scores[-1]'}}])",
        "option_c": "db.coleccion.aggregate([{$project: {first: {$first: '$scores'}, last: {$last: '$scores'}}}])",
        "option_d": "Tanto a como c son correctas",
        "option_e": "No es posible",
        "correct_answer": "d",
        "explanation": "$arrayElemAt: [array, índice] o $first/$last: '$array'. Ambos funcionan. $first/$last más semántico para primer/último. $arrayElemAt más flexible (cualquier posición). NOTA: $first/$last en $group son acumuladores (diferente contexto).",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $size?",
        "option_a": "Retorna el tamaño en bytes de un documento",
        "option_b": "Retorna el número de elementos en un array",
        "option_c": "Cambia el tamaño de campos",
        "option_d": "Limita el tamaño de resultados",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$size: '$arrayField' retorna cantidad de elementos en array. Si campo no es array o es null/missing retorna error (usa $ifNull para manejar). Útil para filtrar por tamaño: {$match: {$expr: {$gt: [{$size: '$tags'}, 3]}}}.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo filtras documentos donde el array 'tags' tiene más de 5 elementos?",
        "option_a": "db.coleccion.aggregate([{$match: {$expr: {$gt: [{$size: '$tags'}, 5]}}}])",
        "option_b": "db.coleccion.aggregate([{$match: {tags: {$size: {$gt: 5}}}}])",
        "option_c": "db.coleccion.aggregate([{$match: {'tags.length': {$gt: 5}}}])",
        "option_d": "db.coleccion.find({tags: {$size: {$gt: 5}}})",
        "option_e": "Todas son correctas",
        "correct_answer": "a",
        "explanation": "$size no funciona directamente en $match (no es operador de query). Debes usar $expr para evaluar expresión: {$expr: {$gt: [{$size: '$campo'}, N]}}. find() con $size solo admite valor exacto: {tags: {$size: 5}}, NO soporta comparadores.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $slice en arrays?",
        "option_a": "Divide documentos",
        "option_b": "Retorna un subconjunto de elementos de un array (como Array.slice)",
        "option_c": "Ordena arrays",
        "option_d": "Suma elementos",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$slice: [array, n] retorna primeros n elementos (n>0) o últimos n (n<0). $slice: [array, start, count] retorna count elementos desde start. Útil para limitar arrays grandes en output. NOTA: $slice también existe en projection de find().",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes los primeros 3 elementos de un array 'reviews'?",
        "option_a": "db.coleccion.aggregate([{$project: {topReviews: {$slice: ['$reviews', 3]}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {topReviews: {$limit: {array: '$reviews', n: 3}}}}])",
        "option_c": "db.coleccion.aggregate([{$project: {topReviews: '$reviews.slice(0, 3)'}}])",
        "option_d": "db.coleccion.find({}, {reviews: {$slice: 3}})",
        "option_e": "Tanto a como d son correctas",
        "correct_answer": "e",
        "explanation": "$slice funciona en aggregate y en projection de find(). Aggregate: {$slice: [array, n]}. find(): {campo: {$slice: n}}. Sintaxis diferente pero ambos funcionan. Útil para limitar arrays grandes (reviews, comments) y reducir tamaño de response.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $ifNull?",
        "option_a": "Valida si un valor es null",
        "option_b": "Retorna valor alternativo si el campo es null o missing",
        "option_c": "Elimina valores null",
        "option_d": "Crea campos null",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$ifNull: [expresión, valorSiNull] retorna la expresión si no es null/missing, sino retorna valorSiNull. Útil para defaults: {$ifNull: ['$campo', 0]} usa 0 si campo no existe. También: $coalesce (MongoDB 4.4+) para múltiples valores.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo calculas un descuento, usando 0 si el campo discount no existe?",
        "option_a": "db.coleccion.aggregate([{$project: {finalPrice: {$subtract: ['$price', {$ifNull: ['$discount', 0]}]}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {finalPrice: {$subtract: ['$price', {$default: ['$discount', 0]}]}}}])",
        "option_c": "db.coleccion.aggregate([{$project: {finalPrice: {$subtract: ['$price', '$discount || 0']}}}])",
        "option_d": "db.coleccion.aggregate([{$project: {finalPrice: {$subtract: ['$price', {$coalesce: ['$discount', 0]}]}}}])",
        "option_e": "Tanto a como d son correctas (d requiere MongoDB 4.4+)",
        "correct_answer": "e",
        "explanation": "$ifNull: [campo, default] funciona en todas las versiones. $coalesce: [expr1, expr2, ..., default] (4.4+) retorna primera expresión no-null. Ambos útiles para manejar campos opcionales. $coalesce más potente (múltiples fallbacks).",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $replaceRoot?",
        "option_a": "Reemplaza la base de datos",
        "option_b": "Reemplaza el documento raíz con un subdocumento o expresión",
        "option_c": "Reemplaza campos",
        "option_d": "Reemplaza colección",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$replaceRoot: {newRoot: expresión} reemplaza todo el documento. Útil para: 1) promover subdocumento a raíz: {newRoot: '$embedded'}, 2) reestructurar con $mergeObjects. $replaceWith (4.2+) es alias más corto. Poderoso para transformaciones radicales.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo promueves un subdocumento 'address' a nivel raíz?",
        "option_a": "db.coleccion.aggregate([{$replaceRoot: {newRoot: '$address'}}])",
        "option_b": "db.coleccion.aggregate([{$replaceWith: '$address'}])",
        "option_c": "Ambas a y b son correctas",
        "option_d": "db.coleccion.aggregate([{$project: {_id: 0, address: 1}}])",
        "option_e": "No es posible",
        "correct_answer": "c",
        "explanation": "$replaceRoot: {newRoot: '$subDoc'} o $replaceWith: '$subDoc' (alias desde 4.2). Ambas funcionan igual. Documento resultante = el subdocumento. CUIDADO: pierdes campos del nivel raíz. Para mantener algunos usa $mergeObjects: {$mergeObjects: ['$address', {oldId: '$_id'}]}.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $mergeObjects?",
        "option_a": "Une colecciones",
        "option_b": "Combina múltiples objetos en uno solo (merge de campos)",
        "option_c": "Compara objetos",
        "option_d": "Serializa objetos",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$mergeObjects: [obj1, obj2, ...] combina objetos. Si campos duplicados, último objeto gana. Útil para: 1) combinar subdocumentos, 2) agregar campos: {$mergeObjects: ['$$ROOT', {newField: valor}]}, 3) con $replaceRoot para reestructurar manteniendo campos.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo combinas campos del documento raíz con un subdocumento?",
        "option_a": "db.coleccion.aggregate([{$replaceRoot: {newRoot: {$mergeObjects: ['$$ROOT', '$subdoc']}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {$merge: ['$$ROOT', '$subdoc']}}])",
        "option_c": "db.coleccion.aggregate([{$addFields: '$subdoc'}])",
        "option_d": "db.coleccion.aggregate([{$extend: {with: '$subdoc'}}])",
        "option_e": "No es posible",
        "correct_answer": "a",
        "explanation": "$mergeObjects con $$ROOT (documento actual) y subdoc. Si hay campos duplicados, subdoc sobreescribe. Orden importa. Para no perder campos raíz, ponlo primero. Alternativa más simple: $addFields extrae campos sin $replaceRoot.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el stage $sample?",
        "option_a": "Crea muestras estadísticas",
        "option_b": "Retorna N documentos aleatorios de la colección",
        "option_c": "Muestrea campos",
        "option_d": "Reduce calidad de datos",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$sample: {size: N} retorna N docs aleatorios. Útil para: testing, visualizaciones, análisis exploratorio. Si N <= 5% de colección, usa algoritmo random. Si N > 5%, hace full scan + sort aleatorio. Mejor performance con tamaños pequeños.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes 10 vuelos aleatorios de infovuelos_limpio?",
        "option_a": "db.infovuelos_limpio.aggregate([{$sample: {size: 10}}])",
        "option_b": "db.infovuelos_limpio.aggregate([{$random: {limit: 10}}])",
        "option_c": "db.infovuelos_limpio.find().random(10)",
        "option_d": "db.infovuelos_limpio.aggregate([{$limit: 10}, {$shuffle: true}])",
        "option_e": "db.infovuelos_limpio.sample(10)",
        "correct_answer": "a",
        "explanation": "$sample: {size: N} debe ser primer stage (o después de $match si quieres filtrar primero). Eficiente para samples pequeños. Para datasets pequeños (<100 docs), puede retornar duplicados en múltiples ejecuciones. No garantiza orden aleatorio diferente cada vez.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué operadores lógicos existen en aggregation expressions?",
        "option_a": "Solo $and",
        "option_b": "$and, $or, $not (operan sobre expresiones booleanas)",
        "option_c": "&&, ||, !",
        "option_d": "AND, OR, NOT",
        "option_e": "No hay operadores lógicos",
        "correct_answer": "b",
        "explanation": "$and: [expr1, expr2, ...] retorna true si TODAS son true. $or: [expr1, expr2, ...] retorna true si ALGUNA es true. $not: [expr] niega. Útiles en $cond, $switch, $filter. SINTAXIS: arrays de expresiones que retornan boolean.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo filtras listings donde price < 100 Y availability > 300?",
        "option_a": "db.listings_limpio.aggregate([{$match: {$expr: {$and: [{$lt: ['$price', 100]}, {$gt: ['$availability_365', 300]}]}}}])",
        "option_b": "db.listings_limpio.aggregate([{$match: {price: {$lt: 100}, availability_365: {$gt: 300}}}])",
        "option_c": "Ambas a y b son correctas",
        "option_d": "db.listings_limpio.aggregate([{$match: {$and: [{price: {$lt: 100}}, {availability_365: {$gt: 300}}]}}])",
        "option_e": "Tanto b como d son correctas",
        "correct_answer": "e",
        "explanation": "En $match: sintaxis de query regular funciona: {campo1: {op}, campo2: {op}} (AND implícito) o $and explícito. $expr con operadores de expresión también funciona pero más verbose. Para condiciones simples en $match, usa sintaxis query. $expr necesario para comparar dos campos.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $type?",
        "option_a": "Cambia tipo de datos",
        "option_b": "Retorna el tipo BSON del valor de un campo (string, int, array, etc.)",
        "option_c": "Valida tipos",
        "option_d": "Crea índices por tipo",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$type: '$campo' retorna string con tipo BSON: 'double', 'string', 'object', 'array', 'null', 'bool', 'int', 'long', etc. Útil para validar tipos en pipelines o filtrar por tipo. También: $isNumber (4.4+) retorna boolean.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo filtras documentos donde el campo 'price' es un string (debería ser número)?",
        "option_a": "db.listings_limpio.aggregate([{$match: {$expr: {$eq: [{$type: '$price'}, 'string']}}}])",
        "option_b": "db.listings_limpio.aggregate([{$match: {price: {$type: 'string'}}}])",
        "option_c": "Ambas a y b son correctas",
        "option_d": "db.listings_limpio.find({price: {$type: 2}})",
        "option_e": "Todas excepto ninguna",
        "correct_answer": "c",
        "explanation": "$type funciona en $match query (opciones: tipo string o número BSON) y en $expr expressions (retorna string). En query: {campo: {$type: 'string'}} o {campo: {$type: 2}} (2=string en BSON). En $expr: {$eq: [{$type: '$campo'}, 'string']}.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $convert?",
        "option_a": "Convierte colecciones",
        "option_b": "Convierte el valor de un campo a otro tipo (string to int, etc.)",
        "option_c": "Convierte formatos de archivo",
        "option_d": "Convierte encoding",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$convert: {input: valor, to: 'tipo', onError: valError, onNull: valNull} convierte tipos. to: 'double', 'string', 'int', 'long', 'decimal', 'bool', 'date', 'objectId'. Útil para limpiar datos con tipos incorrectos. También: shortcuts $toString, $toInt, $toDouble.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo conviertes un campo 'price' de string a número?",
        "option_a": "db.listings_limpio.aggregate([{$addFields: {price: {$toDouble: '$price'}}}])",
        "option_b": "db.listings_limpio.aggregate([{$addFields: {price: {$convert: {input: '$price', to: 'double'}}}}])",
        "option_c": "Ambas a y b son correctas",
        "option_d": "db.listings_limpio.aggregate([{$project: {price: {$cast: {field: '$price', as: 'double'}}}}])",
        "option_e": "No es posible convertir tipos en aggregate",
        "correct_answer": "c",
        "explanation": "$toDouble: '$campo' es shortcut de $convert. Ambos funcionan. $convert más flexible (onError, onNull). Si conversión falla sin onError: error. Shortcuts: $toString, $toInt, $toLong, $toDouble, $toBool, $toDate, $toObjectId. Muy útil para limpieza de datos.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es el operador $let y para qué sirve?",
        "option_a": "Declara constantes",
        "option_b": "Define variables locales para reutilizar en expresiones complejas",
        "option_c": "Permite iteración",
        "option_d": "Crea funciones",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$let: {vars: {var1: expr1, var2: expr2}, in: expresiónUsandoVariables} define variables temporales. Variables accesibles con $$nombre. Útil para: 1) evitar repetir expresiones complejas, 2) mejorar legibilidad, 3) calcular valores intermedios. Similar a let en programación.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo usas $let para calcular IVA una vez y reutilizarlo?",
        "option_a": "db.coleccion.aggregate([{$project: {resultado: {$let: {vars: {iva: {$multiply: ['$price', 0.21]}}, in: {precioConIVA: {$add: ['$price', '$$iva']}, soloIVA: '$$iva'}}}}}])",
        "option_b": "db.coleccion.aggregate([{$addFields: {iva: {$multiply: ['$price', 0.21]}}}, {$project: {precioConIVA: {$add: ['$price', '$iva']}}}])",
        "option_c": "Ambas funcionan pero a es más eficiente (una sola pasada)",
        "option_d": "db.coleccion.aggregate([{$let: {iva: {$multiply: ['$price', 0.21]}}, $project: {precioConIVA: {$add: ['$price', '$iva']}}}])",
        "option_e": "No es posible reutilizar cálculos",
        "correct_answer": "c",
        "explanation": "$let calcula vars una vez, reutiliza en 'in'. Más eficiente que calcular repetidamente. Opción b funciona pero dos stages. $let útil para expresiones complejas en mismo stage. Variables con $$nombre. Mejora performance y legibilidad.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "Pipeline complejo: vuelos por origen con stats de escalas en infovuelos_limpio",
        "option_a": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', totalVuelos: {$sum: 1}, avgEscalas: {$avg: '$NumEscalas'}, maxEscalas: {$max: '$NumEscalas'}}}, {$sort: {totalVuelos: -1}}])",
        "option_b": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen'}}, {$lookup: {from: 'infovuelos_limpio', pipeline: [{$group: {_id: null, avg: {$avg: '$NumEscalas'}}}]}}])",
        "option_c": "db.infovuelos_limpio.group({key: {Origen: 1}, reduce: function() {}})",
        "option_d": "db.infovuelos_limpio.aggregate([{$stats: {groupBy: '$Origen', field: '$NumEscalas'}}])",
        "option_e": "Opción a es la correcta",
        "correct_answer": "e",
        "explanation": "Pipeline combina $group (agrupa por Origen + múltiples acumuladores) y $sort (ordena por totalVuelos descendente). Un solo $group puede calcular múltiples stats. Resultado: cada origen con total, promedio y máximo de escalas, ordenado. Elegante y eficiente.",
        "difficulty": "hard",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes top 5 barrios con mayor precio promedio en listings_limpio?",
        "option_a": "db.listings_limpio.aggregate([{$group: {_id: '$neighbourhood', avgPrice: {$avg: '$price'}}}, {$sort: {avgPrice: -1}}, {$limit: 5}])",
        "option_b": "db.listings_limpio.aggregate([{$sort: {price: -1}}, {$limit: 5}, {$group: {_id: '$neighbourhood', avgPrice: {$avg: '$price'}}}])",
        "option_c": "db.listings_limpio.find().sort({price: -1}).limit(5).group({_id: '$neighbourhood'})",
        "option_d": "db.listings_limpio.aggregate([{$group: {_id: '$neighbourhood', avgPrice: {$avg: '$price'}, total: {$sum: 1}}}, {$topN: {n: 5, sortBy: {avgPrice: -1}}}])",
        "option_e": "Tanto a como d son correctas (d requiere MongoDB 5.2+)",
        "correct_answer": "e",
        "explanation": "Opción a: clásico group+sort+limit. Opción d: $topN (5.2+) más eficiente y semántico. ORDEN IMPORTA: group primero (calcula avg), luego sort (ordena grupos), luego limit (top 5). Opción b incorrecta (sort/limit antes de group no calcula avg correctamente).",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es $expr y cuándo usarlo en $match?",
        "option_a": "Un tipo de expresión regular",
        "option_b": "Permite usar operadores de aggregation expression dentro de $match para comparar campos",
        "option_c": "Optimiza queries",
        "option_d": "Valida expresiones",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$expr en $match: evalúa aggregation expressions. NECESARIO para: 1) comparar dos campos: {$match: {$expr: {$gt: ['$price', '$cost']}}}, 2) usar operadores como $size, $arrayElemAt. Sin $expr, $match solo usa query operators. CUIDADO: $expr NO usa índices (más lento).",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo filtras listings donde price > (minimum_nights * 10)?",
        "option_a": "db.listings_limpio.aggregate([{$match: {$expr: {$gt: ['$price', {$multiply: ['$minimum_nights', 10]}]}}}])",
        "option_b": "db.listings_limpio.aggregate([{$match: {price: {$gt: {$multiply: ['$minimum_nights', 10]}}}}])",
        "option_c": "db.listings_limpio.find({price: {$gt: '$minimum_nights * 10'}})",
        "option_d": "db.listings_limpio.aggregate([{$where: 'this.price > this.minimum_nights * 10'}])",
        "option_e": "Tanto a como d son correctas",
        "correct_answer": "e",
        "explanation": "$expr permite comparar campos con operadores aggregation. $where usa JavaScript (más lento, eval). Opción a: preferida (declarativa, más clara). $expr NO usa índices. Si puedes, filtra con índices primero, luego $expr para condiciones complejas.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el acumulador $first en $group?",
        "option_a": "Retorna el primer documento de la colección",
        "option_b": "Retorna el valor del campo del primer documento de cada grupo (según orden de llegada o $sort previo)",
        "option_c": "Retorna el primer carácter",
        "option_d": "Filtra documentos",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$first en $group: retorna valor del primer doc del grupo. Orden depende de: 1) $sort antes de $group (determinístico), 2) orden natural si no hay $sort (no determinístico). Útil para obtener sample doc de cada grupo. Pareja: $last para último.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes el vuelo con más escalas por cada origen?",
        "option_a": "db.infovuelos_limpio.aggregate([{$sort: {NumEscalas: -1}}, {$group: {_id: '$Origen', maxEscalasVuelo: {$first: '$$ROOT'}}}])",
        "option_b": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', maxEscalas: {$max: '$NumEscalas'}}}])",
        "option_c": "db.infovuelos_limpio.aggregate([{$group: {_id: '$Origen', vueloMax: {$top: {field: 'NumEscalas'}}}}])",
        "option_d": "Opción a da el doc completo, b solo el número máximo",
        "option_e": "Todas son incorrectas",
        "correct_answer": "d",
        "explanation": "Para doc completo: $sort + $group + $first: '$$ROOT'. $$ROOT es documento completo. DEBE haber $sort antes para orden correcto. Opción b solo retorna número (no doc). Para obtener doc con max valor, necesitas sort primero. MongoDB 5.2+ tiene $topN/$bottomN más directo.",
        "difficulty": "hard",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es $$ROOT?",
        "option_a": "Usuario root de MongoDB",
        "option_b": "Variable especial que referencia el documento actual completo",
        "option_c": "Directorio raíz",
        "option_d": "Colección root",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$$ROOT: variable del sistema que referencia documento completo actual. Útil en $group para preservar doc: {$first: '$$ROOT'}, o en $project para incluir todo + campos nuevos: {$mergeObjects: ['$$ROOT', {nuevo: valor}]}. $$ indica variable (diferente de $ que indica campo).",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo agregas un campo calculado manteniendo todos los campos existentes?",
        "option_a": "db.coleccion.aggregate([{$addFields: {nuevo: {$multiply: ['$price', 1.1]}}}])",
        "option_b": "db.coleccion.aggregate([{$set: {nuevo: {$multiply: ['$price', 1.1]}}}])",
        "option_c": "db.coleccion.aggregate([{$project: {$mergeObjects: ['$$ROOT', {nuevo: {$multiply: ['$price', 1.1]}}]}}])",
        "option_d": "Todas son correctas",
        "option_e": "Solo a y b son correctas",
        "correct_answer": "e",
        "explanation": "$addFields y $set (alias desde 4.2) agregan campos manteniendo existentes. $project con $mergeObjects también funciona pero más verbose. $addFields/$set más simple y legible. $project sin merge REEMPLAZA campos (solo incluye especificados). Usa $addFields para agregar.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $in en aggregation expressions?",
        "option_a": "Filtra documentos",
        "option_b": "Verifica si un valor está en un array (retorna boolean)",
        "option_c": "Inserta valores",
        "option_d": "Importa datos",
        "option_e": "No existe en expressions",
        "correct_answer": "b",
        "explanation": "$in: [valor, array] retorna true si valor está en array. Útil en $cond, $filter, $match con $expr. Ejemplo: verificar si tag específico está en array de tags: {$in: ['MongoDB', '$tags']}. DIFERENTE de $in en queries (sintaxis diferente).",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo verificas si 'wifi' está en el array amenities?",
        "option_a": "db.listings_limpio.aggregate([{$project: {hasWifi: {$in: ['wifi', '$amenities']}}}])",
        "option_b": "db.listings_limpio.aggregate([{$match: {amenities: 'wifi'}}])",
        "option_c": "db.listings_limpio.aggregate([{$project: {hasWifi: {$contains: ['$amenities', 'wifi']}}}])",
        "option_d": "Tanto a como b son correctas (diferentes contextos)",
        "option_e": "Solo b es correcta",
        "correct_answer": "d",
        "explanation": "$in expression: [valor, array] en $project para crear campo boolean. $match con {array: valor} filtra docs donde array contiene valor. Contextos diferentes: $match filtra, $project crea campo. Ambos útiles según necesidad.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre $$ y $ en aggregation?",
        "option_a": "No hay diferencia",
        "option_b": "$ referencia campos del documento, $$ referencia variables definidas en pipeline",
        "option_c": "$$ es más lento",
        "option_d": "$ es deprecado",
        "option_e": "No hay variables en aggregation",
        "correct_answer": "b",
        "explanation": "$: field path (valor de campo del documento). $$: variable del sistema o definida por usuario ($let, $filter, $map, $reduce). Variables sistema: $$ROOT (doc actual), $$NOW (fecha actual), $$CURRENT (en $lookup). Variables usuario: definidas en as, vars.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "Pipeline: listings con price>100, top 10 por reviews, solo name y price",
        "option_a": "db.listings_limpio.aggregate([{$match: {price: {$gt: 100}}}, {$sort: {number_of_reviews: -1}}, {$limit: 10}, {$project: {name: 1, price: 1}}])",
        "option_b": "db.listings_limpio.aggregate([{$sort: {number_of_reviews: -1}}, {$match: {price: {$gt: 100}}}, {$limit: 10}, {$project: {name: 1, price: 1}}])",
        "option_c": "db.listings_limpio.find({price: {$gt: 100}}).sort({number_of_reviews: -1}).limit(10).project({name: 1, price: 1})",
        "option_d": "Opciones a y c son correctas",
        "option_e": "Solo a es correcta",
        "correct_answer": "e",
        "explanation": "ORDEN IMPORTA en aggregation: 1) $match primero (filtra, puede usar índices), 2) $sort (ordena los filtrados), 3) $limit (top 10), 4) $project (limpia output). Opción b incorrecta (sort antes de match = ordena todos, ineficiente). find() no tiene project(), usa projection en segundo parámetro.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es el operador $concatArrays?",
        "option_a": "Concatena strings",
        "option_b": "Combina múltiples arrays en uno solo",
        "option_c": "Cuenta arrays",
        "option_d": "Ordena arrays",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$concatArrays: [array1, array2, ...] combina arrays en uno. Si algún input no es array o es null, retorna null (usa $ifNull para manejar). Útil para merge de múltiples arrays. Ejemplo: combinar tags de diferentes fuentes.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo combinas dos arrays 'tags1' y 'tags2' en uno solo?",
        "option_a": "db.coleccion.aggregate([{$project: {allTags: {$concatArrays: ['$tags1', '$tags2']}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {allTags: {$concat: ['$tags1', '$tags2']}}}])",
        "option_c": "db.coleccion.aggregate([{$project: {allTags: {$merge: ['$tags1', '$tags2']}}}])",
        "option_d": "db.coleccion.aggregate([{$project: {allTags: '$tags1 + $tags2'}}])",
        "option_e": "No es posible combinar arrays",
        "correct_answer": "a",
        "explanation": "$concatArrays para arrays, $concat para strings. DIFERENTE operadores. $merge es para objetos (no arrays). Si quieres únicos después de concat: usa $setUnion en lugar de $concatArrays. Para flatten nested arrays: $reduce.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $setUnion?",
        "option_a": "Une colecciones",
        "option_b": "Retorna array con elementos únicos de múltiples arrays (unión de conjuntos)",
        "option_c": "Configura uniones",
        "option_d": "Crea índices",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$setUnion: [array1, array2, ...] retorna unión (elementos únicos de todos los arrays). Elimina duplicados automáticamente. También: $setIntersection (intersección), $setDifference (diferencia). Operadores de teoría de conjuntos. Útiles para análisis de arrays.",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes elementos que están en array1 pero NO en array2?",
        "option_a": "db.coleccion.aggregate([{$project: {difference: {$setDifference: ['$array1', '$array2']}}}])",
        "option_b": "db.coleccion.aggregate([{$project: {difference: {$subtract: ['$array1', '$array2']}}}])",
        "option_c": "db.coleccion.aggregate([{$project: {difference: {$filter: {input: '$array1', cond: {$not: {$in: ['$$this', '$array2']}}}}}}])",
        "option_d": "Tanto a como c son correctas",
        "option_e": "Solo a es correcta",
        "correct_answer": "d",
        "explanation": "$setDifference: [array1, array2] retorna elementos en array1 no en array2 (más simple). $filter con $not + $in también funciona (más verbose). $setDifference optimizado para conjuntos. Resultado: elementos únicos. $subtract es para números (no arrays).",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué hace el operador $reverseArray?",
        "option_a": "Revierte transacciones",
        "option_b": "Invierte el orden de elementos de un array",
        "option_c": "Revierte documentos",
        "option_d": "Deshace cambios",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$reverseArray: '$array' invierte orden: [1,2,3] → [3,2,1]. Si no es array o es null, retorna null. Útil para: procesar desde el final, últimos N elementos sin $slice negativo complicado. Simple operador de conveniencia.",
        "difficulty": "easy"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "Pipeline complejo: precio promedio por neighbourhood con min 5 listings",
        "option_a": "db.listings_limpio.aggregate([{$group: {_id: '$neighbourhood', avgPrice: {$avg: '$price'}, count: {$sum: 1}}}, {$match: {count: {$gte: 5}}}, {$sort: {avgPrice: -1}}])",
        "option_b": "db.listings_limpio.aggregate([{$match: {neighbourhood: {$exists: true}}}, {$group: {_id: '$neighbourhood', avgPrice: {$avg: '$price'}}}, {$match: {count: {$gte: 5}}}])",
        "option_c": "db.listings_limpio.aggregate([{$group: {_id: '$neighbourhood', avgPrice: {$avg: '$price'}}}, {$having: {count: {$gte: 5}}}])",
        "option_d": "Opción a es correcta",
        "option_e": "Ninguna es correcta",
        "correct_answer": "d",
        "explanation": "Pipeline: 1) $group calcula avg + count por neighbourhood, 2) $match filtra grupos con count>=5 (equivalente a HAVING en SQL), 3) $sort ordena por avgPrice. CLAVE: $match DESPUÉS de $group filtra grupos (no documentos). No existe $having en MongoDB, usa $match post-group.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Cuándo deberías usar $unwind?",
        "option_a": "Siempre que tengas arrays",
        "option_b": "Cuando necesitas procesar/agrupar por elementos individuales de un array",
        "option_c": "Nunca, es muy lento",
        "option_d": "Solo para arrays pequeños",
        "option_e": "Para ordenar arrays",
        "correct_answer": "b",
        "explanation": "$unwind útil para: 1) agrupar por elementos de array (ej: ventas por producto cuando pedido tiene múltiples productos), 2) filtrar por propiedades de objetos en array. CUIDADO: puede multiplicar docs (array 100 elementos = 100 docs). Costoso en arrays grandes. Evita si puedes usar operadores array ($filter, $map).",
        "difficulty": "medium"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "¿Cómo cuentas frecuencia de cada tag en todos los documentos?",
        "option_a": "db.coleccion.aggregate([{$unwind: '$tags'}, {$group: {_id: '$tags', count: {$sum: 1}}}, {$sort: {count: -1}}])",
        "option_b": "db.coleccion.aggregate([{$group: {_id: '$tags', count: {$sum: 1}}}])",
        "option_c": "db.coleccion.aggregate([{$project: {tags: 1}}, {$count: 'tags'}])",
        "option_d": "db.coleccion.distinct('tags').length",
        "option_e": "No es posible",
        "correct_answer": "a",
        "explanation": "$unwind descompone array tags (1 doc con [a,b,c] → 3 docs con a, b, c). Luego $group por tag y $sum: 1 cuenta ocurrencias. $sort ordena por frecuencia. Patrón común para tag clouds, análisis de frecuencias. Opción b NO hace unwind (agrupa por array completo).",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Qué es $lookup con pipeline (uncorrelated subquery)?",
        "option_a": "Error de sintaxis",
        "option_b": "$lookup avanzado que permite ejecutar un sub-pipeline completo en la colección externa",
        "option_c": "Un tipo de índice",
        "option_d": "Solo funciona en sharded clusters",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$lookup con pipeline (4.0+): más flexible que sintaxis simple. Permite: 1) sub-pipeline completo en colección externa, 2) variables con $let para pasar valores, 3) $match complejos, 4) múltiples stages. Sintaxis: {from, let: {var: '$campo'}, pipeline: [{stages usando $$var}], as}.",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la mejor práctica para pipelines de aggregation largos?",
        "option_a": "Poner todo en un solo stage",
        "option_b": "Filtrar temprano ($match), proyectar tarde, usar índices, considerar allowDiskUse",
        "option_c": "Usar siempre $out al final",
        "option_d": "Evitar $group",
        "option_e": "No hay best practices",
        "correct_answer": "b",
        "explanation": "Best practices: 1) $match TEMPRANO (usa índices, reduce docs), 2) $project TARDE (solo cuando necesites limitar campos para output), 3) considera allowDiskUse para grandes volúmenes, 4) usa explain() para analizar, 5) stages lightweight primero, 6) evita $lookup si puedes (costoso).",
        "difficulty": "medium"
    }
]

# Total Batch 7: 56 preguntas
# Categoría 6 (Agregación): 101 preguntas ✅
# Total acumulado: 372 preguntas de 520

# ============================================================================
# BATCH 8: CATEGORÍA 7 - MONGODB + PYTHON (PyMongo) (60 preguntas)
# ============================================================================

QUESTIONS_BATCH_8 = [
    # ==================== CATEGORÍA 7: MONGODB + PYTHON ====================

    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es PyMongo?",
        "option_a": "Una base de datos NoSQL",
        "option_b": "El driver oficial de Python para MongoDB",
        "option_c": "Un framework web para Python",
        "option_d": "Una versión de MongoDB escrita en Python",
        "option_e": "Un ORM para MongoDB",
        "correct_answer": "b",
        "explanation": "PyMongo es el driver oficial de Python para MongoDB. Permite conectar aplicaciones Python a MongoDB y realizar operaciones CRUD, agregaciones, etc. No es ORM (para eso existe MongoEngine, ODMantic). Instalación: pip install pymongo.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo instalas PyMongo?",
        "option_a": "pip install pymongo",
        "option_b": "pip install mongodb",
        "option_c": "npm install pymongo",
        "option_d": "apt-get install pymongo",
        "option_e": "conda install mongodb",
        "correct_answer": "a",
        "explanation": "pip install pymongo instala el driver oficial. Opcionalmente pip install 'pymongo[srv]' incluye soporte para connection strings mongodb+srv://. También: pip install 'pymongo[encryption]' para client-side field level encryption.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo te conectas a MongoDB local con PyMongo?",
        "option_a": "from pymongo import MongoClient\nclient = MongoClient('mongodb://localhost:27017/')",
        "option_b": "import pymongo\nconnection = pymongo.connect('localhost:27017')",
        "option_c": "from mongo import Client\nclient = Client('localhost')",
        "option_d": "import mongodb\ndb = mongodb.connect()",
        "option_e": "from pymongo import Connection\nconn = Connection('localhost')",
        "correct_answer": "a",
        "explanation": "MongoClient es la clase principal. Default localhost:27017: MongoClient() sin parámetros funciona. Connection string completo: 'mongodb://localhost:27017/'. También: MongoClient('localhost', 27017) o MongoClient(host='localhost', port=27017). MongoClient es thread-safe.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo accedes a una base de datos y colección con PyMongo?",
        "option_a": "client = MongoClient()\ndb = client['mi_base']\ncol = db['mi_coleccion']",
        "option_b": "client = MongoClient()\ndb = client.database('mi_base')\ncol = db.collection('mi_coleccion')",
        "option_c": "client = MongoClient()\ndb = client.get_database('mi_base')\ncol = db.get_collection('mi_coleccion')",
        "option_d": "Tanto a como c son correctas",
        "option_e": "Solo c es correcta",
        "correct_answer": "d",
        "explanation": "Dos formas: dict-style client['db']['col'] o métodos get_database(), get_collection(). Ambas válidas. Dot notation también funciona: client.mi_base.mi_coleccion (si nombres válidos Python). DB y colección se crean automáticamente al insertar primer doc.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con PyMongo?",
        "option_a": "collection.insert_one({'nombre': 'Juan', 'edad': 30})",
        "option_b": "collection.insert({'nombre': 'Juan', 'edad': 30})",
        "option_c": "collection.add({'nombre': 'Juan', 'edad': 30})",
        "option_d": "collection.create({'nombre': 'Juan', 'edad': 30})",
        "option_e": "collection.save({'nombre': 'Juan', 'edad': 30})",
        "correct_answer": "a",
        "explanation": "insert_one(doc) inserta UN documento. Retorna InsertOneResult con inserted_id. insert_many([doc1, doc2, ...]) para múltiples. insert() deprecado (usa insert_one/insert_many). save() deprecado. PyMongo usa dicts Python como documentos.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes el _id de un documento insertado?",
        "option_a": "result = collection.insert_one(doc)\nid = result.inserted_id",
        "option_b": "result = collection.insert_one(doc)\nid = result.id",
        "option_c": "result = collection.insert_one(doc)\nid = result._id",
        "option_d": "result = collection.insert_one(doc)\nid = doc['_id']",
        "option_e": "Tanto a como d son correctas",
        "correct_answer": "e",
        "explanation": "insert_one retorna InsertOneResult con inserted_id. PyMongo AGREGA _id al dict original si no existe (modifica in-place). Así que doc['_id'] también funciona después de insert. _id es ObjectId por default.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras UN documento con PyMongo?",
        "option_a": "doc = collection.find_one({'nombre': 'Juan'})",
        "option_b": "doc = collection.find({'nombre': 'Juan'}).first()",
        "option_c": "doc = collection.get({'nombre': 'Juan'})",
        "option_d": "doc = collection.findOne({'nombre': 'Juan'})",
        "option_e": "Tanto a como b son correctas",
        "correct_answer": "e",
        "explanation": "find_one(filtro) retorna UN documento (dict) o None si no encuentra. find(filtro) retorna cursor; .first() NO existe pero next(cursor, None) funciona. Mejor: usa find_one para un solo doc. find_one más eficiente (auto limit 1).",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo iteras sobre resultados de find()?",
        "option_a": "for doc in collection.find({'edad': {'$gt': 18}}):\n    print(doc['nombre'])",
        "option_b": "cursor = collection.find({'edad': {'$gt': 18}})\nfor doc in cursor:\n    print(doc['nombre'])",
        "option_c": "Ambas a y b son correctas",
        "option_d": "docs = collection.find({'edad': {'$gt': 18}}).toArray()\nfor doc in docs:\n    print(doc['nombre'])",
        "option_e": "Todas son correctas",
        "correct_answer": "c",
        "explanation": "find() retorna cursor iterable. Puedes iterar directamente o guardar en variable primero. Cursor es lazy (no carga todos en memoria). Para lista: list(cursor) o cursor.to_list() (motor). toArray() no existe en PyMongo (es de mongo shell JS).",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es un cursor en PyMongo?",
        "option_a": "Un puntero a la base de datos",
        "option_b": "Un iterador lazy que obtiene documentos bajo demanda del servidor",
        "option_c": "Una lista de documentos",
        "option_d": "Un índice",
        "option_e": "No existe el concepto de cursor",
        "correct_answer": "b",
        "explanation": "Cursor: iterador lazy, NO carga todos los docs en memoria. Obtiene batches del servidor según necesidad. Ventaja: eficiente para grandes resultados. Desventaja: cursor se agota al iterar (para reiterar, haz nueva query). Métodos: sort(), limit(), skip().",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas UN documento con PyMongo?",
        "option_a": "collection.update_one({'_id': id}, {'$set': {'edad': 31}})",
        "option_b": "collection.update({'_id': id}, {'edad': 31})",
        "option_c": "collection.modify_one({'_id': id}, {'edad': 31})",
        "option_d": "collection.change({'_id': id}, {'$set': {'edad': 31}})",
        "option_e": "collection.set({'_id': id}, {'edad': 31})",
        "correct_answer": "a",
        "explanation": "update_one(filtro, update) actualiza PRIMER doc que coincide. DEBES usar operadores $set, $inc, etc. Sin operador: reemplaza doc completo (peligroso). Retorna UpdateResult con matched_count, modified_count. update() deprecado.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre update_one y replace_one?",
        "option_a": "No hay diferencia",
        "option_b": "update_one modifica campos con operadores ($set), replace_one reemplaza documento completo",
        "option_c": "update_one es más rápido",
        "option_d": "replace_one no existe",
        "option_e": "update_one solo funciona con _id",
        "correct_answer": "b",
        "explanation": "update_one: modifica campos específicos con operadores. replace_one: REEMPLAZA documento completo (excepto _id). replace_one NO acepta operadores. Usa update_one para updates parciales, replace_one para reemplazo total.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas UN documento con PyMongo?",
        "option_a": "collection.delete_one({'nombre': 'Juan'})",
        "option_b": "collection.remove({'nombre': 'Juan'})",
        "option_c": "collection.drop({'nombre': 'Juan'})",
        "option_d": "collection.destroy({'nombre': 'Juan'})",
        "option_e": "collection.erase({'nombre': 'Juan'})",
        "correct_answer": "a",
        "explanation": "delete_one(filtro) elimina PRIMER doc que coincide. Retorna DeleteResult con deleted_count. delete_many(filtro) para múltiples. remove() deprecado. CUIDADO: delete_one({}) elimina UN doc aleatorio (peligroso sin filtro).",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo cuentas documentos con PyMongo?",
        "option_a": "count = collection.count_documents({'edad': {'$gt': 18}})",
        "option_b": "count = collection.count({'edad': {'$gt': 18}})",
        "option_c": "count = collection.find({'edad': {'$gt': 18}}).count()",
        "option_d": "Todas son correctas",
        "option_e": "Solo a es correcta",
        "correct_answer": "e",
        "explanation": "count_documents(filtro) es el método actual (MongoDB 4.0+). count() y cursor.count() deprecados. Para total de docs: collection.estimated_document_count() (más rápido, usa metadata). count_documents preciso pero más lento.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es ObjectId en PyMongo?",
        "option_a": "Un tipo de índice",
        "option_b": "Un identificador único de 12 bytes generado por MongoDB para _id",
        "option_c": "Una clase de Python estándar",
        "option_d": "Un campo opcional",
        "option_e": "Solo existe en JavaScript",
        "correct_answer": "b",
        "explanation": "ObjectId: tipo BSON de 12 bytes. Incluye: timestamp (4), machine id (3), process id (2), counter (3). from bson import ObjectId. Generado automáticamente para _id si no provees. Sorteable por tiempo. Puede crear manualmente: ObjectId() o desde string: ObjectId('507f1f77bcf86cd799439011').",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas por _id con PyMongo?",
        "option_a": "from bson import ObjectId\ndoc = collection.find_one({'_id': ObjectId('507f1f77bcf86cd799439011')})",
        "option_b": "doc = collection.find_one({'_id': '507f1f77bcf86cd799439011'})",
        "option_c": "doc = collection.find_by_id('507f1f77bcf86cd799439011')",
        "option_d": "doc = collection.get(ObjectId('507f1f77bcf86cd799439011'))",
        "option_e": "Tanto a como b son correctas",
        "correct_answer": "a",
        "explanation": "_id es tipo ObjectId (no string). DEBES convertir string a ObjectId: ObjectId(string). Si insertas con _id string, quedará como string (no recomendado). from bson import ObjectId. Error común: buscar con string cuando es ObjectId (no encuentra).",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo ejecutas aggregation pipeline con PyMongo?",
        "option_a": "result = collection.aggregate([{'$match': {'edad': {'$gt': 18}}}, {'$group': {'_id': '$ciudad', 'total': {'$sum': 1}}}])",
        "option_b": "result = collection.aggregate({'$match': {'edad': {'$gt': 18}}})",
        "option_c": "result = collection.pipeline([{'$match': ...}])",
        "option_d": "result = collection.agg([...])",
        "option_e": "No se puede hacer aggregation en PyMongo",
        "correct_answer": "a",
        "explanation": "aggregate(pipeline) recibe lista de stages (dicts). Retorna cursor iterable. Sintaxis idéntica a mongo shell. Puedes pasar opciones: aggregate(pipeline, allowDiskUse=True). Para lista: list(collection.aggregate(...)).",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo ordenas y limitas resultados con PyMongo?",
        "option_a": "cursor = collection.find({'edad': {'$gt': 18}}).sort('nombre', 1).limit(10)",
        "option_b": "cursor = collection.find({'edad': {'$gt': 18}}).orderBy('nombre').limit(10)",
        "option_c": "cursor = collection.find({'edad': {'$gt': 18}}, sort='nombre', limit=10)",
        "option_d": "cursor = collection.find({'edad': {'$gt': 18}}).sort('nombre', 'asc').take(10)",
        "option_e": "Tanto a como c son correctas",
        "correct_answer": "a",
        "explanation": "Métodos de cursor: sort(campo, dirección), limit(n), skip(n). Dirección: 1 ascendente, -1 descendente o pymongo.ASCENDING, pymongo.DESCENDING. Chainable (fluent API). Orden importa: sort antes de limit para top-N. No ejecuta hasta iterar (lazy).",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples documentos con PyMongo?",
        "option_a": "result = collection.insert_many([{'nombre': 'Juan'}, {'nombre': 'Ana'}])",
        "option_b": "collection.insert_one([{'nombre': 'Juan'}, {'nombre': 'Ana'}])",
        "option_c": "for doc in docs:\n    collection.insert_one(doc)",
        "option_d": "Tanto a como c son correctas (a más eficiente)",
        "option_e": "Solo c es correcta",
        "correct_answer": "d",
        "explanation": "insert_many(lista_docs) inserta múltiples en UNA operación (más eficiente). Retorna InsertManyResult con inserted_ids (lista). Loop con insert_one funciona pero es N operaciones (más lento, más round-trips). insert_many atómico por default (ordered=True).",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es ordered en insert_many?",
        "option_a": "Ordena los documentos antes de insertar",
        "option_b": "Si True, detiene al primer error; si False, continúa insertando después de errores",
        "option_c": "Ordena por _id",
        "option_d": "Es un tipo de índice",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "insert_many(docs, ordered=True) default: inserta en orden, detiene al primer error. ordered=False: intenta insertar todos, continúa tras errores. False más eficiente (paralelizable). Útil cuando algunos docs pueden fallar (ej: duplicados) pero quieres insertar el resto.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo manejas excepciones en PyMongo?",
        "option_a": "from pymongo.errors import DuplicateKeyError\ntry:\n    collection.insert_one(doc)\nexcept DuplicateKeyError:\n    print('Duplicado')",
        "option_b": "try:\n    collection.insert_one(doc)\nexcept Exception as e:\n    if 'duplicate' in str(e):\n        print('Duplicado')",
        "option_c": "if collection.exists(doc):\n    print('Duplicado')\nelse:\n    collection.insert_one(doc)",
        "option_d": "Tanto a como b son correctas (a es mejor)",
        "option_e": "PyMongo no lanza excepciones",
        "correct_answer": "d",
        "explanation": "PyMongo lanza excepciones específicas: DuplicateKeyError, ConnectionFailure, OperationFailure, etc. Importa desde pymongo.errors. Mejor: catch específicas que Exception genérico. Jerarquía: PyMongoError (base) → OperationFailure, WriteError, etc.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un índice con PyMongo?",
        "option_a": "collection.create_index('email', unique=True)",
        "option_b": "collection.createIndex({'email': 1}, {unique: true})",
        "option_c": "collection.ensureIndex('email')",
        "option_d": "collection.add_index('email', unique=True)",
        "option_e": "No se pueden crear índices desde PyMongo",
        "correct_answer": "a",
        "explanation": "create_index(campo_o_lista, opciones). Campo: 'nombre' o [('nombre', 1), ('edad', -1)] para compuesto. Opciones: unique=True, sparse=True, background=True (deprecado 4.2+). Retorna nombre del índice. ensureIndex deprecado.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un índice compuesto con PyMongo?",
        "option_a": "collection.create_index([('apellido', 1), ('nombre', 1)])",
        "option_b": "collection.create_index('apellido', 'nombre')",
        "option_c": "collection.create_index({'apellido': 1, 'nombre': 1})",
        "option_d": "collection.create_compound_index(['apellido', 'nombre'])",
        "option_e": "No se pueden crear índices compuestos en PyMongo",
        "correct_answer": "a",
        "explanation": "Índice compuesto: lista de tuplas [(campo1, dir1), (campo2, dir2)]. Dirección: 1 o -1 o pymongo.ASCENDING/DESCENDING. Orden importa en compuestos. Para text index: [('campo', 'text')]. Para geoespacial: [('ubicacion', '2dsphere')].",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué son las bulk operations en PyMongo?",
        "option_a": "Operaciones grandes que usan mucha memoria",
        "option_b": "Mecanismo para ejecutar múltiples operaciones write en una sola llamada al servidor",
        "option_c": "Un tipo de transacción",
        "option_d": "Operaciones de backup",
        "option_e": "No existen en PyMongo",
        "correct_answer": "b",
        "explanation": "Bulk operations: batch múltiples writes (insert, update, delete) en UNA llamada. Reduce round-trips, mejora performance. Dos tipos: ordered (secuencial, para en error) y unordered (paralelo, continúa tras error). Usa bulk_write() o BulkOperationBuilder.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo usas bulk_write en PyMongo?",
        "option_a": "from pymongo import InsertOne, UpdateOne, DeleteOne\nresult = collection.bulk_write([InsertOne({'x': 1}), UpdateOne({'x': 1}, {'$set': {'x': 2}}), DeleteOne({'x': 2})])",
        "option_b": "bulk = collection.bulk()\nbulk.insert({'x': 1})\nbulk.update({'x': 1}, {'$set': {'x': 2}})\nbulk.execute()",
        "option_c": "collection.bulk_write([{'insert': {'x': 1}}, {'update': {...}}])",
        "option_d": "Tanto a como b son correctas",
        "option_e": "No existe bulk_write",
        "correct_answer": "a",
        "explanation": "bulk_write(operaciones) recibe lista de objetos: InsertOne, UpdateOne, UpdateMany, ReplaceOne, DeleteOne, DeleteMany. Retorna BulkWriteResult. Opción: ordered=True/False. Más explícito y type-safe que BulkOperationBuilder (deprecado).",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo usas projection en find() con PyMongo?",
        "option_a": "cursor = collection.find({'edad': {'$gt': 18}}, {'nombre': 1, 'edad': 1, '_id': 0})",
        "option_b": "cursor = collection.find({'edad': {'$gt': 18}}).project({'nombre': 1, 'edad': 1})",
        "option_c": "cursor = collection.find({'edad': {'$gt': 18}}, projection=['nombre', 'edad'])",
        "option_d": "Tanto a como b son correctas",
        "option_e": "Solo a es correcta",
        "correct_answer": "e",
        "explanation": "Projection es segundo parámetro de find(): find(filtro, projection). Dict: {campo: 1} incluir, {campo: 0} excluir. _id incluido por default (usa _id: 0 para excluir). También projection=dict. project() NO existe en cursor.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿MongoClient es thread-safe?",
        "option_a": "No, cada thread necesita su propio cliente",
        "option_b": "Sí, puedes compartir un MongoClient entre threads",
        "option_c": "Solo en Python 3",
        "option_d": "Solo con locks manuales",
        "option_e": "Depende del sistema operativo",
        "correct_answer": "b",
        "explanation": "MongoClient ES thread-safe. Un cliente con pool de conexiones puede compartirse entre threads. BEST PRACTICE: crea UN MongoClient al inicio, reúsalo. EVITA: crear cliente por request (costoso). Database y Collection objetos también thread-safe (obtienen conexiones del pool).",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo trabajas con fechas en PyMongo?",
        "option_a": "from datetime import datetime\ndoc = {'fecha': datetime.now()}\ncollection.insert_one(doc)",
        "option_b": "import time\ndoc = {'fecha': time.time()}\ncollection.insert_one(doc)",
        "option_c": "doc = {'fecha': '2024-01-15'}\ncollection.insert_one(doc)",
        "option_d": "Todas son correctas (a es recomendada)",
        "option_e": "PyMongo no soporta fechas",
        "correct_answer": "d",
        "explanation": "Usa datetime.datetime (Python) para tipo Date (BSON). PyMongo convierte automáticamente. SIEMPRE UTC (MongoDB almacena en UTC). Evita strings (pierdes operadores de fecha). time.time() funciona pero menos semántico. Queries: {'fecha': {'$gt': datetime(2024, 1, 1)}}.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo haces upsert con PyMongo?",
        "option_a": "collection.update_one({'email': 'juan@example.com'}, {'$set': {'nombre': 'Juan'}}, upsert=True)",
        "option_b": "collection.upsert({'email': 'juan@example.com'}, {'nombre': 'Juan'})",
        "option_c": "collection.insert_or_update({'email': 'juan@example.com'}, {'nombre': 'Juan'})",
        "option_d": "if not collection.find_one({'email': 'juan@example.com'}):\n    collection.insert_one({'email': 'juan@example.com', 'nombre': 'Juan'})",
        "option_e": "Tanto a como d son correctas (a es atómica)",
        "correct_answer": "e",
        "explanation": "upsert=True en update_one/update_many: actualiza si existe, inserta si no. ATÓMICO (opción d tiene race condition). UpdateResult.upserted_id contiene _id si insertó. Muy útil para idempotencia. DEBE usar operadores ($set) o setOnInsert.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es $setOnInsert en upsert?",
        "option_a": "Un error de sintaxis",
        "option_b": "Operador que solo aplica campos en INSERT (no en update) durante upsert",
        "option_c": "Un tipo de índice",
        "option_d": "Solo funciona en mongo shell",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$setOnInsert: campos que solo se setean en INSERT (no en update). Útil para timestamps createdAt: {'$set': {updatedAt: now}, '$setOnInsert': {createdAt: now}}. En update: updatedAt cambia. En insert: ambos se setean. Úsalo con upsert=True.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes estadísticas de una colección con PyMongo?",
        "option_a": "stats = db.command('collStats', 'nombre_coleccion')",
        "option_b": "stats = collection.stats()",
        "option_c": "stats = collection.get_stats()",
        "option_d": "stats = db.collection.command('stats')",
        "option_e": "Tanto a como b son correctas",
        "correct_answer": "a",
        "explanation": "db.command(comando, args) ejecuta comandos de DB. 'collStats': tamaño, count, índices. stats() NO es método de Collection. Otros comandos: 'dbStats', 'serverStatus', 'buildInfo'. Retorna dict con resultados.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo haces transacciones con PyMongo?",
        "option_a": "with client.start_session() as session:\n    with session.start_transaction():\n        collection.insert_one(doc1, session=session)\n        collection.update_one(filtro, update, session=session)",
        "option_b": "session = client.start_transaction()\ncollection.insert_one(doc1, session=session)\nsession.commit()",
        "option_c": "client.begin_transaction()\ncollection.insert_one(doc1)\nclient.commit()",
        "option_d": "No se pueden hacer transacciones en PyMongo",
        "option_e": "Transacciones son automáticas",
        "correct_answer": "a",
        "explanation": "Transacciones (MongoDB 4.0+ replica set, 4.2+ sharded): 1) start_session(), 2) start_transaction(), 3) operaciones con session=session, 4) commit automático (with) o manual. ROLLBACK automático en excepción. REQUIERE: replica set o sharded cluster.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué requieren las transacciones en MongoDB?",
        "option_a": "Nada especial, funcionan en cualquier instalación",
        "option_b": "Replica set (4.0+) o sharded cluster (4.2+)",
        "option_c": "Solo MongoDB Atlas",
        "option_d": "MongoDB Enterprise",
        "option_e": "No existen transacciones en MongoDB",
        "correct_answer": "b",
        "explanation": "Transacciones multi-documento requieren: replica set (4.0+) o sharded (4.2+). NO funcionan en standalone. Read/write concerns configurables. Snapshot isolation. ACID completo. Timeout por default: 60s. Para local dev: inicializa replica set de 1 nodo.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo usas watch() para change streams en PyMongo?",
        "option_a": "with collection.watch() as stream:\n    for change in stream:\n        print(change)",
        "option_b": "stream = collection.watch()\nfor change in stream:\n    print(change)",
        "option_c": "Ambas a y b son correctas",
        "option_d": "collection.on('change', callback)",
        "option_e": "No existe watch() en PyMongo",
        "correct_answer": "c",
        "explanation": "watch() retorna change stream (MongoDB 3.6+). Escucha cambios real-time: insert, update, delete, etc. Requiere replica set/sharded. Retorna ChangeStream iterable. Puede filtrar con pipeline: watch([{'$match': {}}]). Genera resume token para recovery.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo conviertes cursor a lista en PyMongo?",
        "option_a": "docs = list(collection.find(filtro))",
        "option_b": "docs = collection.find(filtro).toList()",
        "option_c": "docs = collection.find(filtro).to_array()",
        "option_d": "docs = collection.find(filtro).all()",
        "option_e": "Todas son correctas",
        "correct_answer": "a",
        "explanation": "list(cursor) convierte a lista Python (carga TODOS en memoria). CUIDADO con cursores grandes (puede consumir mucha RAM). Alternativa: itera con for (lazy, eficiente). to_array() existe en motor (async), NO en pymongo sync.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es motor?",
        "option_a": "El motor de MongoDB",
        "option_b": "Driver asíncrono de Python para MongoDB (usa asyncio)",
        "option_c": "Una versión antigua de PyMongo",
        "option_d": "Un ORM para MongoDB",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "motor: driver async para MongoDB (compatible con asyncio). Sintaxis similar a PyMongo pero métodos async: await collection.insert_one(). Ideal para: frameworks async (FastAPI, Sanic), alta concurrencia. API casi idéntica a PyMongo. pip install motor.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes nombres de todas las colecciones con PyMongo?",
        "option_a": "colecciones = db.list_collection_names()",
        "option_b": "colecciones = db.get_collections()",
        "option_c": "colecciones = db.collections()",
        "option_d": "colecciones = db.show_collections()",
        "option_e": "colecciones = list(db.collection_names())",
        "correct_answer": "a",
        "explanation": "list_collection_names() retorna lista de strings. También: list_collections() retorna info detallada (documentos). collection_names() deprecado. Para filtrar: list_collection_names(filter={}) con query.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo eliminas una colección con PyMongo?",
        "option_a": "collection.drop()",
        "option_b": "db.drop_collection('nombre_coleccion')",
        "option_c": "Ambas a y b son correctas",
        "option_d": "collection.delete()",
        "option_e": "db.remove_collection('nombre_coleccion')",
        "correct_answer": "c",
        "explanation": "drop() elimina colección completa: documentos + índices. collection.drop() o db.drop_collection(nombre). IRREVERSIBLE. Para eliminar DB completa: client.drop_database(nombre) o db.command('dropDatabase'). SIEMPRE verifica antes de drop en producción.",
        "difficulty": "easy"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es WriteConcern en PyMongo?",
        "option_a": "Un tipo de error",
        "option_b": "Nivel de confirmación requerido para operaciones write (w, j, wtimeout)",
        "option_c": "Un método de validación",
        "option_d": "Solo existe en replica sets",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "WriteConcern controla garantías de escritura: w (cantidad nodos), j (journal), wtimeout (timeout). from pymongo import WriteConcern. wc = WriteConcern(w='majority', j=True). Aplica a cliente, DB o colección. Mayor durabilidad = mayor latencia.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo configuras WriteConcern en PyMongo?",
        "option_a": "from pymongo import WriteConcern\nclient = MongoClient(w='majority', j=True)",
        "option_b": "wc = WriteConcern(w='majority')\ncollection = db.get_collection('nombre', write_concern=wc)",
        "option_c": "collection.insert_one(doc, w='majority', j=True)",
        "option_d": "Todas son correctas",
        "option_e": "Solo b es correcta",
        "correct_answer": "d",
        "explanation": "WriteConcern configurable en: 1) MongoClient (global), 2) Database, 3) Collection (con with_options o get_collection), 4) operación individual. Más específico sobreescribe general. w: 0, 1, 'majority', número. j: True/False.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es ReadPreference en PyMongo?",
        "option_a": "Preferencia de campos a leer",
        "option_b": "De qué nodo leer en replica set (primary, secondary, nearest, etc.)",
        "option_c": "Orden de lectura",
        "option_d": "Solo existe en sharded clusters",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "ReadPreference: de qué nodo leer. PRIMARY (default), SECONDARY, PRIMARY_PREFERRED, SECONDARY_PREFERRED, NEAREST. Útil para: scale reads, leer de nodo cercano, stale reads ok. from pymongo import ReadPreference. Configurable como WriteConcern.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo configuras timeout de conexión en PyMongo?",
        "option_a": "client = MongoClient('mongodb://localhost', serverSelectionTimeoutMS=5000, socketTimeoutMS=10000)",
        "option_b": "client = MongoClient('mongodb://localhost', timeout=5000)",
        "option_c": "client = MongoClient('mongodb://localhost', connectTimeout=5)",
        "option_d": "Todas son correctas",
        "option_e": "No se puede configurar timeout",
        "correct_answer": "a",
        "explanation": "Timeouts: serverSelectionTimeoutMS (elegir servidor), connectTimeoutMS (conexión TCP), socketTimeoutMS (operaciones), maxIdleTimeMS (pool). En ms. serverSelectionTimeoutMS default: 30000. socketTimeoutMS default: None (sin límite). IMPORTANTE para detectar problemas de red.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes explain de una query en PyMongo?",
        "option_a": "explain = collection.find(filtro).explain()",
        "option_b": "explain = collection.explain().find(filtro)",
        "option_c": "explain = db.command('explain', {'find': 'coleccion', 'filter': filtro})",
        "option_d": "Tanto a como c son correctas",
        "option_e": "No se puede hacer explain en PyMongo",
        "correct_answer": "d",
        "explanation": "cursor.explain() retorna plan de ejecución (como en shell). Útil para debugging performance. Modos: 'queryPlanner' (default), 'executionStats', 'allPlansExecution'. También db.command('explain', {...}). Analiza: índices usados, docs examinados, tiempo.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre PyMongo y MongoEngine?",
        "option_a": "No hay diferencia",
        "option_b": "PyMongo es driver bajo nivel, MongoEngine es ODM (Object-Document Mapper) con schemas",
        "option_c": "PyMongo es más rápido siempre",
        "option_d": "MongoEngine es el driver oficial",
        "option_e": "PyMongo no existe",
        "correct_answer": "b",
        "explanation": "PyMongo: driver oficial, bajo nivel, flexible, sin schemas. MongoEngine: ODM (como SQLAlchemy para SQL), define schemas (Document classes), validación, relaciones. PyMongo más control y performance, MongoEngine más conveniente para apps grandes con estructura. Elige según necesidad.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo trabajas con GridFS en PyMongo?",
        "option_a": "from gridfs import GridFS\nfs = GridFS(db)\nfile_id = fs.put(b'datos', filename='archivo.txt')",
        "option_b": "db.files.insert_one({'data': b'datos', 'filename': 'archivo.txt'})",
        "option_c": "collection.upload_file('archivo.txt', b'datos')",
        "option_d": "No existe GridFS en PyMongo",
        "option_e": "Solo a es correcta",
        "correct_answer": "e",
        "explanation": "GridFS: sistema archivos en MongoDB (>16MB). from gridfs import GridFS. fs.put(datos) sube, fs.get(file_id) descarga, fs.find_one() busca. Divide archivos en chunks (255KB). Usa colecciones fs.files y fs.chunks. Soporta metadata, streaming.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Para qué usarías GridFS?",
        "option_a": "Para cualquier archivo",
        "option_b": "Para archivos >16MB (límite de documento BSON) o cuando necesitas streaming",
        "option_c": "Para mejorar performance",
        "option_d": "Para archivos pequeños",
        "option_e": "No se debe usar GridFS",
        "correct_answer": "b",
        "explanation": "GridFS para: archivos >16MB, streaming (no cargar todo en RAM), versioning de archivos, metadata. EVITA para: archivos pequeños (<16MB, usa Binary o guarda en S3/filesystem), necesitas filesyste access directo. GridFS más lento que filesystem pero conveniente con MongoDB.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo trabajas con datos binarios en PyMongo?",
        "option_a": "from bson.binary import Binary\ndoc = {'archivo': Binary(b'datos')}\ncollection.insert_one(doc)",
        "option_b": "doc = {'archivo': b'datos'}\ncollection.insert_one(doc)",
        "option_c": "Ambas funcionan (a es explícita, b usa conversión automática)",
        "option_d": "No se pueden guardar binarios",
        "option_e": "Solo strings permitidos",
        "correct_answer": "c",
        "explanation": "bytes Python → Binary BSON automáticamente. Binary() explícito con subtypes (0-255). Para archivos grandes: GridFS. Para pequeños (<16MB): Binary o base64 string. Binary preserva tipo BSON correcto.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo usas find_one_and_update en PyMongo?",
        "option_a": "doc = collection.find_one_and_update({'_id': id}, {'$set': {'status': 'procesado'}}, return_document=ReturnDocument.AFTER)",
        "option_b": "doc = collection.update_and_return({'_id': id}, {'$set': {'status': 'procesado'}})",
        "option_c": "doc = collection.find_one({'_id': id})\ncollection.update_one({'_id': id}, {'$set': {'status': 'procesado'}})",
        "option_d": "Tanto a como c son correctas (a es atómica)",
        "option_e": "Solo c es correcta",
        "correct_answer": "d",
        "explanation": "find_one_and_update: ATÓMICO find + update. Retorna doc (antes o después según return_document). from pymongo import ReturnDocument. BEFORE (default) o AFTER. Útil para: obtener valor anterior, operaciones atómicas (contadores, queues). Opción c tiene race condition.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué métodos find_one_and_* existen en PyMongo?",
        "option_a": "Solo find_one_and_update",
        "option_b": "find_one_and_update, find_one_and_replace, find_one_and_delete",
        "option_c": "Solo find_one_and_delete",
        "option_d": "No existen estos métodos",
        "option_e": "Todos requieren transacciones",
        "correct_answer": "b",
        "explanation": "Tres métodos atómicos: find_one_and_update (actualiza), find_one_and_replace (reemplaza doc completo), find_one_and_delete (elimina). Todos retornan documento (antes/después). ATÓMICOS sin necesidad de transacción. Útiles para: queues, locks, contadores.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo parseas connection string en PyMongo?",
        "option_a": "client = MongoClient('mongodb://usuario:password@host:27017/database?authSource=admin')",
        "option_b": "client = MongoClient(host='host', username='usuario', password='password', authSource='admin')",
        "option_c": "Ambas a y b son correctas",
        "option_d": "Solo b es correcta",
        "option_e": "No se pueden usar connection strings",
        "correct_answer": "c",
        "explanation": "Connection string (URI) o parámetros separados. URI: 'mongodb://[usuario:password@]host[:puerto][/database][?opciones]'. Para Atlas: 'mongodb+srv://...'. Opciones en URI: ?authSource=admin&retryWrites=true. También: MongoClient(uri, **opciones).",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es el connection pool en PyMongo?",
        "option_a": "Una lista de bases de datos",
        "option_b": "Pool de conexiones TCP reutilizables al servidor MongoDB",
        "option_c": "Un tipo de índice",
        "option_d": "Solo existe en enterprise",
        "option_e": "No existe pool",
        "correct_answer": "b",
        "explanation": "MongoClient mantiene pool de conexiones (default: 100 max). Conexiones se reutilizan entre requests (eficiente). Configura con: maxPoolSize, minPoolSize, maxIdleTimeMS. Pool por servidor en replica set. Thread-safe: threads comparten pool.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo configuras el tamaño del pool de conexiones?",
        "option_a": "client = MongoClient('mongodb://localhost', maxPoolSize=50, minPoolSize=10)",
        "option_b": "client = MongoClient('mongodb://localhost?maxPoolSize=50&minPoolSize=10')",
        "option_c": "Ambas a y b son correctas",
        "option_d": "client = MongoClient('mongodb://localhost', poolSize=50)",
        "option_e": "No se puede configurar",
        "correct_answer": "c",
        "explanation": "maxPoolSize en parámetro o URI. Default: 100. minPoolSize (default: 0) mantiene conexiones abiertas. maxIdleTimeMS cierra idle connections. Ajusta según: concurrencia app, recursos servidor. Monitorea con: client.server_info(), event listeners.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el mejor patrón para usar PyMongo en una aplicación web?",
        "option_a": "Crear MongoClient en cada request",
        "option_b": "Crear UN MongoClient al inicio, reutilizarlo (con pool de conexiones)",
        "option_c": "Crear MongoClient por thread",
        "option_d": "Usar globals() para guardar cliente",
        "option_e": "No importa",
        "correct_answer": "b",
        "explanation": "BEST PRACTICE: UN MongoClient global, reúsalo. MongoClient thread-safe, pool interno. EVITA: cliente por request (costoso). Patrón: inicializa en app startup, cierra en shutdown. En Flask: app.config, FastAPI: Depends + Singleton. Para testing: fixture con cliente temporal.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo manejas decimales precisos (dinero) en PyMongo?",
        "option_a": "from decimal import Decimal\nfrom bson.decimal128 import Decimal128\ndoc = {'precio': Decimal128(Decimal('19.99'))}\ncollection.insert_one(doc)",
        "option_b": "doc = {'precio': 19.99}\ncollection.insert_one(doc)",
        "option_c": "doc = {'precio': int(1999)}  # centavos\ncollection.insert_one(doc)",
        "option_d": "Todas funcionan (a es más precisa)",
        "option_e": "No se pueden guardar decimales",
        "correct_answer": "d",
        "explanation": "Para dinero/precisión: Decimal128 (BSON decimal, 34 dígitos precisión). float Python tiene imprecisión (0.1+0.2≠0.3). Alternativa: int centavos (preciso, más simple). Decimal Python → Decimal128. Para reads: Decimal128 → Decimal. Configura codec_options para conversión auto.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "Aplicación completa: inserta vuelo en infovuelos_limpio con PyMongo",
        "option_a": "from pymongo import MongoClient\nfrom datetime import datetime\nclient = MongoClient()\ndb = client['mi_base']\ncol = db['infovuelos_limpio']\nvuelo = {'Origen': 'MAD', 'Destino': 'BCN', 'NumEscalas': 0, 'Fecha': datetime.now()}\nresult = col.insert_one(vuelo)\nprint(f'Insertado: {result.inserted_id}')",
        "option_b": "client = MongoClient('localhost')\nvuelo = {'Origen': 'MAD', 'Destino': 'BCN'}\nclient.insert(vuelo)",
        "option_c": "db = MongoClient().database\nvuelo = {'Origen': 'MAD'}\ndb.infovuelos_limpio.add(vuelo)",
        "option_d": "Solo a es correcta y completa",
        "option_e": "Todas son correctas",
        "correct_answer": "d",
        "explanation": "Patrón completo: 1) import MongoClient, 2) conectar, 3) acceder DB y colección, 4) crear documento (dict), 5) insert_one, 6) verificar resultado. Usa datetime para fechas. Maneja excepciones en producción. Cierra cliente en shutdown (client.close()).",
        "difficulty": "hard",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Cuándo deberías cerrar el MongoClient?",
        "option_a": "Después de cada operación",
        "option_b": "Al shutdown de la aplicación (no en cada request)",
        "option_c": "Nunca, se cierra automáticamente",
        "option_d": "Cada hora",
        "option_e": "Depende del sistema operativo",
        "correct_answer": "b",
        "explanation": "MongoClient: cierra al final de app (shutdown). NO cierres entre requests (pierdes pool). Python context manager: with MongoClient() para scripts cortos. Web apps: cierra en app shutdown. Cliente mantiene conexiones abiertas (eficiente). Garbage collector cierra eventually pero mejor explícito.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo haces una query con regex en PyMongo?",
        "option_a": "import re\ncollection.find({'nombre': re.compile('^Juan', re.IGNORECASE)})",
        "option_b": "collection.find({'nombre': {'$regex': '^Juan', '$options': 'i'}})",
        "option_c": "collection.find({'nombre': /^Juan/i})",
        "option_d": "Tanto a como b son correctas",
        "option_e": "Solo b es correcta",
        "correct_answer": "d",
        "explanation": "Dos formas: 1) Python re.compile() para regex, 2) operador $regex con $options. Opciones: 'i' (case insensitive), 'm' (multiline), 's' (dotall), 'x' (verbose). re.compile más Pythonic, $regex más portable (mismo código JS). Ambas generan mismo BSON.",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo implementas paginación eficiente con PyMongo?",
        "option_a": "# Página 1\ncursor = collection.find().sort('_id', 1).limit(20)\n# Página 2 (guarda last_id de página 1)\ncursor = collection.find({'_id': {'$gt': last_id}}).sort('_id', 1).limit(20)",
        "option_b": "page = 2\npage_size = 20\ncursor = collection.find().skip((page-1)*page_size).limit(page_size)",
        "option_c": "Ambas funcionan (a es más eficiente para páginas avanzadas)",
        "option_d": "collection.paginate(page=2, size=20)",
        "option_e": "No se puede hacer paginación en PyMongo",
        "correct_answer": "c",
        "explanation": "skip() funciona pero es LENTO para páginas grandes (debe escanear docs anteriores). MEJOR: range queries con último _id visto ({_id: {$gt: last_id}}). Requiere índice en campo ordenado. skip() ok para pocas páginas. Para millones de docs: solo range queries.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "conceptual",
        "question_text": "¿Qué es codec_options en PyMongo?",
        "option_a": "Opciones de compresión",
        "option_b": "Configuración para serialización/deserialización BSON (ej: cómo manejar UUID, Decimal)",
        "option_c": "Opciones de encoding de texto",
        "option_d": "Un tipo de índice",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "codec_options: controla conversión Python ↔ BSON. from bson.codec_options import CodecOptions. Configura: tz_aware (timezone), uuid_representation, type_registry (custom codecs). Útil para: Decimal128 auto-conversion, UUID formats, custom types. Aplica a DB/Collection.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo configuras timezone-aware datetimes en PyMongo?",
        "option_a": "from bson.codec_options import CodecOptions\nimport pytz\nopts = CodecOptions(tz_aware=True, tzinfo=pytz.UTC)\ncollection_tz = db.get_collection('nombre', codec_options=opts)",
        "option_b": "client = MongoClient(tz_aware=True)",
        "option_c": "collection.find({}, timezone='UTC')",
        "option_d": "Todas son correctas",
        "option_e": "No se pueden usar timezones",
        "correct_answer": "a",
        "explanation": "tz_aware=True hace que PyMongo retorne datetime.datetime con tzinfo. Default: naive datetimes UTC. SIEMPRE especifica tzinfo explícito (pytz.UTC, timezone.utc). MongoDB almacena en UTC. Para conversión a local: usa timezone en tu app.",
        "difficulty": "hard"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo implementas retry logic para operaciones en PyMongo?",
        "option_a": "from pymongo.errors import AutoReconnect\nmax_retries = 3\nfor attempt in range(max_retries):\n    try:\n        result = collection.insert_one(doc)\n        break\n    except AutoReconnect:\n        if attempt == max_retries - 1:\n            raise\n        time.sleep(2**attempt)",
        "option_b": "client = MongoClient(retryWrites=True, retryReads=True)",
        "option_c": "Ambas: b para retries automáticos, a para lógica custom",
        "option_d": "collection.insert_one(doc, retry=True)",
        "option_e": "PyMongo hace retry automáticamente siempre",
        "correct_answer": "c",
        "explanation": "MongoDB 3.6+: retryWrites=True (default desde PyMongo 3.6), retryReads=True (4.2+) para retries automáticos de writes/reads idempotentes. Para lógica custom (ej: exponential backoff), catch AutoReconnect/NetworkTimeout. Retries automáticos transparentes, custom para casos especiales.",
        "difficulty": "hard"
    }
]

# Total Batch 8: 60 preguntas ✅
# Categoría 7 (MongoDB + Python): 60 preguntas ✅
# Total acumulado: 432 preguntas de 520

# ============================================================================
# BATCH 9: CATEGORÍA 8 - OTRAS FUNCIONALIDADES (40 preguntas)
# ============================================================================

QUESTIONS_BATCH_9 = [
    # ==================== CATEGORÍA 8: OTRAS FUNCIONALIDADES ====================

    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es un índice de texto (text index)?",
        "option_a": "Un índice para strings",
        "option_b": "Índice especializado para búsquedas full-text en campos de texto",
        "option_c": "Un índice alfabético",
        "option_d": "Solo funciona en inglés",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Text index: búsquedas full-text con stemming, stop words, idiomas (50+ soportados). Sintaxis: createIndex({campo: 'text'}). Soporta búsquedas por relevancia, frases, exclusión. Más potente que regex para búsquedas de texto. Solo UN text index por colección (pero puede ser compuesto).",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un índice de texto en el campo 'descripcion'?",
        "option_a": "db.collection.createIndex({descripcion: 'text'})",
        "option_b": "db.collection.createIndex({descripcion: 1}, {type: 'text'})",
        "option_c": "db.collection.createTextIndex('descripcion')",
        "option_d": "db.collection.createIndex({descripcion: 'fulltext'})",
        "option_e": "No se pueden crear índices de texto",
        "correct_answer": "a",
        "explanation": "createIndex({campo: 'text'}) para text index. Para múltiples campos: {campo1: 'text', campo2: 'text'}. Wildcard text index: {'$**': 'text'} indexa TODOS los strings. Opciones: default_language, weights (importancia relativa).",
        "difficulty": "easy"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas con un índice de texto?",
        "option_a": "db.collection.find({$text: {$search: 'MongoDB database'}})",
        "option_b": "db.collection.textSearch('MongoDB database')",
        "option_c": "db.collection.find({descripcion: {$text: 'MongoDB'}})",
        "option_d": "db.collection.search('MongoDB database')",
        "option_e": "No se puede buscar con text index",
        "correct_answer": "a",
        "explanation": "$text: {$search: 'términos'} busca en text index. Busca ANY palabra por default. Para frase exacta: \"frase entre comillas\". Para excluir: -palabra. Score de relevancia: {$meta: 'textScore'}. Proyección y sort por score disponibles.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas una frase exacta con text search?",
        "option_a": "db.collection.find({$text: {$search: '\"base de datos\"'}})",
        "option_b": "db.collection.find({$text: {$search: 'base de datos', exact: true}})",
        "option_c": "db.collection.find({$text: {$search: '[base de datos]'}})",
        "option_d": "db.collection.find({$text: {$phrase: 'base de datos'}})",
        "option_e": "No se pueden buscar frases exactas",
        "correct_answer": "a",
        "explanation": "Comillas DENTRO del string de búsqueda: '\"frase exacta\"'. Sin comillas: busca ANY palabra. También: -palabra para excluir. Para ordenar por relevancia: .sort({score: {$meta: 'textScore'}}).",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es un índice geoespacial?",
        "option_a": "Un índice para coordenadas GPS",
        "option_b": "Índice especializado para queries de ubicación (2d plano, 2dsphere esférico)",
        "option_c": "Solo para mapas",
        "option_d": "Un tipo de índice de texto",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Índices geoespaciales para queries de proximidad: 2d (plano cartesiano), 2dsphere (esfera, usa GeoJSON). Soporta: $near (cercanos), $geoWithin (dentro de área), $geoIntersects. Útil para: apps de ubicación, delivery, mapas. Formato GeoJSON: {type: 'Point', coordinates: [lng, lat]}.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un índice 2dsphere?",
        "option_a": "db.collection.createIndex({ubicacion: '2dsphere'})",
        "option_b": "db.collection.createIndex({ubicacion: 'geo'})",
        "option_c": "db.collection.createGeoIndex('ubicacion')",
        "option_d": "db.collection.createIndex({ubicacion: 1}, {type: '2dsphere'})",
        "option_e": "No existen índices geoespaciales",
        "correct_answer": "a",
        "explanation": "createIndex({campo: '2dsphere'}) para geometrías GeoJSON en esfera. '2d' para coordenadas planas [x,y]. 2dsphere más común (Earth). Soporta: Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection.",
        "difficulty": "easy"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo almacenas coordenadas en formato GeoJSON?",
        "option_a": "{\n  nombre: 'Restaurante',\n  ubicacion: {\n    type: 'Point',\n    coordinates: [-73.856077, 40.848447]  // [longitud, latitud]\n  }\n}",
        "option_b": "{\n  nombre: 'Restaurante',\n  ubicacion: {\n    lat: 40.848447,\n    lng: -73.856077\n  }\n}",
        "option_c": "{\n  nombre: 'Restaurante',\n  ubicacion: [40.848447, -73.856077]\n}",
        "option_d": "Todas son correctas",
        "option_e": "Solo b es correcta",
        "correct_answer": "a",
        "explanation": "GeoJSON: {type: 'Point', coordinates: [lng, lat]}. ORDEN: longitud primero, latitud segundo. type: 'Point', 'LineString', 'Polygon'. Legacy format [lng, lat] funciona con 2d pero no con 2dsphere. SIEMPRE usa GeoJSON para 2dsphere.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras documentos cerca de una ubicación?",
        "option_a": "db.lugares.find({\n  ubicacion: {\n    $near: {\n      $geometry: {type: 'Point', coordinates: [-73.9, 40.7]},\n      $maxDistance: 1000  // metros\n    }\n  }\n})",
        "option_b": "db.lugares.findNear([-73.9, 40.7], 1000)",
        "option_c": "db.lugares.find({ubicacion: {$distance: {point: [-73.9, 40.7], max: 1000}}})",
        "option_d": "db.lugares.near({lng: -73.9, lat: 40.7, radius: 1000})",
        "option_e": "No se pueden hacer queries de proximidad",
        "correct_answer": "a",
        "explanation": "$near: encuentra cercanos, ordenados por distancia. Requiere índice geoespacial. $maxDistance en metros (2dsphere) o unidades (2d). $minDistance también disponible. $nearSphere para esférico sin índice (más lento). Retorna más cercanos primero.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es schema validation en MongoDB?",
        "option_a": "MongoDB no soporta validación",
        "option_b": "Reglas para validar estructura y tipos de documentos al insert/update",
        "option_c": "Solo valida tipos de datos",
        "option_d": "Solo en MongoDB Enterprise",
        "option_e": "Requiere un schema fijo",
        "correct_answer": "b",
        "explanation": "Schema validation (3.2+): reglas JSON Schema para validar docs. Configura al crear colección o con collMod. Validación: error (rechaza), warn (acepta + log). Útil para: data quality, enforce structure. NO es schema fijo (opcional). validationLevel: strict/moderate.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas una colección con validación de esquema?",
        "option_a": "db.createCollection('usuarios', {\n  validator: {\n    $jsonSchema: {\n      required: ['nombre', 'email'],\n      properties: {\n        nombre: {bsonType: 'string'},\n        email: {bsonType: 'string', pattern: '^.+@.+$'},\n        edad: {bsonType: 'int', minimum: 0}\n      }\n    }\n  }\n})",
        "option_b": "db.createCollection('usuarios', {\n  schema: {\n    nombre: String,\n    email: String,\n    edad: Number\n  }\n})",
        "option_c": "db.usuarios.validate({nombre: 'string', email: 'string'})",
        "option_d": "MongoDB no soporta validación",
        "option_e": "Solo a través de aplicación",
        "correct_answer": "a",
        "explanation": "createCollection con validator: {$jsonSchema: ...}. $jsonSchema soporta: required, properties, bsonType, pattern (regex), minimum/maximum, enum, etc. También: $expr para validaciones complejas. Para modificar: collMod. validationAction: 'error' (default) o 'warn'.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es una capped collection?",
        "option_a": "Una colección con límite de documentos",
        "option_b": "Colección de tamaño fijo con inserción FIFO (first-in-first-out), sobrescribe viejos",
        "option_c": "Una colección bloqueada",
        "option_d": "Solo para logs",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Capped collection: tamaño máximo fijo (bytes). Cuando llena, sobrescribe docs más viejos (FIFO). Inserciones mantienen orden natural. NO se puede: delete, update que cambie tamaño. Útil para: logs, cache, historial reciente. Alta performance (sin fragmentación).",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas una capped collection?",
        "option_a": "db.createCollection('logs', {capped: true, size: 10485760, max: 5000})",
        "option_b": "db.createCappedCollection('logs', 10485760)",
        "option_c": "db.logs.cap({size: 10485760})",
        "option_d": "db.createCollection('logs', {type: 'capped', limit: 5000})",
        "option_e": "No se pueden crear capped collections",
        "correct_answer": "a",
        "explanation": "createCollection con capped: true, size (bytes, obligatorio), max (docs, opcional). size se redondea a múltiplo de 256. max limita cantidad docs (si size permite). Para convertir existente: convertToCapped. NO se puede descapped.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es collation en MongoDB?",
        "option_a": "Un tipo de índice",
        "option_b": "Reglas de comparación de strings (case-insensitive, acentos, orden alfabético por idioma)",
        "option_c": "Unión de colecciones",
        "option_d": "Un método de agregación",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Collation (3.4+): reglas para comparar strings. Idioma-específico: español ordena ch/ll diferente. Case/accent insensitive: {locale: 'es', strength: 1}. Configura: colección (default), índice, operación. Útil para búsquedas/ordenamiento natural por idioma.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo haces una query case-insensitive con collation?",
        "option_a": "db.collection.find({nombre: 'juan'}).collation({locale: 'es', strength: 2})",
        "option_b": "db.collection.find({nombre: {$regex: /^juan$/i}})",
        "option_c": "Ambas funcionan (a usa collation, b usa regex)",
        "option_d": "db.collection.find({nombre: 'juan'}, {caseInsensitive: true})",
        "option_e": "No se puede hacer case-insensitive",
        "correct_answer": "c",
        "explanation": "Collation strength: 1 (base, ignora case/accent), 2 (ignora case), 3 (default). find().collation({locale, strength}). Regex también funciona. Collation usa índice si índice tiene misma collation. Para colección: createCollection con collation default.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es una view en MongoDB?",
        "option_a": "Una forma de ver datos",
        "option_b": "Vista read-only basada en aggregation pipeline, actualiza automáticamente",
        "option_c": "Una copia de colección",
        "option_d": "Solo en MongoDB Enterprise",
        "option_e": "No existen views",
        "correct_answer": "b",
        "explanation": "Views (3.4+): colección virtual read-only basada en pipeline. NO almacena datos, ejecuta pipeline on-the-fly. Útil para: ocultar campos sensibles, simplificar queries complejos, diferentes vistas de mismos datos. No soporta: write, índices propios.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas una view?",
        "option_a": "db.createView('vistaUsuarios', 'usuarios', [{$project: {password: 0}}, {$match: {activo: true}}])",
        "option_b": "db.createCollection('vistaUsuarios', {viewOn: 'usuarios', pipeline: [{$project: {password: 0}}]})",
        "option_c": "Ambas a y b son correctas",
        "option_d": "db.usuarios.createView('vistaUsuarios', {exclude: ['password']})",
        "option_e": "No se pueden crear views",
        "correct_answer": "c",
        "explanation": "createView(nombre, sourceCollection, pipeline) o createCollection con viewOn. Pipeline: array de stages. Query en view ejecuta pipeline + query adicional. Views pueden basarse en otras views (máximo 100 niveles). Modifica con: collMod.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es un índice partial?",
        "option_a": "Un índice incompleto",
        "option_b": "Índice que solo indexa documentos que cumplen filtro específico (ahorra espacio)",
        "option_c": "Un índice temporal",
        "option_d": "Solo para campos parciales",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Partial index (3.2+): indexa subset de docs con partialFilterExpression. Ahorra espacio y mejora write performance. Útil para: indexar solo activos, no-null, cierto rango. Query DEBE incluir filtro compatible para usar índice. Similar a índice + WHERE en SQL.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un índice partial que solo indexa usuarios activos?",
        "option_a": "db.usuarios.createIndex({email: 1}, {partialFilterExpression: {activo: true}})",
        "option_b": "db.usuarios.createIndex({email: 1}, {filter: {activo: true}})",
        "option_c": "db.usuarios.createIndex({email: 1, activo: true})",
        "option_d": "db.usuarios.createPartialIndex({email: 1}, {where: {activo: true}})",
        "option_e": "No se pueden crear índices parciales",
        "correct_answer": "a",
        "explanation": "createIndex con partialFilterExpression: filtro query-like. Índice solo incluye docs que cumplen filtro. Query DEBE incluir filtro compatible: {activo: true, email: '...'} usa índice, {email: '...'} no. Soporta: $eq, $gt, $gte, $lt, $lte, $exists, $type, $and, $or.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es un índice sparse?",
        "option_a": "Un índice con pocos elementos",
        "option_b": "Índice que solo incluye documentos donde el campo indexado existe y no es null",
        "option_c": "Un índice optimizado",
        "option_d": "Un tipo de índice de texto",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Sparse index: excluye docs sin campo o con null. Ahorra espacio cuando muchos docs no tienen campo. Útil para campos opcionales. CUIDADO: queries sin campo no usan índice. Diferencia con partial: sparse solo para exists/null, partial para cualquier condición.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un índice sparse?",
        "option_a": "db.collection.createIndex({campoOpcional: 1}, {sparse: true})",
        "option_b": "db.collection.createIndex({campoOpcional: 1}, {type: 'sparse'})",
        "option_c": "db.collection.createSparseIndex('campoOpcional')",
        "option_d": "db.collection.createIndex({campoOpcional: 1}, {skipNull: true})",
        "option_e": "No existen índices sparse",
        "correct_answer": "a",
        "explanation": "createIndex con sparse: true. Índice no incluye docs donde campo missing o null. Combina con unique: permite múltiples docs sin campo (unique solo aplica a docs EN índice). Para más control, usa partial index.",
        "difficulty": "easy"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es un wildcard index?",
        "option_a": "Un índice para búsquedas con *",
        "option_b": "Índice que indexa todos los campos o subfields dinámicos (útil para schemas variables)",
        "option_c": "Un índice de texto",
        "option_d": "Solo para arrays",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Wildcard index (4.2+): indexa todos campos o patrón: {'$**': 1} todo, {'campo.$**': 1} subcampos. Útil para: schemas flexibles, campos dinámicos, queries ad-hoc. CUIDADO: más espacio, puede ser ineficiente. Excluye campos con wildcardProjection.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas un wildcard index?",
        "option_a": "db.collection.createIndex({'$**': 1})",
        "option_b": "db.collection.createIndex({'*': 1})",
        "option_c": "db.collection.createWildcardIndex()",
        "option_d": "db.collection.createIndex({}, {wildcard: true})",
        "option_e": "No existen wildcard indexes",
        "correct_answer": "a",
        "explanation": "{'$**': 1} indexa TODOS los campos (excepto _id). Para subcampos: {'campo.$**': 1}. Excluir: {wildcardProjection: {campo: 0}}. NO soporta: unique, compuesto con otros campos. Útil pero costoso en espacio/writes.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es un hidden index?",
        "option_a": "Un índice secreto",
        "option_b": "Índice que existe pero query planner no lo usa (útil para testing antes de drop)",
        "option_c": "Un índice invisible al usuario",
        "option_d": "Solo en MongoDB Enterprise",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Hidden index (4.4+): índice mantenido pero no usado por planner. Útil para: test impacto de remover índice sin dropearlo. Puedes unhide. Sigue consumiendo espacio y slowing writes. Para temporary disable sin rebuild.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo escondes un índice existente?",
        "option_a": "db.collection.hideIndex('nombreIndice')",
        "option_b": "db.collection.updateIndex('nombreIndice', {hidden: true})",
        "option_c": "db.runCommand({collMod: 'collection', index: {keyPattern: {campo: 1}, hidden: true}})",
        "option_d": "Tanto a como c son correctas",
        "option_e": "No se pueden esconder índices",
        "correct_answer": "d",
        "explanation": "hideIndex(nombre) o collMod con hidden: true. Para unhide: unhideIndex() o hidden: false. _id index NO se puede hide. Índice hidden sigue actualizándose en writes. Para ver: getIndexes() muestra hidden: true.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué son las time series collections?",
        "option_a": "Colecciones que expiran",
        "option_b": "Colecciones optimizadas para datos time-stamped (IoT, métricas, logs)",
        "option_c": "Colecciones ordenadas por tiempo",
        "option_d": "Solo en MongoDB Atlas",
        "option_e": "No existen",
        "correct_answer": "b",
        "explanation": "Time series (5.0+): optimizadas para series temporales (IoT, stocks, métricas). Mejor compresión, queries rápidos por tiempo. Requiere: timeField, metaField (opcional). Auto-crea buckets. Soporta: secondary indexes, TTL. Más eficiente que colección normal.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo creas una time series collection?",
        "option_a": "db.createCollection('sensores', {\n  timeseries: {\n    timeField: 'timestamp',\n    metaField: 'sensorId',\n    granularity: 'seconds'\n  }\n})",
        "option_b": "db.createCollection('sensores', {type: 'timeseries', timeField: 'timestamp'})",
        "option_c": "db.createTimeSeriesCollection('sensores', {timeField: 'timestamp'})",
        "option_d": "Todas son correctas",
        "option_e": "No se pueden crear time series collections",
        "correct_answer": "a",
        "explanation": "createCollection con timeseries: {timeField, metaField, granularity}. timeField: Date obligatorio. metaField: agrupa mediciones relacionadas. granularity: 'seconds', 'minutes', 'hours' (optimización). expireAfterSeconds para TTL. NO se puede convertir normal a timeseries.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es $geoWithin?",
        "option_a": "Operador para texto",
        "option_b": "Operador geoespacial que encuentra documentos dentro de un área (polígono, círculo, etc.)",
        "option_c": "Operador de array",
        "option_d": "Solo funciona con 2d",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$geoWithin: encuentra docs dentro de geometría. Soporta: $geometry (GeoJSON Polygon), $centerSphere (círculo en esfera), $box, $polygon. NO ordena por distancia (usa $near para eso). No requiere índice (pero más rápido con índice).",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras lugares dentro de un polígono?",
        "option_a": "db.lugares.find({\n  ubicacion: {\n    $geoWithin: {\n      $geometry: {\n        type: 'Polygon',\n        coordinates: [[[lng1,lat1], [lng2,lat2], [lng3,lat3], [lng1,lat1]]]\n      }\n    }\n  }\n})",
        "option_b": "db.lugares.findWithinPolygon([[lng1,lat1], [lng2,lat2], [lng3,lat3]])",
        "option_c": "db.lugares.find({ubicacion: {$inside: {polygon: [...]}}})",
        "option_d": "db.lugares.geoQuery({polygon: [...]})",
        "option_e": "No se puede",
        "correct_answer": "a",
        "explanation": "$geoWithin con $geometry: {type: 'Polygon', coordinates: [[[puntos]]]}. Polígono: array de arrays (puede tener holes). IMPORTANTE: primer y último punto deben ser iguales (cerrar polígono). Para círculo: $centerSphere: [[lng,lat], radiusRadians].",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es $geoIntersects?",
        "option_a": "Operador de intersección de arrays",
        "option_b": "Encuentra geometrías que intersectan con geometría especificada",
        "option_c": "Solo para polígonos",
        "option_d": "Igual que $geoWithin",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$geoIntersects: encuentra geometrías que intersectan (tocan, cruzan) con geometría dada. Requiere 2dsphere. Útil para: encontrar rutas que cruzan área, límites que tocan. Diferencia con $geoWithin: intersects incluye límites, within solo interior.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo calculas distancia en una query geoespacial?",
        "option_a": "db.lugares.aggregate([{\n  $geoNear: {\n    near: {type: 'Point', coordinates: [-73.9, 40.7]},\n    distanceField: 'distancia',\n    maxDistance: 5000,\n    spherical: true\n  }\n}])",
        "option_b": "db.lugares.find({ubicacion: {$near: ...}}).calculateDistance()",
        "option_c": "db.lugares.distance({from: [-73.9, 40.7]})",
        "option_d": "No se puede calcular distancia",
        "option_e": "Solo a es correcta",
        "correct_answer": "e",
        "explanation": "$geoNear stage en aggregation: calcula distancia, la añade en distanceField. spherical: true para 2dsphere. DEBE ser primer stage. Incluye: near, distanceField, query (filtro adicional), includeLocs (ubicación). Retorna ordenado por distancia.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué operadores de array existen además de $push?",
        "option_a": "Solo $push",
        "option_b": "$push, $addToSet, $pop, $pull, $pullAll",
        "option_c": "$push y $pop solamente",
        "option_d": "Solo en aggregation",
        "option_e": "No hay operadores de array",
        "correct_answer": "b",
        "explanation": "$push: agrega elemento. $addToSet: agrega si no existe (evita duplicados). $pop: remueve primero (1) o último (-1). $pull: remueve elementos que cumplen condición. $pullAll: remueve valores específicos. También: $each, $position, $slice, $sort con $push.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo agregas múltiples elementos a un array?",
        "option_a": "collection.updateOne({_id: id}, {$push: {tags: {$each: ['nuevo1', 'nuevo2', 'nuevo3']}}})",
        "option_b": "collection.updateOne({_id: id}, {$push: {tags: ['nuevo1', 'nuevo2', 'nuevo3']}})",
        "option_c": "collection.updateOne({_id: id}, {$pushAll: {tags: ['nuevo1', 'nuevo2', 'nuevo3']}})",
        "option_d": "Tanto a como c son correctas",
        "option_e": "Solo b es correcta",
        "correct_answer": "a",
        "explanation": "$push con $each: agrega múltiples elementos. $pushAll deprecado. También con $each: $position (índice inserción), $slice (limita tamaño), $sort (ordena array). Ejemplo: {$push: {scores: {$each: [90,85], $sort: -1, $slice: 5}}} mantiene top 5.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo remueves elementos de array que cumplen condición?",
        "option_a": "collection.updateOne({_id: id}, {$pull: {scores: {$lt: 50}}})",
        "option_b": "collection.updateOne({_id: id}, {$remove: {scores: {$lt: 50}}})",
        "option_c": "collection.updateOne({_id: id}, {$filter: {scores: {$gte: 50}}})",
        "option_d": "collection.updateOne({_id: id}, {$unset: {scores: {$lt: 50}}})",
        "option_e": "No se puede",
        "correct_answer": "a",
        "explanation": "$pull: remueve TODOS los elementos que cumplen condición. Para valor específico: {$pull: {tags: 'viejo'}}. Para objetos en array: {$pull: {items: {qty: {$lt: 0}}}}. $pullAll remueve valores específicos: {$pullAll: {tags: ['a', 'b']}}.",
        "difficulty": "medium"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es el operador positional $ en updates?",
        "option_a": "Un símbolo especial",
        "option_b": "Operador que referencia el índice del primer elemento del array que matcheó en query",
        "option_c": "Solo para aggregation",
        "option_d": "Un operador de suma",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$ positional: actualiza primer elemento de array que matcheó query. Ejemplo: find({items.id: 5}) update {$set: {'items.$.qty': 10}}. SOLO primer match. Para todos: $[] (all positional). Para algunos: $[identifier] con arrayFilters.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas un elemento específico de array?",
        "option_a": "collection.updateOne(\n  {'items.id': 5},\n  {$set: {'items.$.qty': 10}}\n)",
        "option_b": "collection.updateOne(\n  {_id: id},\n  {$set: {'items[0].qty': 10}}\n)",
        "option_c": "collection.updateOne(\n  {_id: id},\n  {$set: {'items.qty': 10}},\n  {arrayFilters: [{'item.id': 5}]}\n)",
        "option_d": "Todas funcionan en diferentes contextos",
        "option_e": "Solo a es correcta",
        "correct_answer": "d",
        "explanation": "$ positional: primer match de query. Índice directo items.0: posición específica. arrayFilters con $[]: actualiza elementos que cumplen condición. arrayFilters más potente (múltiples elementos, condiciones complejas). Opción d correcta: diferentes casos de uso.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas TODOS los elementos de un array?",
        "option_a": "collection.updateOne(\n  {_id: id},\n  {$inc: {'items.$[].qty': 1}}\n)",
        "option_b": "collection.updateOne(\n  {_id: id},\n  {$inc: {'items.*.qty': 1}}\n)",
        "option_c": "collection.updateMany(\n  {_id: id},\n  {$inc: {'items.qty': 1}}\n)",
        "option_d": "No se puede actualizar todos",
        "option_e": "Solo a es correcta",
        "correct_answer": "e",
        "explanation": "$[] all positional (3.6+): actualiza TODOS los elementos del array. Sin condición. Para subset con condición: $[identifier] + arrayFilters: [{'elem.field': condición}]. Muy potente para updates batch en arrays.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué son los arrayFilters?",
        "option_a": "Filtros para arrays en find",
        "option_b": "Condiciones para actualizar elementos específicos de arrays en updates (con $[identifier])",
        "option_c": "Un operador de aggregation",
        "option_d": "Solo para $filter",
        "option_e": "No existen",
        "correct_answer": "b",
        "explanation": "arrayFilters (3.6+): condiciones para actualizar subset de array. Usa con $[identifier] en update. Sintaxis: arrayFilters: [{'identifier.field': condición}]. Puede usar múltiples identifiers para arrays nested. Más flexible que $ positional.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas elementos de array que cumplen condición con arrayFilters?",
        "option_a": "collection.updateOne(\n  {_id: id},\n  {$set: {'items.$[elem].qty': 0}},\n  {arrayFilters: [{'elem.qty': {$lt: 0}}]}\n)",
        "option_b": "collection.updateOne(\n  {_id: id, 'items.qty': {$lt: 0}},\n  {$set: {'items.$.qty': 0}}\n)",
        "option_c": "Ambas funcionan (a es más flexible)",
        "option_d": "collection.updateOne(\n  {_id: id},\n  {$update: {items: {where: {qty: {$lt: 0}}, set: {qty: 0}}}}\n)",
        "option_e": "Solo b es correcta",
        "correct_answer": "c",
        "explanation": "arrayFilters: actualiza TODOS los elementos que cumplen (no solo primero como $). Sintaxis: $[identifier] en update, arrayFilters con condiciones. $ positional solo primer match. arrayFilters más potente para múltiples elementos.",
        "difficulty": "hard"
    },
    {
        "category_id": 8,
        "question_type": "conceptual",
        "question_text": "¿Qué es $currentDate?",
        "option_a": "Operador para fechas futuras",
        "option_b": "Operador que setea campo a la fecha/timestamp actual del servidor",
        "option_c": "Una función de JavaScript",
        "option_d": "Solo en aggregation",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "$currentDate: setea fecha actual del servidor. Opciones: tipo Date o timestamp. Útil para: updatedAt automático. Sintaxis: {$currentDate: {lastModified: true}} o {lastModified: {$type: 'timestamp'}}. Usa hora del servidor (no cliente).",
        "difficulty": "easy"
    },
    {
        "category_id": 8,
        "question_type": "syntax",
        "question_text": "¿Cómo actualizas un campo con la fecha actual?",
        "option_a": "collection.updateOne({_id: id}, {$currentDate: {updatedAt: true}})",
        "option_b": "collection.updateOne({_id: id}, {$set: {updatedAt: new Date()}})",
        "option_c": "Ambas funcionan (a usa fecha del servidor, b del cliente)",
        "option_d": "collection.updateOne({_id: id}, {$now: {updatedAt: true}})",
        "option_e": "Solo b es correcta",
        "correct_answer": "c",
        "explanation": "$currentDate: fecha del SERVIDOR (consistente, correcto para distributed). new Date() en cliente puede tener clock skew. Para timestamp: {$currentDate: {field: {$type: 'timestamp'}}}. BEST PRACTICE: usa $currentDate para auditoría.",
        "difficulty": "medium"
    }
]

# Total Batch 9: 40 preguntas ✅
# Categoría 8 (Otras Funcionalidades): 40 preguntas ✅
# Total acumulado: 472 preguntas de 520

# ============================================================================
# BATCH 10: CATEGORÍA 9 - OPERACIONES AVANZADAS (40 preguntas)
# ============================================================================

QUESTIONS_BATCH_10 = [
    # ==================== CATEGORÍA 9: OPERACIONES AVANZADAS ====================

    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un replica set?",
        "option_a": "Una copia de seguridad",
        "option_b": "Grupo de instancias MongoDB que mantienen el mismo dataset con alta disponibilidad",
        "option_c": "Un tipo de índice",
        "option_d": "Solo para MongoDB Atlas",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Replica set: grupo de mongod que replican datos. Uno es primary (recibe writes), otros secundaries (replican). Si primary falla, automático election de nuevo primary. Mínimo 3 nodos recomendado (o 2 + arbiter). Proporciona: high availability, data redundancy, disaster recovery.",
        "difficulty": "easy"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué roles tienen los miembros de un replica set?",
        "option_a": "Todos son iguales",
        "option_b": "Primary (writes/reads), Secondary (replican, pueden reads), Arbiter (solo vota, no data)",
        "option_c": "Solo Primary y Secondary",
        "option_d": "Master y Slave",
        "option_e": "No hay roles",
        "correct_answer": "b",
        "explanation": "Primary: ÚNICO que recibe writes, puede reads. Secondary: replican primary vía oplog, pueden reads (con readPreference). Arbiter: participa en elections, NO almacena data (ahorra recursos). También: Hidden (no visible a clientes), Delayed (replicación con delay), Priority 0 (nunca primary).",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es el oplog en replicación?",
        "option_a": "Un archivo de log",
        "option_b": "Capped collection (local.oplog.rs) que registra todas las operaciones de escritura para replicación",
        "option_c": "Un tipo de índice",
        "option_d": "Solo para debugging",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Oplog (operations log): capped collection en DB local. Primary registra todas las writes. Secondaries leen oplog y aplican operaciones. Idempotente (aplicar múltiples veces = mismo resultado). Tamaño configurable. Si secondary se atrasa más que tamaño oplog, necesita resync inicial.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede cuando el primary de un replica set falla?",
        "option_a": "El sistema se detiene",
        "option_b": "Automatic election: un secondary se convierte en primary (típicamente <12 segundos)",
        "option_c": "Requiere intervención manual",
        "option_d": "Los datos se pierden",
        "option_e": "Solo funciona en Atlas",
        "correct_answer": "b",
        "explanation": "Election automática: cuando primary falla o no responde, secondaries votan por nuevo primary. Majority vote requerido. Típicamente <12 segundos. Durante election: NO writes (reads dependen de readConcern). Después: nuevo primary acepta writes. IMPORTANTE: mayoría de nodos debe estar disponible.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es sharding?",
        "option_a": "Una forma de backup",
        "option_b": "Método de distribución horizontal de datos across múltiples servidores (particionamiento)",
        "option_c": "Un tipo de índice",
        "option_d": "Solo para grandes empresas",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Sharding: particiona datos horizontalmente across múltiples servidores (shards). Cada shard: subset de datos. Permite: escalar horizontalmente, más throughput, más storage. Componentes: config servers (metadata), mongos (router), shards (data). Para datasets muy grandes (>100GB+).",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es mongos?",
        "option_a": "Una versión de MongoDB",
        "option_b": "Query router en sharded cluster que direcciona queries a shards correctos",
        "option_c": "Un comando",
        "option_d": "Un tipo de índice",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "mongos: routing service en sharded cluster. Clientes conectan a mongos (no directamente a shards). mongos lee metadata de config servers y enruta queries a shards apropiados. Stateless: puede tener múltiples mongos (load balancing). Agrega resultados de múltiples shards.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un shard key?",
        "option_a": "Una contraseña",
        "option_b": "Campo(s) usado para particionar y distribuir datos across shards",
        "option_c": "Un tipo de índice",
        "option_d": "Solo para seguridad",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Shard key: campo(s) que determina cómo distribuir documentos. INMUTABLE después de elegir. Debe tener índice. Tipos: ranged (rangos de valores), hashed (hash del valor). CRÍTICO: mala elección = hotspots, distribución desigual. Buenos shard keys: alta cardinalidad, distribución uniforme, queries usan shard key.",
        "difficulty": "hard"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es el database profiler?",
        "option_a": "Un tipo de índice",
        "option_b": "Herramienta que registra operaciones de DB para análisis de performance",
        "option_c": "Un backup tool",
        "option_d": "Solo para desarrollo",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Profiler: registra operaciones (queries, writes) en system.profile collection. Niveles: 0 (off), 1 (solo slow ops), 2 (todas ops). Configurable threshold (milisegundos). Útil para: identificar slow queries, optimizar. CUIDADO: nivel 2 impacta performance. En producción: nivel 1 con threshold apropiado.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "syntax",
        "question_text": "¿Cómo activas el profiler para queries >100ms?",
        "option_a": "db.setProfilingLevel(1, {slowms: 100})",
        "option_b": "db.enableProfiling(100)",
        "option_c": "db.profiler.start({threshold: 100})",
        "option_d": "mongod --profile 1 --slowms 100",
        "option_e": "No se puede configurar",
        "correct_answer": "a",
        "explanation": "setProfilingLevel(level, options). Level: 0/1/2. slowms: threshold. Para ver: db.getProfilingStatus(). Para leer: db.system.profile.find(). Para filtrar: {millis: {$gt: 100}}. Limit collection size: capped. También: db.setProfilingLevel(0) para desactivar.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es explain() y para qué sirve?",
        "option_a": "Documenta queries",
        "option_b": "Retorna plan de ejecución de query (índices usados, docs examinados, tiempo)",
        "option_c": "Ejecuta queries más rápido",
        "option_d": "Un tipo de índice",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "explain(): analiza query sin ejecutar (o ejecutando según modo). Modos: 'queryPlanner' (plan), 'executionStats' (ejecuta + stats), 'allPlansExecution' (todos planes considerados). Info: índices, docs examined/returned, execution time. ESENCIAL para optimización. Identifica: missing indexes, inefficient queries.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "syntax",
        "question_text": "¿Cómo usas explain() con execution stats?",
        "option_a": "db.collection.find({filtro}).explain('executionStats')",
        "option_b": "db.collection.explain().find({filtro})",
        "option_c": "db.collection.find({filtro}).stats()",
        "option_d": "Tanto a como b son correctas",
        "option_e": "No se puede",
        "correct_answer": "d",
        "explanation": "Dos sintaxis: cursor.explain(verbosity) o db.collection.explain(verbosity).find(). Verbosity: 'queryPlanner', 'executionStats', 'allPlansExecution'. executionStats: ejecuta query, retorna stats reales. Analiza: totalDocsExamined, totalKeysExamined, executionTimeMillis, nReturned.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué indica en explain() que totalDocsExamined >> nReturned?",
        "option_a": "Query muy eficiente",
        "option_b": "Query posiblemente ineficiente, examina muchos docs pero retorna pocos (probablemente falta índice)",
        "option_c": "Es normal",
        "option_d": "No importa",
        "option_e": "Error en la query",
        "correct_answer": "b",
        "explanation": "totalDocsExamined vs nReturned: ratio importante. Ideal: ~1:1. Si examina 10000 docs pero retorna 10: INEFICIENTE. Causas: sin índice apropiado, índice no selectivo, query no usa índice. Solución: crear/mejorar índice. COLLSCAN (collection scan) es señal de alerta.",
        "difficulty": "hard"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un índice compuesto (compound) y cuándo usarlo?",
        "option_a": "Un índice de múltiples colecciones",
        "option_b": "Índice en múltiples campos, orden importa (queries deben usar prefix del índice)",
        "option_c": "Un índice complejo",
        "option_d": "Solo para texto",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Compound index: múltiples campos {a: 1, b: 1, c: 1}. Soporta queries con prefixes: {a}, {a,b}, {a,b,c} pero NO {b}, {c}, {b,c}. ORDEN IMPORTA: equality first, sort/range last. Más eficiente que múltiples single-field indexes. Regla ESR: Equality, Sort, Range.",
        "difficulty": "hard"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es el ESR rule para índices compuestos?",
        "option_a": "Un tipo de índice",
        "option_b": "Regla de orden: Equality (=), Sort (ordenamiento), Range (>, <) para mejor performance",
        "option_c": "Un comando",
        "option_d": "Solo para aggregation",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "ESR: orden óptimo campos en compound index. E (Equality): campos con = primero. S (Sort): campos de ordenamiento. R (Range): campos con range queries ($gt, $lt) último. Ejemplo: query {status: 'active', date: {$gt: X}}.sort({name: 1}) → índice {status: 1, name: 1, date: 1}.",
        "difficulty": "hard"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es index selectivity?",
        "option_a": "Cantidad de índices",
        "option_b": "Medida de cuán únicos son los valores (alta selectividad = pocos duplicados, más eficiente)",
        "option_c": "Velocidad del índice",
        "option_d": "Tamaño del índice",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Selectivity: ratio de valores únicos vs total docs. Alta selectividad (ej: email, _id): muy eficiente. Baja selectividad (ej: boolean, gender): menos eficiente. Para baja selectividad: considera partial index o compound index. Índices con alta selectividad filtran más docs.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es read concern?",
        "option_a": "Preocupación por lectura",
        "option_b": "Nivel de consistencia/isolation para operaciones de lectura",
        "option_c": "Un tipo de índice",
        "option_d": "Solo para writes",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Read concern: garantías de consistencia en reads. Niveles: 'local' (data local, puede rollback), 'majority' (acknowledged por majority, durable), 'linearizable' (linearizable reads), 'available' (no waiting), 'snapshot' (en transacciones). Balance: consistencia vs latencia.",
        "difficulty": "hard"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué diferencia hay entre 'local' y 'majority' read concern?",
        "option_a": "No hay diferencia",
        "option_b": "'local' puede leer datos que podrían hacer rollback; 'majority' solo lee datos durables (majority acknowledged)",
        "option_c": "'majority' es más rápido",
        "option_d": "'local' es más seguro",
        "option_e": "Solo funciona en standalone",
        "correct_answer": "b",
        "explanation": "'local': lee desde primary local, puede incluir writes no replicados (si primary falla, rollback). 'majority': lee solo data acknowledged por majority (durable, no rollback). 'majority' más latencia pero más seguro. Para strong consistency: 'majority'. Default: 'local'.",
        "difficulty": "hard"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es causal consistency?",
        "option_a": "Un tipo de índice",
        "option_b": "Garantiza que reads ven writes en orden causal (si A writes luego B reads, B ve write de A)",
        "option_c": "Solo para logs",
        "option_d": "No relacionado con MongoDB",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Causal consistency (3.6+): garantiza orden causal de operaciones. Requiere: sessions, majority read/write concern. Útil cuando: múltiples apps, reads después de writes, distributed. Ejemplo: write luego immediate read ve el write (sin causal, read podría ver stale data de secondary).",
        "difficulty": "hard"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es el working set en MongoDB?",
        "option_a": "Conjunto de operaciones",
        "option_b": "Subset de datos frecuentemente accedidos que deben caber en RAM para performance óptimo",
        "option_c": "Un tipo de colección",
        "option_d": "Solo para sharding",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Working set: datos + índices frecuentemente usados. CRÍTICO: debe caber en RAM. Si working set > RAM: disk I/O constante (muy lento). MongoDB usa memory-mapped files. Monitorea: page faults. Solución: más RAM o reducir working set (indexes, data).",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué herramientas de monitoreo proporciona MongoDB?",
        "option_a": "Ninguna",
        "option_b": "mongostat (stats tiempo real), mongotop (time en colecciones), db.serverStatus(), Cloud Manager/Ops Manager",
        "option_c": "Solo logs",
        "option_d": "Solo Atlas",
        "option_e": "Requiere tools externos",
        "correct_answer": "b",
        "explanation": "mongostat: stats cada segundo (inserts, queries, updates, etc.). mongotop: tiempo por colección. db.serverStatus(): métricas completas. db.stats(), collection.stats(). También: MongoDB Cloud Manager (SaaS), Ops Manager (on-prem), Atlas monitoring. Prometheus exporter disponible.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es mongodump y mongorestore?",
        "option_a": "Comandos obsoletos",
        "option_b": "Herramientas para backup (dump) y restauración (restore) de datos BSON",
        "option_c": "Solo para desarrollo",
        "option_d": "Herramientas de debugging",
        "option_e": "No existen",
        "correct_answer": "b",
        "explanation": "mongodump: export BSON backup de DB/colección. mongorestore: import desde dump. Útil para: backups, migración, testing. Formato BSON (no human-readable, preserva tipos). Para JSON: mongoexport/mongoimport. mongodump no es snapshot consistente (usa para dev, no prod crítico).",
        "difficulty": "easy"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre mongodump y snapshot?",
        "option_a": "Son iguales",
        "option_b": "mongodump: logical backup (documenta por documento); snapshot: filesystem/volume backup (más rápido, consistente)",
        "option_c": "mongodump es más rápido",
        "option_d": "snapshot no existe",
        "option_e": "No hay diferencia",
        "correct_answer": "b",
        "explanation": "mongodump: logical backup, puede hacerse en línea pero no point-in-time consistente. Snapshot: filesystem-level (LVM, EBS), instantáneo, consistente. Para prod: snapshots + oplog. mongodump: pequeños DBs, dev/test. Snapshots: producción, grandes datasets. Cloud provider snapshots recomendados.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es authentication en MongoDB?",
        "option_a": "No existe",
        "option_b": "Proceso de verificar identidad del usuario antes de permitir acceso",
        "option_c": "Un tipo de índice",
        "option_d": "Solo para Atlas",
        "option_e": "Automático",
        "correct_answer": "b",
        "explanation": "Authentication: verifica quién eres. Mecanismos: SCRAM (default, username/password), x.509 (certificates), LDAP, Kerberos. Crea usuarios con roles. IMPORTANTE: MongoDB SIN auth acepta cualquier conexión (NUNCA en producción expuesta). Habilita auth con --auth o security.authorization en config.",
        "difficulty": "easy"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es authorization en MongoDB?",
        "option_a": "Igual que authentication",
        "option_b": "Proceso de determinar qué acciones puede realizar un usuario autenticado (roles y permisos)",
        "option_c": "No existe",
        "option_d": "Solo para Enterprise",
        "option_e": "Automático",
        "correct_answer": "b",
        "explanation": "Authorization: qué puedes hacer. Basado en roles: read, readWrite, dbAdmin, userAdmin, root. Roles por DB. Built-in roles + custom roles. Principio least privilege: mínimos permisos necesarios. Authentication (quién) + Authorization (qué) = seguridad completa.",
        "difficulty": "easy"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué son los built-in roles en MongoDB?",
        "option_a": "No existen roles",
        "option_b": "Roles predefinidos: read, readWrite, dbAdmin, userAdmin, clusterAdmin, root, etc.",
        "option_c": "Solo custom roles permitidos",
        "option_d": "Un tipo de índice",
        "option_e": "Solo en Atlas",
        "correct_answer": "b",
        "explanation": "Built-in roles: read (read data), readWrite (read+write), dbAdmin (admin operations), userAdmin (manage users), clusterAdmin (cluster management), root (superuser). Por DB excepto cluster roles. Usa roles específicos, evita root. Puedes crear custom roles para necesidades específicas.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es encryption at rest?",
        "option_a": "Encriptación durante transporte",
        "option_b": "Encriptación de datos almacenados en disco",
        "option_c": "Un tipo de índice",
        "option_d": "Solo para passwords",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Encryption at rest: encripta data files en disco. Protege si: roban discos, acceso físico no autorizado. MongoDB: WiredTiger encryption (Enterprise/Atlas). Requiere key management. También: TLS/SSL para encryption in transit. Defense in depth: ambos tipos de encriptación.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es TLS/SSL en MongoDB?",
        "option_a": "Un tipo de backup",
        "option_b": "Protocolo de encriptación para comunicación client-server (encryption in transit)",
        "option_c": "Un rol",
        "option_d": "Solo para Atlas",
        "option_e": "No necesario",
        "correct_answer": "b",
        "explanation": "TLS/SSL: encripta comunicación entre cliente-servidor y entre nodos de replica set/sharded cluster. Protege: man-in-the-middle, eavesdropping. Requiere: certificates. Configura: net.tls en config. ESENCIAL en producción, especialmente si conexiones atraviesan redes públicas.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es el storage engine en MongoDB?",
        "option_a": "Un motor de búsqueda",
        "option_b": "Componente que gestiona cómo datos se almacenan en disco (WiredTiger es default)",
        "option_c": "Un tipo de índice",
        "option_d": "Una herramienta externa",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Storage engine: capa de almacenamiento. WiredTiger (default desde 3.2): compresión, document-level locking, encryption. MMAPv1 (deprecado). WiredTiger: mejor performance, concurrencia, compresión. In-memory engine también disponible (Enterprise). Storage engine define: formato archivos, concurrency, compresión.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué ventajas tiene WiredTiger?",
        "option_a": "Ninguna especial",
        "option_b": "Document-level locking (más concurrencia), compresión, snapshots, checkpoints, encryption",
        "option_c": "Solo compresión",
        "option_d": "Es más antiguo",
        "option_e": "No hay ventajas",
        "correct_answer": "b",
        "explanation": "WiredTiger: document-level locking (vs collection-level en MMAPv1, mucho mejor concurrencia). Compresión: snappy (default), zlib, zstd. Checkpoints: snapshots consistentes cada 60s. Journaling eficiente. Encryption at rest (Enterprise). Cache configurable. Mucho mejor que MMAPv1.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es journaling en MongoDB?",
        "option_a": "Un tipo de log",
        "option_b": "Write-ahead log que garantiza durabilidad (recovery tras crash)",
        "option_c": "Solo para debugging",
        "option_d": "No existe",
        "option_e": "Opcional sin importancia",
        "correct_answer": "b",
        "explanation": "Journal: write-ahead log de operaciones. Antes de aplicar a data files, escribe a journal. En crash: replica desde journal. WiredTiger: journal en disco cada 50-100ms (configurable). Garantiza durabilidad con write concern {j: true}. CRÍTICO para evitar pérdida de datos en crash.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es el replication lag?",
        "option_a": "Lag de red",
        "option_b": "Retraso entre primary y secondary en aplicar operaciones del oplog",
        "option_c": "Un error",
        "option_d": "Solo en sharding",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Replication lag: cuánto se atrasa secondary respecto a primary. Medido en segundos. Causas: secondary sobrecargado, network slow, disk slow, operaciones pesadas. Monitorea: rs.printSecondaryReplicationInfo(). Alto lag: reads de secondary ven stale data, risk de secondary no poder catch up si primary falla.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un initial sync en replicación?",
        "option_a": "Primera conexión",
        "option_b": "Proceso de copiar dataset completo cuando nuevo secondary se une o secondary está muy atrasado",
        "option_c": "Un tipo de backup",
        "option_d": "Solo al instalar",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Initial sync: copia completa de datos de otro miembro. Ocurre cuando: nuevo member, secondary muy atrasado (oplog no cubre), after restore de backup. Proceso: clone data, apply oplog ops durante clone, build indexes. Costoso (tiempo, recursos, network). Evita: mantén oplog suficientemente grande.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es balancing en sharded cluster?",
        "option_a": "Balance de carga",
        "option_b": "Proceso automático de migrar chunks entre shards para distribuir datos uniformemente",
        "option_c": "Un tipo de índice",
        "option_d": "Manual solamente",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Balancer: background process que migra chunks entre shards. Objetivo: distribución uniforme de chunks. Ejecuta cuando: diferencia de chunks entre shards supera threshold. Configurable: balancing window (horario), enable/disable. Migración puede impactar performance. Monitorea: sh.status().",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un chunk en sharding?",
        "option_a": "Un pedazo de código",
        "option_b": "Rango continuo de shard key values que se migra como unidad atómica",
        "option_c": "Un tipo de índice",
        "option_d": "Un nodo",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Chunk: rango de shard key values (ej: {userId: 1000 to 2000}). MongoDB divide collection en chunks (~64MB default). Balancer migra chunks entre shards. Chunk split: cuando chunk crece mucho. Hot chunks: chunks con mucha actividad (problema de shard key mal elegido).",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué son los config servers en sharded cluster?",
        "option_a": "Servidores de configuración de apps",
        "option_b": "Replica set que almacena metadata del cluster (qué chunks en qué shards, etc.)",
        "option_c": "Un tipo de shard",
        "option_d": "Solo para monitoring",
        "option_e": "No existen",
        "correct_answer": "b",
        "explanation": "Config servers: replica set (CSRS - Config Server Replica Set) con metadata del sharded cluster. Info: chunks, shards, collections sharded. mongos consulta config servers para routing. CRÍTICOS: sin config servers disponibles, cluster no funciona. Mínimo 3 config servers recomendado.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué métricas son importantes para monitorear en producción?",
        "option_a": "Solo espacio en disco",
        "option_b": "CPU, RAM (working set), disk I/O, replication lag, connections, slow queries, lock %",
        "option_c": "Solo número de documentos",
        "option_d": "MongoDB se monitorea automáticamente",
        "option_e": "No necesita monitoreo",
        "correct_answer": "b",
        "explanation": "Métricas clave: CPU (no >80% sostenido), RAM (working set fit?), disk I/O (IOPS, queue depth), replication lag (<10s), connections (near max?), slow queries (profiler), lock % (contention), page faults (memoria insuficiente). Herramientas: mongostat, Cloud/Ops Manager, Prometheus+Grafana.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un arbiter y cuándo usarlo?",
        "option_a": "Un tipo de primary",
        "option_b": "Miembro de replica set que solo vota en elections (no almacena data), útil para número impar de voters con presupuesto limitado",
        "option_c": "Un tipo de índice",
        "option_d": "Un backup",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Arbiter: vota en elections pero NO replica data. Lightweight (poco recursos). Útil: cuando solo puedes tener 2 data-bearing nodes pero necesitas 3 para majority. CUIDADO: sin arbiter = más resiliente (con 2 data nodes + arbiter, si 1 data node falla, no hay automatic failover). Mejor: 3 data nodes sin arbiter.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un hidden member en replica set?",
        "option_a": "Un nodo secreto",
        "option_b": "Secondary que replica pero no es visible a clientes (para reporting, backups sin impactar tráfico normal)",
        "option_c": "Un nodo sin datos",
        "option_d": "Solo para testing",
        "option_e": "No existe",
        "correct_answer": "b",
        "explanation": "Hidden member: priority 0 (nunca primary) + hidden: true (no aparece en queries automáticas). Usa para: reporting queries sin impactar primary, backups, analytics. Mantiene replicación actualizada. Clientes no ven hidden member (a menos que especifiquen directamente). Útil en producción.",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Qué es un delayed member?",
        "option_a": "Un member lento",
        "option_b": "Secondary con delay intencional en replicación (ej: 1 hora atrás) para protección contra errores humanos",
        "option_c": "Un error",
        "option_d": "No existe",
        "option_e": "Un backup",
        "correct_answer": "b",
        "explanation": "Delayed member: replica con delay configurable (ej: slaveDelay: 3600 = 1 hora). Útil para: recovery de errores humanos (delete accidental), puedes recover estado de hace X tiempo. También hidden y priority 0. NO reemplazo de backups (continuous, limitado por oplog).",
        "difficulty": "medium"
    },
    {
        "category_id": 9,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la mejor práctica para tamaño de oplog?",
        "option_a": "Lo más pequeño posible",
        "option_b": "Suficientemente grande para cubrir ventana de mantenimiento + problemas (típicamente 2-7 días de operaciones)",
        "option_c": "1GB siempre",
        "option_d": "No importa",
        "option_e": "Default es suficiente",
        "correct_answer": "b",
        "explanation": "Oplog: suficientemente grande para cubrir: maintenance (upgrades), network issues, secondary failures. Típico: 2-7 días. Muy pequeño: secondary puede quedar atrás irreversiblemente (require initial sync). Configurable: oplogSizeMB. Monitorea: cuánto tiempo cubre oplog actual. Default: 5% disk o 50GB (el mayor).",
        "difficulty": "hard"
    }
]

# Total Batch 10: 40 preguntas ✅
# Categoría 9 (Operaciones Avanzadas): 40 preguntas ✅
# Total acumulado: 512 preguntas de 520

# ============================================================
# BATCH 11: PREGUNTAS FINALES (CATEGORÍAS MIXTAS)
# ============================================================

FINAL_BATCH = [
    # Preguntas adicionales de Agregación (Categoría 6)
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "En infovuelos_limpio, ¿cómo obtener el promedio de distancia por aerolínea, mostrando solo aerolíneas con promedio > 1000?",
        "option_a": "db.infovuelos.aggregate([{$group: {_id: '$AIRLINE', avg_dist: {$avg: '$DISTANCE'}}}, {$match: {avg_dist: {$gt: 1000}}}])",
        "option_b": "db.infovuelos.aggregate([{$match: {DISTANCE: {$gt: 1000}}}, {$group: {_id: '$AIRLINE', avg_dist: {$avg: '$DISTANCE'}}}])",
        "option_c": "db.infovuelos.aggregate([{$group: {_id: '$AIRLINE', avg_dist: {$avg: '$DISTANCE'}}}, {$sort: {avg_dist: -1}}])",
        "option_d": "db.infovuelos.find({DISTANCE: {$gt: 1000}}).group({AIRLINE: 1})",
        "option_e": "db.infovuelos.aggregate([{$avg: '$DISTANCE'}, {$match: {$gt: 1000}}])",
        "correct_answer": "a",
        "explanation": "$match DESPUÉS de $group filtra resultados agregados. Opción b filtra antes (distancia individual > 1000, no promedio). $match después de $group usa campos calculados en $group.",
        "dataset_reference": "infovuelos_limpio",
        "difficulty": "hard"
    },
    {
        "category_id": 6,
        "question_type": "syntax",
        "question_text": "En listings_limpio, ¿cómo obtener el top 3 de barrios con más listings de tipo 'Entire home/apt', ordenados por cantidad?",
        "option_a": "db.listings.aggregate([{$match: {room_type: 'Entire home/apt'}}, {$group: {_id: '$neighbourhood', count: {$sum: 1}}}, {$sort: {count: -1}}, {$limit: 3}])",
        "option_b": "db.listings.find({room_type: 'Entire home/apt'}).limit(3)",
        "option_c": "db.listings.aggregate([{$group: {_id: '$neighbourhood'}}, {$limit: 3}])",
        "option_d": "db.listings.aggregate([{$sort: {neighbourhood: 1}}, {$limit: 3}])",
        "option_e": "db.listings.count({room_type: 'Entire home/apt'})",
        "correct_answer": "a",
        "explanation": "Pipeline correcto: $match filtra por tipo, $group agrupa por barrio y cuenta, $sort ordena por count descendente, $limit toma top 3. Orden de stages es crítico en aggregation.",
        "dataset_reference": "listings_limpio",
        "difficulty": "medium"
    },

    # Preguntas adicionales de PyMongo (Categoría 7)
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "¿Cómo crear un índice compuesto en PyMongo sobre campos 'ciudad' (ascendente) y 'fecha' (descendente)?",
        "option_a": "collection.create_index([('ciudad', 1), ('fecha', -1)])",
        "option_b": "collection.index(['ciudad', 'fecha'])",
        "option_c": "collection.create_index({'ciudad': 1, 'fecha': -1})",
        "option_d": "collection.createIndex([('ciudad', 1), ('fecha', -1)])",
        "option_e": "collection.ensureIndex('ciudad', 'fecha')",
        "correct_answer": "a",
        "explanation": "create_index() en PyMongo acepta lista de tuplas: [(campo, dirección), ...]. 1 = ascendente, -1 = descendente. Opción c usa dict (no garantiza orden en Python < 3.7).",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 7,
        "question_type": "syntax",
        "question_text": "En PyMongo, ¿cómo usar update_many() con $inc para incrementar 'views' en 1 para todos los documentos de categoría 'tech'?",
        "option_a": "collection.update_many({'category': 'tech'}, {'$inc': {'views': 1}})",
        "option_b": "collection.update({'category': 'tech'}, {'views': 1})",
        "option_c": "collection.update_many({'category': 'tech'}, {'views': {'$inc': 1}})",
        "option_d": "collection.increment({'category': 'tech'}, {'views': 1})",
        "option_e": "collection.update_many({'$inc': {'views': 1}}, {'category': 'tech'})",
        "correct_answer": "a",
        "explanation": "update_many(filtro, actualización). $inc va en actualización: {'$inc': {'campo': valor}}. Opción e invierte los argumentos. $inc incrementa valor existente.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },

    # Preguntas adicionales de CRUD - Read (Categoría 3)
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "En data_act_01_limpio, ¿cómo buscar documentos donde 'tags' (array) contenga 'urgent' Y 'priority', y proyectar solo 'title' y 'tags'?",
        "option_a": "db.data.find({tags: {$all: ['urgent', 'priority']}}, {title: 1, tags: 1, _id: 0})",
        "option_b": "db.data.find({tags: ['urgent', 'priority']}, {title: 1, tags: 1})",
        "option_c": "db.data.find({$and: [{tags: 'urgent'}, {tags: 'priority'}]}, {title: 1, tags: 1})",
        "option_d": "db.data.find({tags: {$in: ['urgent', 'priority']}}, {title: 1, tags: 1, _id: 0})",
        "option_e": "db.data.find({tags: 'urgent', tags: 'priority'}, {title: 1, tags: 1})",
        "correct_answer": "a",
        "explanation": "$all requiere que array contenga TODOS los elementos especificados. $in requiere al menos uno. Proyección: 1 incluye campo, 0 excluye (excluir _id explícitamente). Opción b busca array exacto.",
        "dataset_reference": "data_act_01_limpio",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "En infovuelos_limpio, ¿cómo buscar vuelos con DEPARTURE_DELAY entre -10 y 30 (inclusive), ordenados por DEPARTURE_TIME?",
        "option_a": "db.infovuelos.find({DEPARTURE_DELAY: {$gte: -10, $lte: 30}}).sort({DEPARTURE_TIME: 1})",
        "option_b": "db.infovuelos.find({DEPARTURE_DELAY: {$between: [-10, 30]}}).sort({DEPARTURE_TIME: 1})",
        "option_c": "db.infovuelos.find({$and: [{DEPARTURE_DELAY: {$gte: -10}}, {DEPARTURE_DELAY: {$lt: 30}}]}).sort({DEPARTURE_TIME: 1})",
        "option_d": "db.infovuelos.find({DEPARTURE_DELAY: [-10, 30]}).sort({DEPARTURE_TIME: 1})",
        "option_e": "db.infovuelos.find({DEPARTURE_DELAY: {$in: [-10, 30]}}).sort({DEPARTURE_TIME: 1})",
        "correct_answer": "a",
        "explanation": "$gte (mayor o igual) y $lte (menor o igual) para rangos inclusivos. Pueden combinarse en mismo objeto. $between no existe en MongoDB. $in busca valores exactos en array.",
        "dataset_reference": "infovuelos_limpio",
        "difficulty": "medium"
    },

    # Preguntas adicionales de CRUD - Update (Categoría 4)
    {
        "category_id": 4,
        "question_type": "syntax",
        "question_text": "¿Cómo agregar elemento 'premium' al array 'features' solo si no existe ya, para documentos con price > 100?",
        "option_a": "db.collection.updateMany({price: {$gt: 100}}, {$addToSet: {features: 'premium'}})",
        "option_b": "db.collection.updateMany({price: {$gt: 100}}, {$push: {features: 'premium'}})",
        "option_c": "db.collection.updateMany({price: {$gt: 100}}, {$set: {features: {$push: 'premium'}}})",
        "option_d": "db.collection.update({price: {$gt: 100}}, {$addToSet: {features: 'premium'}})",
        "option_e": "db.collection.updateMany({price: {$gt: 100}}, {$add: {features: 'premium'}})",
        "correct_answer": "a",
        "explanation": "$addToSet agrega a array solo si valor no existe (evita duplicados). $push siempre agrega (permite duplicados). updateMany actualiza múltiples docs. update (sin Many) solo actualiza primero.",
        "dataset_reference": "N/A",
        "difficulty": "hard"
    },

    # Pregunta adicional de Instalación y Entorno (Categoría 1)
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el puerto por defecto de MongoDB y cómo cambiarlo?",
        "option_a": "3306, no se puede cambiar",
        "option_b": "27017, se cambia con --port o en mongod.conf (net.port)",
        "option_c": "8080, se cambia en settings",
        "option_d": "5432, no se puede cambiar",
        "option_e": "27017, solo se puede cambiar reinstalando",
        "correct_answer": "b",
        "explanation": "Puerto default: 27017. Se cambia con flag --port al iniciar mongod, o configurando net.port en mongod.conf. También: 27018 para mongos, 27019 para config servers (convenciones). Clientes deben especificar puerto custom en connection string.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    }
]

# Total Batch 11: 8 preguntas ✅
# Distribución final:
# - Categoría 1 (Instalación): +1 = 31 preguntas
# - Categoría 3 (CRUD Read): +2 = 82 preguntas
# - Categoría 4 (CRUD Update): +1 = 61 preguntas
# - Categoría 6 (Agregación): +2 = 102 preguntas
# - Categoría 7 (PyMongo): +2 = 62 preguntas
# Total acumulado: 520 preguntas ✅✅✅

# ============================================================
# CATEGORÍA 10: TEST 1 - FUNDAMENTOS DE DATOS
# ============================================================
# Preguntas extraídas del Test 1 del curso
# Total: 10 preguntas conceptuales

TEST_1_FUNDAMENTOS_DATOS = [
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la unidad semántica mínima que puede almacenarse o comunicarse?",
        "option_a": "Dato.",
        "option_b": "Información.",
        "option_c": "Conocimiento.",
        "option_d": "Las respuestas A y B son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "El dato es la mínima expresión semántica que puede almacenarse.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Qué métodos pueden utilizarse para la transformación de información a conocimiento?",
        "option_a": "Contextualización, agregación y cálculo.",
        "option_b": "Repercusión, conexión y conversación.",
        "option_c": "Categorización, corrección y agregación.",
        "option_d": "Análisis, investigación y discusión.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Son los métodos que, entre otros, permiten la transformación adecuada de la información en conocimiento.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Qué métrica de calidad describe la proporción en la que un conjunto de datos contiene a la población que representa?",
        "option_a": "Precisión.",
        "option_b": "Consistencia.",
        "option_c": "Completitud.",
        "option_d": "Interpretabilidad.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "Solo puede ser la completitud la métrica que indique lo representativo que son los datos con respecto a una población.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Cuál de los siguientes es un ejemplo de método de captura manual?",
        "option_a": "Web scraping.",
        "option_b": "Encuestas.",
        "option_c": "Acceso a bases de datos relacionales.",
        "option_d": "Lectura de termómetro digital.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Excepto las encuestas, los otros métodos pueden ser automatizados; la encuesta, por su parte, no.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿En qué categoría de captura de datos entra la lectura de información del acelerómetro y giroscopio de un teléfono móvil?",
        "option_a": "Captura manual.",
        "option_b": "Procesamiento de documentos.",
        "option_c": "Acceso a datos públicos.",
        "option_d": "Sensores.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "El acelerómetro y el giroscopio son los sensores que vienen integrados en el teléfono para capturar el movimiento del teléfono y su posición o inclinación, por ende, los sensores determinan la captura de este tipo de datos.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Qué elemento es utilizado para delimitar valores en un fichero CSV?",
        "option_a": "Coma.",
        "option_b": "CRLF.",
        "option_c": "Comillas dobles.",
        "option_d": "Espacio.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Dentro de los limitares posibles de CSV, la coma es uno de ellos.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Sobre qué estructuras se basa el formato JSON?",
        "option_a": "Objetos y diccionarios.",
        "option_b": "Tablas hash.",
        "option_c": "Objetos y arrays.",
        "option_d": "Listas enlazadas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "Los objetos y los arrays son los elementos que conforman la estructura de JSON.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Cuál de las siguientes condiciones sobre XML es verdadera?",
        "option_a": "Un documento solo puede tener un elemento raíz.",
        "option_b": "El contenido de un elemento debe ser otro elemento.",
        "option_c": "Todo elemento debe tener un atributo llamado «id».",
        "option_d": "Los atributos deben de ser de tipo numérico.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Es la única afirmación que es cierta, un documento XML solo puede tener un único elemento raíz.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Qué nombre recibe un conjunto de datos persistente utilizado por un sistema de software?",
        "option_a": "Archivo.",
        "option_b": "Base de datos.",
        "option_c": "Registro.",
        "option_d": "Las respuestas A y B son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "La persistencia se puede dar o bien en una base de datos o bien en un archivo.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 10,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la instrucción de SQL para consultar información?",
        "option_a": "SELECT.",
        "option_b": "INSERT.",
        "option_c": "UPDATE.",
        "option_d": "DELETE.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "La instrucción SELECT permite consultar información en cualquier base de datos.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    }
]

# ============================================================
# CATEGORÍA 11: TEST 2 - NOSQL Y MONGODB
# ============================================================
# Preguntas extraídas del Test 2 del curso
# Total: 10 preguntas conceptuales

TEST_2_NOSQL_MONGODB = [
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Qué tipo de base de datos NoSQL se caracteriza por operaciones de lectura y escritura básicas, además de ser apropiadas para entornos de gestión de caché?",
        "option_a": "Almacén clave-valor simple.",
        "option_b": "Almacén clave-valor sofisticado.",
        "option_c": "Base de datos relacional.",
        "option_d": "Almacén de documentos.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Son el tipo de bases de datos que soportan operaciones de lectura y escritura básicas.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿En qué categoría de base de datos NoSQL se clasifica a MongoDB?",
        "option_a": "Almacén clave-valor simple.",
        "option_b": "Almacén clave-valor sofisticado.",
        "option_c": "Base de datos relacional.",
        "option_d": "Almacén de documentos.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "MongoDB es una base de datos basada en documentos.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Cuál de las siguientes afirmaciones es correcta?",
        "option_a": "Cassandra se caracteriza porque todos sus nodos actúan por igual y se agrupan en anillo.",
        "option_b": "Cassandra y Neo4j están desarrolladas en Java.",
        "option_c": "Neo4j es una base de datos transaccional compatible con ACID y que almacena y procesa grafos nativos.",
        "option_d": "Todas las afirmaciones anteriores son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Todas estas afirmaciones son correctas.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el equivalente a un registro en MongoDB?",
        "option_a": "Base de datos.",
        "option_b": "Collection.",
        "option_c": "Tabla.",
        "option_d": "Documento.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "El documento es la mínima agrupación de datos en MongoDB.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el término equivalente a una tabla en MongoDB?",
        "option_a": "Base de datos.",
        "option_b": "Collection.",
        "option_c": "Registro.",
        "option_d": "Documento.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "La colección agrupa varios documentos y es lo más similar a las tablas en un modelo relacional.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Cuándo se detalla el uso de la primera base de datos NoSQL?",
        "option_a": "En 2007, cuando Amazon liberó DynamoDB.",
        "option_b": "Con Carlo Strozzi en 1998.",
        "option_c": "En 1965 con MultiValue.",
        "option_d": "Eric Evans en 2009.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "Las bases de datos MultiValue fueron desarrolladas por TRW en 1965.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Cuál de las siguientes es una ventaja de las bases de datos NoSQL?",
        "option_a": "No generan cuellos de botella.",
        "option_b": "Tecnología madura.",
        "option_c": "Responden a la necesidad de escalabilidades horizontal demandada cada vez por más empresas y, además, de manera sencilla.",
        "option_d": "Las respuestas A y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Estas dos afirmaciones describen dos problemas que resuelven las bases de datos NoSQL: el cuello de botella al almacenar los datos y la escalabilidad de dichas bases de datos cuando aumenta el volumen de datos.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Cuál de las siguientes afirmaciones es correcta?",
        "option_a": "Todo sistema distribuido no puede garantizar a la vez que haya consistencia, disponibilidad y tolerancia a particiones.",
        "option_b": "Un sistema distribuido garantiza al menos disponibilidad y consistencia.",
        "option_c": "Un sistema distribuido que garantiza la consistencia y la tolerancia a particiones no sacrifica por ello la disponibilidad.",
        "option_d": "Todas las afirmaciones anteriores son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Este es uno de los principios que describe el teorema CAP.",
        "dataset_reference": "N/A",
        "difficulty": "hard"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Qué patrón de diseño de MongoDB permite incluir un documento dentro de otro?",
        "option_a": "Uno-a-uno con documentos embebidos.",
        "option_b": "Uno-a-uno con documentos referidos.",
        "option_c": "Uno-a-varios con documentos referidos.",
        "option_d": "Las respuestas B y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Los documentos embebidos hacen referencia al uso de un documento dentro de otro, la relación es uno a uno en este caso.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 11,
        "question_type": "conceptual",
        "question_text": "¿Qué patrón de diseño de MongoDB permite incluir una lista de referencias a otros documentos dentro de un documento principal?",
        "option_a": "Uno-a-uno con documentos embebidos.",
        "option_b": "Uno-a-uno con documentos referidos.",
        "option_c": "Uno-a-varios con documentos referidos.",
        "option_d": "Las respuestas B y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Este patrón describe el uso de referencias entre documentos para representar las relaciones. Estas relaciones pueden ser uno a uno o uno a muchos.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    }
]

# ============================================================
# CATEGORÍA 12: TEST 3 - MONGODB CRUD
# ============================================================
# Preguntas extraídas del Test 3 del curso
# Total: 10 preguntas conceptuales

TEST_3_MONGODB_CRUD = [
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Qué comando de la consola de MongoDB se utiliza para indicar la base de datos con la que se trabajará?",
        "option_a": "select.",
        "option_b": "find.",
        "option_c": "use.",
        "option_d": "Las respuestas A y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "use permite «usar» la base de datos con la que se quiere trabajar.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Cuál de las siguientes afirmaciones es correcta?",
        "option_a": "MongoBooster es una herramienta GUI multiplataforma que facilita la construcción de consultas.",
        "option_b": "MongoDB Compass es una herramienta no propietaria para la manipulación externa de bases de datos MongoDB.",
        "option_c": "MongoBooster y MongoDB Compass proporcionan información estadística y de rendimiento de una base de datos MongoDB.",
        "option_d": "Todas las afirmaciones anteriores son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Las tres afirmaciones son correctas sobre los productos MongoBooster y MongoDB Compass.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Cuál será el resultado al insertar un documento que posee un atributo más al resto de atributos de la colección?",
        "option_a": "Dará un fallo al insertar los datos porque el modelo de datos es diferente.",
        "option_b": "Insertará los datos a la colección.",
        "option_c": "Insertará los datos a la colección y creará el nuevo atributo vacío en el resto de documentos.",
        "option_d": "Insertará los datos a la colección, pero sin el nuevo atributo para cumplir con el modelo.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Los documentos dentro de las colecciones no responden a ningún modelo de datos, por ello, se pueden insertar documentos con atributos diferentes.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Qué comando puede utilizarse en MongoDB para la creación de un nuevo documento dentro de una collection?",
        "option_a": "save.",
        "option_b": "insert.",
        "option_c": "create.",
        "option_d": "Las respuestas A y B son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Tanto save como insert permiten crear un nuevo documento en una colección. La acción es la misma en determinados casos, pero cada opción tiene un comportamiento diferente.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el nombre del atributo especial en las collections de MongoDB que ayuda a identificar de manera única a cada documento?",
        "option_a": "_id.",
        "option_b": "_ID.",
        "option_c": "Primary_key.",
        "option_d": "Identifier.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Este es el nombre del atributo; si en la consulta no se indica, lo crea MongoDB, y si se indica, el valor debe ser único entre los documentos.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Qué método permite modificar los datos de un documento sin tener que incluir el documento completo como argumento?",
        "option_a": "save.",
        "option_b": "store.",
        "option_c": "update.",
        "option_d": "set.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "Al igual que en SQL, update permite actualizar el documento utilizando una condición y los nuevos a valores a actualizar.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "La operación MongoDB equivalente a JOIN en SQL es:",
        "option_a": "Se puede conseguir concatenando sentencias find en la misma operación.",
        "option_b": "El aggregation framework.",
        "option_c": "MongoDB no tiene operación equivalente a JOIN hasta su versión 3.2.",
        "option_d": "Ninguna de las anteriores es cierta.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Hay funciones de agregación que nos permiten simular el JOIN de SQL.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Qué situación tiene que darse para que el comando save actualice un documento?",
        "option_a": "Que el argumento contenga un identificador existente en la collection.",
        "option_b": "Que el segundo argumento en el comando sea el valor true.",
        "option_c": "Que el argumento se parezca en más de un 50 % a un documento en la collection.",
        "option_d": "save no puede utilizarse para actualizar documentos.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "save no permite ningún parámetro de búsqueda. Comprueba si existe un documento con el mismo _id que guardaste. Cuando existe, lo reemplaza. Cuando no existe tal documento, inserta el documento como uno nuevo. Cuando el documento que inserta no tiene _id campo, genera uno con un ObjectId recién creado antes de insertarlo.",
        "dataset_reference": "N/A",
        "difficulty": "hard"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Qué comando se utiliza en MongoDB para eliminar un conjunto de documentos?",
        "option_a": "save.",
        "option_b": "delete.",
        "option_c": "remove.",
        "option_d": "unset.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Delete permite borrar documentos que cumplan determinada condición. Remove, por su parte, borra el primero documento que cumpla dicha condición.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 12,
        "question_type": "conceptual",
        "question_text": "¿Qué comando puede aplicarse sobre el resultado de una consulta en MongoDB para restringir el número de documentos retornados?",
        "option_a": "limit.",
        "option_b": "restrict.",
        "option_c": "skip.",
        "option_d": "sort.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Al igual que en SQL, limit limita el número de registros que se visualizan en una consulta.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    }
]

# ============================================================
# CATEGORÍA 13: TEST 4 - AGREGACIÓN MONGODB
# ============================================================
# Preguntas extraídas del Test 4 del curso
# Total: 10 preguntas conceptuales

TEST_4_AGREGACION_MONGODB = [
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Para qué son útiles las funciones de agregación?",
        "option_a": "Para agrupar datos.",
        "option_b": "Para realizar cálculos.",
        "option_c": "Para crear nuevas colecciones.",
        "option_d": "Todas las anteriores son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Las funciones de agregación, entre otras cosas, permiten agrupar datos, realizar cálculos y crear nuevas colecciones a partir de los resultados de sus operaciones.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Qué método puede utilizarse en MongoDB para agregar información de documentos en una collection?",
        "option_a": "sum.",
        "option_b": "Aggregate, a partir de la versión 2.2.",
        "option_c": "Map-Reduce.",
        "option_d": "Las respuestas B y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Estos son los métodos que se han desarrollado en este tema.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Cuál de las siguientes son operaciones específicas de agregación?",
        "option_a": "sum.",
        "option_b": "Map-Reduce.",
        "option_c": "count.",
        "option_d": "Las respuestas A y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Sum y count son funciones de agregación de por sí. Mongo las utiliza para cumplir operaciones específicas en Aggregate.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el objetivo principal de la función map?",
        "option_a": "Generar los pares clave-valor.",
        "option_b": "Realizar operaciones con los atributos de la colección.",
        "option_c": "Opinar sobre los pares clave-valor.",
        "option_d": "Crear una nueva colección.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Map genera los pares clave-valor en función de los datos que procesa.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el objetivo principal de la función reduce?",
        "option_a": "Generar los pares clave-valor.",
        "option_b": "Realizar operaciones con los atributos de la colección.",
        "option_c": "Operar sobre los pares clave-valor, reduce lo que hace es operar sobre ellos para cumplir su objetivo como función de reducción.",
        "option_d": "Crear una nueva colección.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "Una vez generados los pares clave-valor, reduce lo que hace es operar sobre ellos para cumplir su objetivo como función de reducción.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Qué comando se utiliza en una función map para generar el par clave-valor que será procesado posteriormente?",
        "option_a": "generate.",
        "option_b": "return.",
        "option_c": "emit.",
        "option_d": "yield.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "emit es la función que genera el par clave-valor que será procesado en el momento de generarse.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Cuál de las siguientes es una ventaja del framework de agregación de MongoDB?",
        "option_a": "Rendimiento.",
        "option_b": "Potencia.",
        "option_c": "Simplicidad.",
        "option_d": "Las respuestas A y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Aggregation básicamente permite conseguir mejor rendimiento y simplicidad a la hora de hacer las agregaciones. Potencia no es que sea siempre un daño en una agregación, incluso habrá agregaciones que no sean lo suficientemente adecuadas para pensar en su uso.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿En qué está modelado el framework de agregación?",
        "option_a": "Funciones.",
        "option_b": "Etapas.",
        "option_c": "Sentencias SQL.",
        "option_d": "Agrupaciones.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Recordemos que el framework de agregación está modelado en el concepto de tuberías de procesamiento de datos, es decir, los documentos entran en una tubería de varias etapas que transforman los documentos en un resultado agregado.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Qué campo es obligatorio especificar en framework de agregación?",
        "option_a": "_id.",
        "option_b": "Object.",
        "option_c": "$sum.",
        "option_d": "$group.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "$group es el campo obligatorio que debe especificarse en el framework de agregación.",
        "dataset_reference": "N/A",
        "difficulty": "hard"
    },
    {
        "category_id": 13,
        "question_type": "conceptual",
        "question_text": "¿Cuál de los siguientes es un operador del framework de agregación?",
        "option_a": "$gt.",
        "option_b": "$map.",
        "option_c": "$glear.",
        "option_d": "Todos los anteriores son correctos.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Los tres son operadores de agregación del framework.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    }
]

# ============================================================
# CATEGORÍA 14: TEST 5 - BACKUP, ÍNDICES, REPLICACIÓN Y SHARDING
# ============================================================
# Preguntas extraídas del Test 5 del curso
# Total: 10 preguntas conceptuales

TEST_5_BACKUP_INDICES_REPLICACION = [
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Qué comando de MongoDB permite crear una copia de respaldo de una base de datos?",
        "option_a": "mongorestore.",
        "option_b": "mongodump.",
        "option_c": "backup.",
        "option_d": "mongod.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Este comando permite crear una copia de seguridad «dump» de la base de datos.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Qué comando de MongoDB permite recuperar una base de datos a partir de una copia de seguridad?",
        "option_a": "mongorestore.",
        "option_b": "save.",
        "option_c": "mongos.",
        "option_d": "copydb.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Este comando permite restaurar una base de datos que previamente ha sido guardada «dump».",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Qué elementos de la base de datos mejoran el rendimiento de consultas a collection?",
        "option_a": "Índices.",
        "option_b": "Replica sets.",
        "option_c": "Query routers.",
        "option_d": "Las respuestas B y C son correctas.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "a",
        "explanation": "Los índices son elementos que permiten indexar los documentos de la base de datos para mejorar las búsquedas.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Qué característica de MongoDB permite tener redundancia y aumentar la disponibilidad de los datos?",
        "option_a": "Seguridad.",
        "option_b": "Sharding.",
        "option_c": "Índices.",
        "option_d": "Replicación.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Recuerda que la replicación es una característica de MongoDB que permite la redundancia de datos e incrementa su disponibilidad.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el modelo básico de replicación en MongoDB?",
        "option_a": "Sharding.",
        "option_b": "Replica set.",
        "option_c": "Maestro-Esclavo.",
        "option_d": "Shards.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "La arquitectura básica de replicación en MongoDB sigue un modelo Maestro-Esclavo.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Cómo se llama al refinamiento del modelo Maestro-Esclavo implementado en MongoDB?",
        "option_a": "Result set.",
        "option_b": "Replica set.",
        "option_c": "Sharding.",
        "option_d": "Replicación.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Este método permite una recuperación a fallos de forma automática, y es la forma recomendada de implementar replicación de datos en MongoDB.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Cómo se denomina al nodo de un replica set que no almacena datos y solamente puede votar en las elecciones de nodo primario?",
        "option_a": "Secundario.",
        "option_b": "Árbitro.",
        "option_c": "Shard.",
        "option_d": "Config server.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Este es utilizado solamente para decidir qué nodo debe ser asignado como primario.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Qué otro nombre recibe el método de escalabilidad horizontal, en el que los datos son separados y distribuidos entre varios servidores?",
        "option_a": "Escalabilidad vertical.",
        "option_b": "Elastic computing.",
        "option_c": "Sharding.",
        "option_d": "Replicación.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "c",
        "explanation": "Sharding o escalabilidad horizontal.",
        "dataset_reference": "N/A",
        "difficulty": "easy"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Qué nombre reciben los nodos que almacenan datos en un sharded cluster?",
        "option_a": "Data stores.",
        "option_b": "Config servers.",
        "option_c": "Query routers.",
        "option_d": "Shards.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "d",
        "explanation": "Están a cargo de almacenar la información. Cada shard es un replica set, por lo que brinda alta disponibilidad y consistencia de datos.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    },
    {
        "category_id": 14,
        "question_type": "conceptual",
        "question_text": "¿Cuántos config servers debe haber en un entorno de producción?",
        "option_a": "Uno.",
        "option_b": "Tres.",
        "option_c": "Un máximo de cinco.",
        "option_d": "Depende del número de servidores disponibles.",
        "option_e": "Ninguna de las anteriores.",
        "correct_answer": "b",
        "explanation": "Los sharded clusters en un entorno de producción tienen exactamente tres config servers.",
        "dataset_reference": "N/A",
        "difficulty": "medium"
    }
]

# ============================================================
# CATEGORÍA 15: TEST 6 - DRIVERS MONGODB
# ============================================================
# Preguntas extraídas del Test 6 del curso
# Total: 10 preguntas conceptuales

TEST_6_DRIVERS_MONGODB = [
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Cuál es el objetivo de un driver?", "option_a": "«Traducir» las llamadas que se hacen desde un lenguaje de programación a un «lenguaje» que entienda la base de datos.", "option_b": "Proporcionar un objeto de conexión.", "option_c": "Proporcionar una serie de «funciones» que permitan al programador interactuar con la base de datos.", "option_d": "Todas las anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Todas las afirmaciones anteriores son características de los drivers.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Dónde se debería acudir si se quiere desarrollar una aplicación con base de datos MongoDB para gestionar una conexión?", "option_a": "A la página oficial del lenguaje de programación con el que estamos desarrollando.", "option_b": "A la página de documentación oficial de MongoDB, en el apartado de drivers.", "option_c": "A la página oficial del sistema operativo donde estemos desarrollando.", "option_d": "Todas las anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "b", "explanation": "MongoDB proporciona información detallada de todos los drivers de conexión que existen, lo recomendable es utilizar dicha información para crear nuestras propias aplicaciones.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Cuál de los siguientes lenguajes de programación soporta MongoDB?", "option_a": "C.", "option_b": "Java.", "option_c": "PHP.", "option_d": "Todos los anteriores son correctos.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Los tres lenguajes soportan programar para MongoDB.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Cuál es la mejor forma de descargar el driver de Java?", "option_a": "Utilizando Maven.", "option_b": "Buscando en Google.", "option_c": "Repositorio.", "option_d": "Las respuestas A y C son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Tanto Maven como los repositorios oficiales ofrecen las librerías de Java necesarias para trabajar con MongoDB.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "Si no se especifica en el driver ningún parámetro, ¿dónde se realiza la conexión?", "option_a": "A localhost u puerto 27017.", "option_b": "Puerto 27017.", "option_c": "Localhost.", "option_d": "Es obligatorio definir un servidor y un puerto.", "option_e": "Ninguna de las anteriores.", "correct_answer": "a", "explanation": "Al instalar MongoDB, por defecto, este levanta una instancia de servidor en localhost sobre el puerto 27017. El driver por defecto conoce esta información y la usa para conectarse si el usuario no indica ninguna información de conexión diferente.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Cuál es el formato de documentos utilizado por el driver de Java?", "option_a": "BSON.", "option_b": "JSON.", "option_c": "CSV.", "option_d": "XML.", "option_e": "Ninguna de las anteriores.", "correct_answer": "a", "explanation": "Java utiliza el formato BSON para manipular los documentos de MongoDB.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Cuál es la mejor forma de instalar el driver de Node.js?", "option_a": "Usando Maven.", "option_b": "Buscando en Google.", "option_c": "Usando NPM.", "option_d": "Todas las anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "c", "explanation": "NPM es el instalador de paquetes útil para Node.js, por medio de este es posible instalar el driver para que Node.js conecte con MongoDB.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Qué es PyMongo?", "option_a": "Una base de datos NoSQL.", "option_b": "El driver de MongoDB para Python.", "option_c": "Una base de datos SQL.", "option_d": "El driver de lenguaje de programación Py.", "option_e": "Ninguna de las anteriores.", "correct_answer": "b", "explanation": "La librería de Python para trabajar y conectar con MongoDB se llama PyMongo.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Cómo podemos descargar el driver de Python para Mongo?", "option_a": "Utilizando NPM.", "option_b": "Utilizando Maven.", "option_c": "Buscando en Google.", "option_d": "Utilizando PIP.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "El driver de Python está disponible en el repositorio de paquetes de PIP, por ello es la forma más sencilla de instalar dicho driver para conectar con MongoDB desde Python.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 15, "question_type": "conceptual", "question_text": "¿Cuál de estos comandos son válidos para acceder a una colección de mongo?", "option_a": "db.myCollection", "option_b": "db['myCollection']", "option_c": "db.getCollection('myCollection')", "option_d": "Todas son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Todos los comandos anteriores permiten acceder a una colección en MongoDB.", "dataset_reference": "N/A", "difficulty": "medium"}
]

# ============================================================
# CATEGORÍA 16: TEST 7 - CASSANDRA
# ============================================================
# Preguntas extraídas del Test 7 del curso
# Total: 10 preguntas conceptuales

TEST_7_CASSANDRA = [
    {"category_id": 16, "question_type": "conceptual", "question_text": "Cassandra:", "option_a": "Es un sistema de almacenamiento de datos NoSQL desarrollado por Facebook.", "option_b": "Es un sistema de almacenamiento en tiempo real para aplicaciones en línea.", "option_c": "Está diseñado para manejar cargas de trabajo en múltiples nodos.", "option_d": "Todas las afirmaciones anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Todas estas afirmaciones definen lo que es Cassandra y lo que puede hacer como base de datos NoSQL.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "¿Cuáles son los componentes principales de Cassandra?", "option_a": "Cluster, keyspace, column y column & family.", "option_b": "Columna name, tables y keyspace.", "option_c": "Mem-Table, SSTable y Bloom Filter.", "option_d": "Las respuestas A y C son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "a", "explanation": "Además de los componentes que permiten el almacenamiento del dato y su manipulación, la tabla de memoria, la SSTable y BFilter son componentes claves que dan a Cassandra agilidad y robustez.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "¿Cuáles son las colecciones en CQL Cassandra?", "option_a": "Tupple, list y timestamp.", "option_b": "Map, list y set.", "option_c": "Counter, duration y date.", "option_d": "Ninguna respuesta anterior es correcta.", "option_e": "Ninguna de las anteriores.", "correct_answer": "b", "explanation": "Estas son las principales colecciones que utiliza Cassandra y que optimiza para facilitar su implementación en determinados contextos.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "¿Cuál es la principal característica de la colección list?", "option_a": "Almacenar datos de forma aleatoria.", "option_b": "Almacenar datos de forma ordenada y que se puedan repetir.", "option_c": "Almacenar elementos clave-valor.", "option_d": "Almacenar elementos para usarlos en un orden concreto.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Cuando el orden de los elementos importa, se utiliza list en Cassandra. La consulta de estos elementos es mediante su posición.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "¿Qué pasa con los datos eliminados en Cassandra?", "option_a": "Se borran inmediatamente de la base de datos.", "option_b": "Se almacenan temporalmente en la papelera de reciclaje de Cassandra.", "option_c": "Son marcados con una lápida.", "option_d": "Nunca se borran, están inactivos hasta que el usuario los vuelva a activar.", "option_e": "Ninguna de las anteriores.", "correct_answer": "c", "explanation": "Cassandra tiene un modo particular de eliminar los datos borrados. Estos no se eliminan de inmediato, sino que son marcados para que tareas posteriores se encarguen de su borrado real.", "dataset_reference": "N/A", "difficulty": "hard"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "¿Cuál de las siguientes afirmaciones es verdadera?", "option_a": "Cassandra escribe los datos en una caché clave-valor llamada Mem-Table.", "option_b": "Los datos en Mem-Table se ordenan por clave.", "option_c": "Existe una Mem-Table por cada ColumnFamily y de ella se recuperan los datos por la columna clave.", "option_d": "Todas las afirmaciones anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Las tres afirmaciones explican cómo utiliza Cassandra la memoria mediante la tabla Mem-Table.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "La instrucción ALTER KEYSPACE se puede utilizar para:", "option_a": "Definir un esquema.", "option_b": "Crear una tabla.", "option_c": "Ejecutar una consulta.", "option_d": "Modificar un keyspace.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "La instrucción ALTER modifica cualquier elemento que se indique a continuación, en este caso el keyspace.", "dataset_reference": "N/A", "difficulty": "easy"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "Al intentar borrar un elemento que no existe en una colección set, se produce:", "option_a": "La inserción de un nuevo elemento con dicho valor.", "option_b": "Un error en la operación de borrado.", "option_c": "Una operación que no se lleva a cabo y que tampoco genera error alguno.", "option_d": "Una mutación de la colección.", "option_e": "Ninguna de las anteriores.", "correct_answer": "c", "explanation": "No es un error intentar borrar un elemento que no existe en un set, simplemente la operación no se realiza y tampoco genera ningún mensaje de error.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "¿Qué es una UDT?", "option_a": "Un tipo de datos primitivo.", "option_b": "Un objeto con funciones especiales en Cassandra.", "option_c": "Un tipo de datos definido por el usuario.", "option_d": "Un proceso de carga de datos.", "option_e": "Ninguna de las anteriores.", "correct_answer": "c", "explanation": "La sigla UDT significa User Define Tupe, es decir, un tipo de datos definido por el usuario.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 16, "question_type": "conceptual", "question_text": "¿Cuál de las siguientes instrucciones es correcta?", "option_a": "select * from client.agent where dept='AB';", "option_b": "drop index IF EXISTS clients.DeptIndex;", "option_c": "insert into University.Teacher(id,Name,Email,Description) values (2, 'Hamilton',['hamilton@hotmail.com'], ['Data Science']);", "option_d": "Todas las instrucciones anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Todas las instrucciones son correctas en este caso.", "dataset_reference": "N/A", "difficulty": "hard"}
]

# ============================================================
# CATEGORÍA 17: TEST 8 - GRAFO (NEO4J)
# ============================================================
# Preguntas extraídas del Test 8 del curso
# Total: 10 preguntas conceptuales

TEST_8_GRAFO_NEO4J = [
    {"category_id": 17, "question_type": "conceptual", "question_text": "¿Cuáles son los principales componentes de un grafo?", "option_a": "El esquema, los nodos, las relaciones y las propiedades.", "option_b": "Nodos, relaciones y propiedades.", "option_c": "Nodos y relaciones, las propiedades están implícitas en cada uno.", "option_d": "Ninguna de las anteriores es correcta.", "option_e": "Ninguna de las anteriores.", "correct_answer": "b", "explanation": "Un grafo se representa principalmente por nodos, relaciones y propiedades. Otros elementos, como los esquemas, son propios del concepto de base de datos.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "¿Qué afirmación define las características principales del modelo de grafos?", "option_a": "El modelo representa datos en nodos, relaciones y propiedades.", "option_b": "Las propiedades son pares clave-valor.", "option_c": "Las relaciones conectan los nodos.", "option_d": "Todas las anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Todas las afirmaciones definen las características de Neo4j vistas en este tema.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "¿Qué es CQL?", "option_a": "El lenguaje de consulta para Neo4j Graph Database.", "option_b": "Un lenguaje para insertar y borrar nodos y relaciones.", "option_c": "Un lenguaje enfocado a encontrar solo nodos dentro de un grafo.", "option_d": "Todas las afirmaciones anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "a", "explanation": "CQL o Cypher Query Language es el lenguaje que utiliza Neo4j para la manipulación de grafos.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "¿Qué hace la siguiente instrucción: MATCH ( n ) DETACH DELETE n?", "option_a": "Limpia la base de datos.", "option_b": "Borra todos los nodos y relaciones de la base de datos.", "option_c": "Borra solo los nodos existentes.", "option_d": "Borra los nodos y sus propiedades.", "option_e": "Ninguna de las anteriores.", "correct_answer": "b", "explanation": "Cuidado, esta instrucción borra tanto nodos como relaciones de la base de datos. De igual forma, incluye las propiedades de ambos elementos.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "La cláusula que borra etiquetas y propiedades es:", "option_a": "DELETE.", "option_b": "UNWIND.", "option_c": "REMOVE.", "option_d": "DROP.", "option_e": "Ninguna de las anteriores.", "correct_answer": "c", "explanation": "REMOVE permite eliminar tanto las etiquetas como las propiedades de nodos y relaciones. DELETE borra nodos o relaciones y DROP no existe en Neo4j.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "¿Qué significa n en la siguiente instrucción: MATCH ( n ) RETURN n.name, n.runs ORDER BY n.runs?", "option_a": "Cualquier nodo y relación.", "option_b": "Cualquier nodo.", "option_c": "Cualquier relación con las propiedades name y runs.", "option_d": "Los nodos cuya propiedad name tiene un valor.", "option_e": "Ninguna de las anteriores.", "correct_answer": "a", "explanation": "n representa cualquier nodo relacionado con otros nodos.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "¿La instrucción MATCH ( n ) RETURN n.name order by n.name qué retorna?", "option_a": "Un grafo con los nodos n.", "option_b": "Un listado.", "option_c": "Un listado y un grafo.", "option_d": "Una lista ordenada de las propiedades nombre de todos los nodos.", "option_e": "Ninguna de las anteriores.", "correct_answer": "d", "explanation": "Al igual que en SQL, order by ordena un resultado, en este caso el retorno en la lista de nombres ordenada ascendentemente por defecto.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "¿La instrucción CREATE (Pepe)-[r:CANTA_EN{name=\"Padre\"}]-(Concierto) genera algún tipo de error al ser ejecutada?", "option_a": "No, crea los nodos Pepe y Concierto y su relación CANTAEN.", "option_b": "Sí, la propiedad de la relación es incorrecta.", "option_c": "Sí, no se indica una dirección o sentido de la relación.", "option_d": "Todas las respuestas anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "c", "explanation": "Siempre es necesario indicar el sentido de la relación. Si este no se indica, Neo4j genera un error preguntando por esta definición.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "La instrucción CREATE (Juan)-[r:HIJO_DE]->(Alma) crea:", "option_a": "Los nodos Juan y Alma y una relación entre ellos llamada HIJO_DE.", "option_b": "Una relación entre los nodos Juan y Alma llamada HIJO_DE.", "option_c": "Una relación saliente de Juan hacia Ana llamada HIJO_DE.", "option_d": "Ninguna de las anteriores es correcta.", "option_e": "Ninguna de las anteriores.", "correct_answer": "a", "explanation": "Juan y Alma son nodos, aunque existan se crearán dichos nodos y ambos se le asignará la relación HIJO_DE.", "dataset_reference": "N/A", "difficulty": "medium"},
    {"category_id": 17, "question_type": "conceptual", "question_text": "Indica qué hace la siguiente instrucción: MATCH (a:Jugador), (b:Juego) WHERE a.name = \"Rabino\" AND b.name = \"Casino\" CREATE (a)-[r:TRABAJA_EN {partida1: victorias:5}]->(b) RETURN a,b", "option_a": "Crea los nodos a y b y asigna la relación TRABAJA_EN.", "option_b": "Crea la relación TRABAJA_EN sobre los nodos a y b.", "option_c": "Busca los nodos a y b que cumplan la condición del WHERE y luego asigna la relación TRABAJA_EN entre ellos.", "option_d": "Todas las respuestas anteriores son correctas.", "option_e": "Ninguna de las anteriores.", "correct_answer": "c", "explanation": "Al ejecutarse juntas MATCH y CREATE, los nodos que cumplan la condición WHERE serán quienes reciban la relación que se indica en el CREATE.", "dataset_reference": "N/A", "difficulty": "hard"}
]

# Total acumulado: 600 preguntas (520 originales + 80 tests) ✅✅✅✅

# ============================================================
# COMPILACIÓN FINAL DE TODAS LAS PREGUNTAS
# ============================================================

ALL_QUESTIONS = (
    QUESTIONS_BATCH_1 +
    QUESTIONS_BATCH_2 +
    QUESTIONS_BATCH_3 +
    QUESTIONS_BATCH_4 +
    QUESTIONS_BATCH_5 +
    QUESTIONS_BATCH_6 +
    QUESTIONS_BATCH_7 +
    QUESTIONS_BATCH_8 +
    QUESTIONS_BATCH_9 +
    QUESTIONS_BATCH_10 +
    FINAL_BATCH +
    TEST_1_FUNDAMENTOS_DATOS +
    TEST_2_NOSQL_MONGODB +
    TEST_3_MONGODB_CRUD +
    TEST_4_AGREGACION_MONGODB +
    TEST_5_BACKUP_INDICES_REPLICACION +
    TEST_6_DRIVERS_MONGODB +
    TEST_7_CASSANDRA +
    TEST_8_GRAFO_NEO4J
)

# Función auxiliar para obtener todas las preguntas
def get_all_questions():
    """Retorna la lista completa de 600 preguntas (520 originales + 80 de tests)"""
    return ALL_QUESTIONS

# Función para obtener preguntas por categoría
def get_questions_by_category(category_id):
    """Retorna preguntas filtradas por categoría"""
    return [q for q in ALL_QUESTIONS if q['category_id'] == category_id]

# Función para obtener estadísticas del banco de preguntas
def get_question_stats():
    """Retorna estadísticas del banco de preguntas"""
    stats = {
        'total': len(ALL_QUESTIONS),
        'by_category': {},
        'by_type': {'conceptual': 0, 'syntax': 0},
        'by_difficulty': {'easy': 0, 'medium': 0, 'hard': 0}
    }

    for question in ALL_QUESTIONS:
        # Por categoría
        cat_id = question['category_id']
        if cat_id not in stats['by_category']:
            stats['by_category'][cat_id] = 0
        stats['by_category'][cat_id] += 1

        # Por tipo
        stats['by_type'][question['question_type']] += 1

        # Por dificultad
        stats['by_difficulty'][question['difficulty']] += 1

    return stats

# Verificación final
if __name__ == "__main__":
    stats = get_question_stats()
    print(f"Total de preguntas: {stats['total']}")
    print("\nPor categoría:")
    for cat_id, count in sorted(stats['by_category'].items()):
        print(f"  Categoría {cat_id}: {count} preguntas")
    print("\nPor tipo:")
    for q_type, count in stats['by_type'].items():
        print(f"  {q_type}: {count} preguntas")
    print("\nPor dificultad:")
    for diff, count in stats['by_difficulty'].items():
        print(f"  {diff}: {count} preguntas")
