"""
question_bank.py - Banco de preguntas para MongoDB Quiz System
Total aproximado: ~520 preguntas distribuidas en 9 categorías

Progreso: 50/520 preguntas
"""

# Categoría 1: Instalación y Entorno (30 preguntas)
# Categoría 2: CRUD - Create (20/60 preguntas)

QUESTIONS_BATCH_1 = [
    # ==================== CATEGORÍA 1: INSTALACIÓN Y ENTORNO ====================
    # Preguntas 1-30

    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué tipo de base de datos es MongoDB?",
        "option_a": "Base de datos relacional",
        "option_b": "Base de datos orientada a documentos NoSQL",
        "option_c": "Base de datos de grafos",
        "option_d": "Base de datos en memoria",
        "option_e": "Base de datos de columnas anchas",
        "correct_answer": "b",
        "explanation": "MongoDB es una base de datos NoSQL orientada a documentos que almacena datos en formato BSON (Binary JSON). No usa tablas y relaciones como las bases de datos SQL tradicionales, sino colecciones de documentos flexibles.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el formato de almacenamiento de documentos en MongoDB?",
        "option_a": "XML",
        "option_b": "CSV",
        "option_c": "BSON (Binary JSON)",
        "option_d": "YAML",
        "option_e": "Plain Text",
        "correct_answer": "c",
        "explanation": "MongoDB almacena documentos en formato BSON (Binary JSON), que es una representación binaria de JSON. BSON extiende JSON con tipos de datos adicionales como Date, ObjectId, y Binary, y permite un almacenamiento más eficiente.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es una colección en MongoDB?",
        "option_a": "Un grupo de bases de datos",
        "option_b": "Un conjunto de documentos similar a una tabla en SQL",
        "option_c": "Un índice para búsquedas rápidas",
        "option_d": "Un tipo de dato especial",
        "option_e": "Una función de agregación",
        "correct_answer": "b",
        "explanation": "Una colección en MongoDB es equivalente a una tabla en bases de datos relacionales. Agrupa documentos relacionados, pero a diferencia de las tablas SQL, los documentos en una colección pueden tener estructuras diferentes (esquema flexible).",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la ventaja principal del esquema flexible de MongoDB?",
        "option_a": "Mayor velocidad de consulta",
        "option_b": "Menor uso de memoria",
        "option_c": "No requiere definir estructura fija antes de insertar datos",
        "option_d": "Mejor seguridad de datos",
        "option_e": "Compatibilidad con SQL estándar",
        "correct_answer": "c",
        "explanation": "El esquema flexible de MongoDB permite insertar documentos sin definir previamente su estructura. Cada documento en una colección puede tener campos diferentes, facilitando la evolución del modelo de datos sin necesidad de migraciones complejas.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es MongoDB Atlas?",
        "option_a": "Un cliente de escritorio para MongoDB",
        "option_b": "Una herramienta de visualización de datos",
        "option_c": "Un servicio de MongoDB en la nube totalmente gestionado",
        "option_d": "Un lenguaje de consulta para MongoDB",
        "option_e": "Una librería de Python para MongoDB",
        "correct_answer": "c",
        "explanation": "MongoDB Atlas es el servicio de base de datos como servicio (DBaaS) en la nube de MongoDB. Proporciona despliegue, gestión y escalado automático de clusters MongoDB en proveedores cloud como AWS, Azure y Google Cloud.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué puerto utiliza MongoDB por defecto?",
        "option_a": "3306",
        "option_b": "5432",
        "option_c": "27017",
        "option_d": "8080",
        "option_e": "27018",
        "correct_answer": "c",
        "explanation": "MongoDB utiliza el puerto 27017 por defecto para las conexiones de clientes. El puerto 27018 se usa típicamente para el daemon mongos en configuraciones de sharding, y 27019 para el config server.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué comando se usa para iniciar el shell de MongoDB?",
        "option_a": "mongodb",
        "option_b": "mongo",
        "option_c": "mongosh",
        "option_d": "start-mongo",
        "option_e": "db.start()",
        "correct_answer": "c",
        "explanation": "El comando 'mongosh' (MongoDB Shell) es el shell interactivo moderno de MongoDB. Anteriormente se usaba 'mongo', pero desde la versión 5.0+ se recomienda usar mongosh que ofrece mejor funcionalidad y compatibilidad con JavaScript moderno.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra todas las bases de datos en MongoDB?",
        "option_a": "db.showDatabases()",
        "option_b": "show databases",
        "option_c": "list databases",
        "option_d": "db.getDatabases()",
        "option_e": "display dbs",
        "correct_answer": "b",
        "explanation": "El comando 'show databases' o su alias 'show dbs' muestra todas las bases de datos en el servidor MongoDB. Es un comando del shell, no una función de JavaScript. También existe 'db.adminCommand({listDatabases: 1})' para uso programático.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se selecciona o crea una base de datos en MongoDB?",
        "option_a": "CREATE DATABASE nombre",
        "option_b": "use nombre",
        "option_c": "db.create('nombre')",
        "option_d": "select nombre",
        "option_e": "new database nombre",
        "correct_answer": "b",
        "explanation": "El comando 'use nombre' cambia a una base de datos. Si la base de datos no existe, MongoDB la creará automáticamente cuando insertes el primer documento. No es necesario un comando CREATE DATABASE explícito.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra la base de datos actual en uso?",
        "option_a": "show current",
        "option_b": "db.getName()",
        "option_c": "db",
        "option_d": "current db",
        "option_e": "which database",
        "correct_answer": "c",
        "explanation": "El comando 'db' en el shell de MongoDB muestra el nombre de la base de datos actualmente seleccionada. Es la forma más rápida de verificar en qué base de datos estás trabajando.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se muestran todas las colecciones de la base de datos actual?",
        "option_a": "list collections",
        "option_b": "show collections",
        "option_c": "db.showCollections()",
        "option_d": "display tables",
        "option_e": "get collections",
        "correct_answer": "b",
        "explanation": "El comando 'show collections' muestra todas las colecciones en la base de datos actual. Alternativamente, puedes usar 'show tables' (que es un alias) o 'db.getCollectionNames()' para obtener un array con los nombres.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es un documento en MongoDB?",
        "option_a": "Un archivo PDF almacenado en la base de datos",
        "option_b": "Una fila en una tabla",
        "option_c": "Un registro en formato BSON con pares clave-valor",
        "option_d": "Un esquema de validación",
        "option_e": "Una función JavaScript",
        "correct_answer": "c",
        "explanation": "Un documento en MongoDB es una estructura de datos compuesta por pares clave-valor, similar a objetos JSON. Es la unidad básica de datos en MongoDB, equivalente a una fila en SQL, pero con estructura flexible y capacidad de anidar datos.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el _id en MongoDB?",
        "option_a": "Un índice secundario opcional",
        "option_b": "El campo de clave primaria único y obligatorio para cada documento",
        "option_c": "Un identificador de colección",
        "option_d": "Una función para generar IDs",
        "option_e": "Un campo de auditoría",
        "correct_answer": "b",
        "explanation": "El campo _id es la clave primaria de cada documento en MongoDB. Es obligatorio, único dentro de una colección, e inmutable. Si no se proporciona al insertar, MongoDB genera automáticamente un ObjectId de 12 bytes.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la estructura de un ObjectId en MongoDB?",
        "option_a": "UUID estándar de 36 caracteres",
        "option_b": "Entero autoincremental",
        "option_c": "Valor hexadecimal de 24 caracteres (12 bytes)",
        "option_d": "Hash MD5",
        "option_e": "GUID de Windows",
        "correct_answer": "c",
        "explanation": "Un ObjectId es un valor BSON de 12 bytes que se representa como una cadena hexadecimal de 24 caracteres. Incluye timestamp (4 bytes), identificador de máquina (5 bytes), y un contador incremental (3 bytes), lo que garantiza su unicidad.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué ventaja tiene MongoDB sobre bases de datos SQL tradicionales en términos de escalabilidad?",
        "option_a": "Solo puede escalarse verticalmente",
        "option_b": "Escalabilidad horizontal nativa mediante sharding",
        "option_c": "No soporta escalabilidad",
        "option_d": "Requiere hardware especializado para escalar",
        "option_e": "Solo funciona en un único servidor",
        "correct_answer": "b",
        "explanation": "MongoDB soporta escalabilidad horizontal mediante sharding, distribuyendo datos automáticamente entre múltiples servidores. Esto permite manejar grandes volúmenes de datos y tráfico sin las limitaciones de escalado vertical de bases de datos SQL tradicionales.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué herramienta de línea de comandos se usa para importar datos JSON a MongoDB?",
        "option_a": "mongodump",
        "option_b": "mongoimport",
        "option_c": "mongorestore",
        "option_d": "mongoexport",
        "option_e": "mongoload",
        "correct_answer": "b",
        "explanation": "mongoimport es la herramienta para importar datos desde archivos JSON, CSV o TSV a MongoDB. Ejemplo: 'mongoimport --db basedatos --collection coleccion --file datos.json'. mongodump/mongorestore se usan para backups BSON.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para exportar una colección completa a JSON?",
        "option_a": "mongodump --db basedatos --collection coleccion",
        "option_b": "mongoexport --db basedatos --collection coleccion --out archivo.json",
        "option_c": "db.coleccion.export('archivo.json')",
        "option_d": "mongosave --collection coleccion --file archivo.json",
        "option_e": "export --from coleccion --to archivo.json",
        "correct_answer": "b",
        "explanation": "mongoexport se usa para exportar datos en formato JSON o CSV. La sintaxis incluye --db para la base de datos, --collection para la colección, y --out para el archivo de salida. mongodump exporta en formato BSON para backups.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es un replica set en MongoDB?",
        "option_a": "Un conjunto de colecciones duplicadas",
        "option_b": "Un grupo de instancias MongoDB que mantienen el mismo conjunto de datos para alta disponibilidad",
        "option_c": "Una técnica de indexación",
        "option_d": "Un backup automático",
        "option_e": "Un tipo de consulta optimizada",
        "correct_answer": "b",
        "explanation": "Un replica set es un grupo de procesos mongod que mantienen el mismo conjunto de datos. Proporciona redundancia y alta disponibilidad mediante replicación automática. Incluye un nodo primario (escrituras) y múltiples secundarios (réplicas).",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia principal entre MongoDB y bases de datos SQL?",
        "option_a": "MongoDB no soporta consultas complejas",
        "option_b": "MongoDB usa esquema flexible y no requiere JOINs tradicionales",
        "option_c": "SQL es más rápido para todos los casos de uso",
        "option_d": "MongoDB no puede almacenar datos estructurados",
        "option_e": "SQL no soporta índices",
        "correct_answer": "b",
        "explanation": "La diferencia clave es que MongoDB usa un modelo de datos basado en documentos con esquema flexible, mientras SQL usa tablas con esquema fijo. MongoDB evita JOINs costosos mediante documentos embebidos y referencias, optimizando para lecturas.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuándo NO es recomendable usar MongoDB?",
        "option_a": "Cuando necesitas esquema flexible",
        "option_b": "Cuando requieres transacciones ACID complejas entre múltiples tablas relacionales",
        "option_c": "Cuando trabajas con datos JSON",
        "option_d": "Cuando necesitas escalabilidad horizontal",
        "option_e": "Cuando trabajas con documentos anidados",
        "correct_answer": "b",
        "explanation": "MongoDB no es ideal para aplicaciones que requieren transacciones ACID complejas entre múltiples entidades altamente relacionadas con muchos JOINs. Aunque MongoDB 4.0+ soporta transacciones multi-documento, bases de datos SQL tradicionales siguen siendo mejores para estos casos.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el Write Concern en MongoDB?",
        "option_a": "Un nivel de logging de errores",
        "option_b": "El nivel de confirmación requerido para operaciones de escritura",
        "option_c": "Un tipo de índice",
        "option_d": "Una validación de esquema",
        "option_e": "Un patrón de diseño",
        "correct_answer": "b",
        "explanation": "Write Concern es el nivel de confirmación requerido de MongoDB para operaciones de escritura. Define cuántos nodos del replica set deben confirmar la escritura antes de considerarla exitosa. Valores comunes: {w: 1} (solo primario), {w: 'majority'} (mayoría).",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el Read Concern en MongoDB?",
        "option_a": "La cantidad de documentos que se pueden leer",
        "option_b": "El nivel de garantía sobre la durabilidad de los datos leídos",
        "option_c": "El tiempo máximo de espera para lecturas",
        "option_d": "Un filtro de lectura",
        "option_e": "Una validación de datos",
        "correct_answer": "b",
        "explanation": "Read Concern controla el nivel de consistencia de los datos leídos en operaciones de consulta. Niveles incluyen: 'local' (datos más recientes del nodo), 'majority' (datos reconocidos por la mayoría), 'linearizable' (garantía de lectura más fuerte).",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se elimina una base de datos completa en MongoDB?",
        "option_a": "DROP DATABASE nombre",
        "option_b": "db.dropDatabase()",
        "option_c": "delete database nombre",
        "option_d": "db.remove()",
        "option_e": "destroy db nombre",
        "correct_answer": "b",
        "explanation": "El método db.dropDatabase() elimina la base de datos actual y todas sus colecciones. Primero debes usar 'use nombre_bd' para seleccionar la base de datos, luego ejecutar db.dropDatabase(). Esta operación es irreversible.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra las estadísticas de una base de datos?",
        "option_a": "db.status()",
        "option_b": "db.stats()",
        "option_c": "show stats",
        "option_d": "db.info()",
        "option_e": "database statistics",
        "correct_answer": "b",
        "explanation": "db.stats() devuelve estadísticas sobre la base de datos actual, incluyendo número de colecciones, vistas, objetos, tamaño promedio de documentos, tamaño de datos, índices, etc. Útil para monitoreo y optimización.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es WiredTiger en MongoDB?",
        "option_a": "Una herramienta de migración de datos",
        "option_b": "El motor de almacenamiento por defecto desde MongoDB 3.2",
        "option_c": "Un cliente GUI para MongoDB",
        "option_d": "Un protocolo de red",
        "option_e": "Una librería de validación",
        "correct_answer": "b",
        "explanation": "WiredTiger es el motor de almacenamiento por defecto de MongoDB desde la versión 3.2. Proporciona compresión de datos, concurrencia a nivel de documento, y mejor rendimiento que el motor MMAPv1 anterior. Soporta snapshots y checkpoints.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué formato de compresión usa WiredTiger por defecto?",
        "option_a": "gzip",
        "option_b": "snappy",
        "option_c": "lz4",
        "option_d": "zlib",
        "option_e": "bzip2",
        "correct_answer": "b",
        "explanation": "WiredTiger usa Snappy como algoritmo de compresión por defecto para colecciones. Snappy ofrece un buen balance entre velocidad y ratio de compresión. Para índices, usa compresión prefix. También soporta zlib y zstd para mayor compresión.",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se verifica la versión de MongoDB instalada?",
        "option_a": "mongodb --version",
        "option_b": "mongod --version",
        "option_c": "mongo --ver",
        "option_d": "show version",
        "option_e": "db.getVersion()",
        "correct_answer": "b",
        "explanation": "El comando 'mongod --version' muestra la versión del servidor MongoDB instalado. En el shell, puedes usar 'db.version()' o 'mongosh --version' para ver la versión del shell. También 'db.serverBuildInfo()' da información detallada.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el oplog en MongoDB?",
        "option_a": "Un archivo de log de errores",
        "option_b": "Una colección especial que registra todas las operaciones de escritura para replicación",
        "option_c": "Una herramienta de monitoreo",
        "option_d": "Un índice automático",
        "option_e": "Un comando de optimización",
        "correct_answer": "b",
        "explanation": "El oplog (operations log) es una colección capped especial que registra todas las operaciones que modifican datos. Los nodos secundarios de un replica set leen el oplog del primario para replicar los cambios. Es circular y tiene tamaño fijo.",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué puerto usa MongoDB Compass por defecto para conectarse?",
        "option_a": "27016",
        "option_b": "27017",
        "option_c": "28017",
        "option_d": "8080",
        "option_e": "3000",
        "correct_answer": "b",
        "explanation": "MongoDB Compass, la GUI oficial de MongoDB, se conecta por defecto al puerto 27017, que es el puerto estándar del servidor MongoDB. Compass proporciona una interfaz visual para explorar datos, crear consultas y analizar rendimiento.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el sharding en MongoDB?",
        "option_a": "Un método de backup incremental",
        "option_b": "Un método de particionamiento horizontal de datos entre múltiples máquinas",
        "option_c": "Una técnica de indexación",
        "option_d": "Un tipo de validación de datos",
        "option_e": "Un algoritmo de compresión",
        "correct_answer": "b",
        "explanation": "Sharding es el método de MongoDB para distribuir datos horizontalmente entre múltiples máquinas (shards). Permite escalar más allá de los límites de un solo servidor dividiendo la colección en chunks distribuidos según una shard key.",
        "difficulty": "medium"
    },

    # ==================== CATEGORÍA 2: CRUD - CREATE ====================
    # Preguntas 31-50 (20 de 60 totales)

    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para insertar un documento en MongoDB?",
        "option_a": "db.coleccion.add({campo: 'valor'})",
        "option_b": "db.coleccion.insertOne({campo: 'valor'})",
        "option_c": "db.coleccion.create({campo: 'valor'})",
        "option_d": "INSERT INTO coleccion VALUES ({campo: 'valor'})",
        "option_e": "db.coleccion.put({campo: 'valor'})",
        "correct_answer": "b",
        "explanation": "db.coleccion.insertOne({documento}) es el método correcto para insertar un único documento en MongoDB. Retorna un objeto con el _id del documento insertado. Si el documento no tiene _id, MongoDB genera uno automáticamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se insertan múltiples documentos a la vez en MongoDB?",
        "option_a": "db.coleccion.insertOne([{}, {}])",
        "option_b": "db.coleccion.insertMany([{}, {}])",
        "option_c": "db.coleccion.insertAll([{}, {}])",
        "option_d": "db.coleccion.bulkInsert([{}, {}])",
        "option_e": "db.coleccion.addMany([{}, {}])",
        "correct_answer": "b",
        "explanation": "db.coleccion.insertMany([array_de_documentos]) inserta múltiples documentos en una sola operación. Es más eficiente que múltiples insertOne(). Retorna un objeto con los _id de todos los documentos insertados.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para el dataset infovuelos_limpio, ¿cuál es la sintaxis correcta para insertar un nuevo vuelo?",
        "option_a": "db.infovuelos.insert({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_b": "db.infovuelos_limpio.insertOne({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_c": "INSERT INTO infovuelos_limpio VALUES ('Madrid', 'Barcelona', 150)",
        "option_d": "db.infovuelos_limpio.add({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_e": "db.infovuelos_limpio.create({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "correct_answer": "b",
        "explanation": "db.infovuelos_limpio.insertOne({documento}) es la sintaxis correcta. Usa el nombre exacto de la colección (infovuelos_limpio) y el método insertOne() con un objeto conteniendo los campos del vuelo. El método insert() está deprecado.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué sucede si intentas insertar un documento con un _id que ya existe?",
        "option_a": "Se actualiza el documento existente",
        "option_b": "Se genera un error de duplicate key",
        "option_c": "Se ignora silenciosamente",
        "option_d": "Se crea un nuevo documento con _id diferente",
        "option_e": "Se elimina el documento anterior",
        "correct_answer": "b",
        "explanation": "MongoDB genera un error 'E11000 duplicate key error' si intentas insertar un documento con un _id que ya existe en la colección. El _id debe ser único. Para actualizar, debes usar updateOne() o replaceOne().",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para insertar un listing en la colección listings_limpio con campos anidados, ¿cuál es correcto?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Apartamento', ubicacion: {ciudad: 'Madrid', barrio: 'Centro'}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Apartamento', ubicacion.ciudad: 'Madrid'})",
        "option_c": "db.listings_limpio.insertOne([nombre: 'Apartamento', ubicacion: [ciudad: 'Madrid']])",
        "option_d": "INSERT INTO listings_limpio (nombre, ubicacion) VALUES ('Apartamento', 'Madrid, Centro')",
        "option_e": "db.listings_limpio.add(nombre='Apartamento', ubicacion={'Madrid', 'Centro'})",
        "correct_answer": "a",
        "explanation": "MongoDB permite documentos anidados usando objetos JavaScript. La sintaxis correcta es {campo: {subcampo: valor}}. Esto crea una estructura jerárquica donde ubicacion es un objeto con propiedades ciudad y barrio.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con un array de valores?",
        "option_a": "db.coleccion.insertOne({tags: ['tag1', 'tag2', 'tag3']})",
        "option_b": "db.coleccion.insertOne({tags: 'tag1, tag2, tag3'})",
        "option_c": "db.coleccion.insertOne({tags: {0: 'tag1', 1: 'tag2'}})",
        "option_d": "db.coleccion.insertOne({tags: SET['tag1', 'tag2']})",
        "option_e": "db.coleccion.insertOne({tags: ARRAY('tag1', 'tag2')})",
        "correct_answer": "a",
        "explanation": "En MongoDB, los arrays se insertan usando la sintaxis de arrays JavaScript: [valor1, valor2, ...]. MongoDB soporta arrays nativamente como tipo de dato BSON, permitiendo almacenar listas de valores en un solo campo.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cuál es la diferencia entre insert() e insertOne()?",
        "option_a": "No hay diferencia, son sinónimos",
        "option_b": "insertOne() es el método moderno recomendado; insert() está deprecado",
        "option_c": "insert() es más rápido",
        "option_d": "insertOne() solo funciona en MongoDB Atlas",
        "option_e": "insert() requiere permisos de administrador",
        "correct_answer": "b",
        "explanation": "insertOne() e insertMany() son los métodos modernos introducidos en MongoDB 3.2+. El método insert() está deprecado. Los métodos nuevos tienen mejor manejo de errores, retornan objetos más consistentes y son más explícitos en su propósito.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento especificando un _id personalizado?",
        "option_a": "db.coleccion.insertOne({_id: 'mi_id_custom', nombre: 'valor'})",
        "option_b": "db.coleccion.insertOne({nombre: 'valor'}).setId('mi_id_custom')",
        "option_c": "db.coleccion.insertOne({nombre: 'valor'}, {_id: 'mi_id_custom'})",
        "option_d": "No es posible, MongoDB siempre genera el _id",
        "option_e": "db.coleccion.insertWithId('mi_id_custom', {nombre: 'valor'})",
        "correct_answer": "a",
        "explanation": "Puedes especificar tu propio _id incluyéndolo en el documento: {_id: valor, ...}. El _id puede ser cualquier tipo BSON excepto arrays. Si no proporcionas _id, MongoDB genera un ObjectId automáticamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para el dataset data_act_01_limpio, ¿cómo insertarías un documento con fecha actual?",
        "option_a": "db.data_act_01_limpio.insertOne({fecha: Date.now()})",
        "option_b": "db.data_act_01_limpio.insertOne({fecha: new Date()})",
        "option_c": "db.data_act_01_limpio.insertOne({fecha: CURRENT_TIMESTAMP})",
        "option_d": "db.data_act_01_limpio.insertOne({fecha: today()})",
        "option_e": "db.data_act_01_limpio.insertOne({fecha: '2024-01-21'})",
        "correct_answer": "b",
        "explanation": "new Date() crea un objeto Date de JavaScript que MongoDB almacena como tipo BSON Date. Date.now() retorna un timestamp numérico (no recomendado). Las cadenas de texto no son fechas tipadas. BSON Date permite consultas y operaciones temporales eficientes.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué retorna el método insertOne() tras una inserción exitosa?",
        "option_a": "El documento completo insertado",
        "option_b": "Un objeto con acknowledged: true y insertedId con el _id",
        "option_c": "El número de documentos insertados",
        "option_d": "true o false",
        "option_e": "Nada (void)",
        "correct_answer": "b",
        "explanation": "insertOne() retorna un objeto con dos propiedades: 'acknowledged' (boolean indicando si la operación fue reconocida) y 'insertedId' (el _id del documento insertado). Ejemplo: {acknowledged: true, insertedId: ObjectId('...')}",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué retorna insertMany() cuando inserta 5 documentos exitosamente?",
        "option_a": "Un array con los 5 documentos",
        "option_b": "Un objeto con acknowledged: true e insertedIds: {0: id1, 1: id2, ...}",
        "option_c": "El número 5",
        "option_d": "Los ObjectIds separados por comas",
        "option_e": "true",
        "correct_answer": "b",
        "explanation": "insertMany() retorna un objeto con 'acknowledged' (boolean) e 'insertedIds' (un objeto/mapa donde las keys son índices y los valores son los _id insertados). Ejemplo: {acknowledged: true, insertedIds: {0: ObjectId('...'), 1: ObjectId('...')}}",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es la opción 'ordered' en insertMany()?",
        "option_a": "Ordena los documentos alfabéticamente antes de insertar",
        "option_b": "Controla si la inserción se detiene en el primer error (true) o continúa (false)",
        "option_c": "Define el orden de los índices",
        "option_d": "Ordena por _id automáticamente",
        "option_e": "Requiere que los documentos estén ordenados por timestamp",
        "correct_answer": "b",
        "explanation": "La opción 'ordered: true' (default) detiene la inserción al primer error. Con 'ordered: false', MongoDB intenta insertar todos los documentos, omitiendo los que causan error. Útil para inserciones masivas donde algunos documentos pueden fallar.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples vuelos en infovuelos_limpio con ordered: false?",
        "option_a": "db.infovuelos_limpio.insertMany([{...}, {...}], {ordered: false})",
        "option_b": "db.infovuelos_limpio.insertMany([{...}, {...}], ordered=false)",
        "option_c": "db.infovuelos_limpio.insertMany([{...}, {...}]).unordered()",
        "option_d": "db.infovuelos_limpio.bulkInsert([{...}, {...}], false)",
        "option_e": "db.infovuelos_limpio.insertMany([{...}, {...}], {mode: 'unordered'})",
        "correct_answer": "a",
        "explanation": "La sintaxis correcta es insertMany(array_documentos, opciones). Las opciones se pasan como segundo parámetro en un objeto: {ordered: false}. Esto hace que MongoDB intente insertar todos los documentos incluso si algunos fallan.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite de tamaño máximo de un documento en MongoDB?",
        "option_a": "1 MB",
        "option_b": "8 MB",
        "option_c": "16 MB",
        "option_d": "32 MB",
        "option_e": "No hay límite",
        "correct_answer": "c",
        "explanation": "MongoDB tiene un límite de 16 MB por documento. Este límite previene uso excesivo de memoria y ancho de banda. Para datos más grandes, usa GridFS que divide archivos en chunks. El límite se aplica al documento BSON completo.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con un campo que contiene un objeto complejo en listings_limpio?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: {habitaciones: 3, banos: 2, amenidades: ['wifi', 'parking']}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Casa', detalles.habitaciones: 3, detalles.banos: 2})",
        "option_c": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: JSON.stringify({habitaciones: 3})})",
        "option_d": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: OBJECT(habitaciones=3, banos=2)})",
        "option_e": "db.listings_limpio.insertOne(nombre='Casa', detalles={habitaciones:3})",
        "correct_answer": "a",
        "explanation": "MongoDB soporta objetos anidados arbitrariamente complejos. Puedes incluir objetos dentro de objetos, arrays dentro de objetos, etc. La sintaxis es JavaScript estándar. No necesitas stringify, MongoDB maneja la estructura nativa.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede si insertas un documento sin especificar ningún campo?",
        "option_a": "MongoDB rechaza el documento vacío",
        "option_b": "Se inserta un documento con solo el _id",
        "option_c": "Se genera un error de validación",
        "option_d": "Se crea un documento con campos null",
        "option_e": "La colección se elimina",
        "correct_answer": "b",
        "explanation": "MongoDB permite insertar documentos vacíos: db.coleccion.insertOne({}). Se creará un documento con solo el campo _id generado automáticamente. Esto es válido aunque poco práctico en la mayoría de casos de uso.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con WriteConcern 'majority' para garantizar replicación?",
        "option_a": "db.coleccion.insertOne({...}, {w: 'majority'})",
        "option_b": "db.coleccion.insertOne({...}, {writeConcern: 'majority'})",
        "option_c": "db.coleccion.insertOne({...}, {replicate: 'all'})",
        "option_d": "db.coleccion.insertOne({...}).majority()",
        "option_e": "db.coleccion.insertOne({...}, {durability: 'high'})",
        "correct_answer": "a",
        "explanation": "El WriteConcern se especifica como opción con la propiedad 'w'. {w: 'majority'} espera confirmación de la mayoría de nodos del replica set antes de retornar. Aumenta durabilidad pero reduce performance. {w: 1} solo espera al nodo primario (default).",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'bulk write' en MongoDB?",
        "option_a": "Una operación de escritura masiva con múltiples tipos de operaciones (insert, update, delete) en una sola llamada",
        "option_b": "Un método para escribir archivos grandes",
        "option_c": "Una técnica de compresión de datos",
        "option_d": "Un tipo especial de índice",
        "option_e": "Una herramienta de backup",
        "correct_answer": "a",
        "explanation": "bulkWrite() permite ejecutar múltiples operaciones (insertOne, updateOne, deleteOne, etc.) en una sola llamada al servidor. Es más eficiente que múltiples operaciones individuales. Soporta modo ordenado y no ordenado.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con un campo de tipo NumberDecimal?",
        "option_a": "db.data_act_01_limpio.insertOne({precio: 99.99})",
        "option_b": "db.data_act_01_limpio.insertOne({precio: NumberDecimal('99.99')})",
        "option_c": "db.data_act_01_limpio.insertOne({precio: new Decimal(99.99)})",
        "option_d": "db.data_act_01_limpio.insertOne({precio: DECIMAL(99.99)})",
        "option_e": "db.data_act_01_limpio.insertOne({precio: parseDecimal('99.99')})",
        "correct_answer": "b",
        "explanation": "NumberDecimal('string') es el constructor para el tipo Decimal128 de BSON, diseñado para cálculos financieros precisos. Números normales se almacenan como Double (64-bit) que pueden tener imprecisiones. NumberDecimal evita errores de redondeo.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué ventaja tiene usar insertMany() sobre múltiples insertOne()?",
        "option_a": "insertMany() valida los datos automáticamente",
        "option_b": "insertMany() es más eficiente al enviar una sola solicitud al servidor",
        "option_c": "insertMany() crea índices automáticamente",
        "option_d": "insertMany() no requiere permisos especiales",
        "option_e": "insertMany() soporta transacciones implícitas",
        "correct_answer": "b",
        "explanation": "insertMany() reduce el overhead de red al enviar todos los documentos en una sola solicitud al servidor en lugar de múltiples round-trips. Esto mejora significativamente el rendimiento en inserciones masivas. También permite uso de writeConcern más eficiente.",
        "difficulty": "medium"
    }
]

# Total: 50 preguntas
# Categoría 1 (Instalación y Entorno): 30 preguntas COMPLETAS ✅
# Categoría 2 (CRUD - Create): 20 de 60 preguntas (faltan 40)
