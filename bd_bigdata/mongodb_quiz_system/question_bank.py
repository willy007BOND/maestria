"""
question_bank.py - Banco de preguntas para MongoDB Quiz System
Total aproximado: ~520 preguntas distribuidas en 9 categorías

Progreso: 150/520 preguntas
"""

# Categoría 1: Instalación y Entorno (30 preguntas) ✅
# Categoría 2: CRUD - Create (60 preguntas) ✅
# Categoría 3: CRUD - Read (60/80 preguntas)

QUESTIONS_BATCH_1 = [
    # ==================== CATEGORÍA 1: INSTALACIÓN Y ENTORNO ====================
    # Preguntas 1-30

    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué tipo de base de datos es MongoDB?",
        "option_a": "Base de datos relacional",
        "option_b": "Base de datos orientada a documentos NoSQL",
        "option_c": "Base de datos de grafos",
        "option_d": "Base de datos en memoria",
        "option_e": "Base de datos de columnas anchas",
        "correct_answer": "b",
        "explanation": "MongoDB es una base de datos NoSQL orientada a documentos que almacena datos en formato BSON (Binary JSON). No usa tablas y relaciones como las bases de datos SQL tradicionales, sino colecciones de documentos flexibles.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el formato de almacenamiento de documentos en MongoDB?",
        "option_a": "XML",
        "option_b": "CSV",
        "option_c": "BSON (Binary JSON)",
        "option_d": "YAML",
        "option_e": "Plain Text",
        "correct_answer": "c",
        "explanation": "MongoDB almacena documentos en formato BSON (Binary JSON), que es una representación binaria de JSON. BSON extiende JSON con tipos de datos adicionales como Date, ObjectId, y Binary, y permite un almacenamiento más eficiente.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es una colección en MongoDB?",
        "option_a": "Un grupo de bases de datos",
        "option_b": "Un conjunto de documentos similar a una tabla en SQL",
        "option_c": "Un índice para búsquedas rápidas",
        "option_d": "Un tipo de dato especial",
        "option_e": "Una función de agregación",
        "correct_answer": "b",
        "explanation": "Una colección en MongoDB es equivalente a una tabla en bases de datos relacionales. Agrupa documentos relacionados, pero a diferencia de las tablas SQL, los documentos en una colección pueden tener estructuras diferentes (esquema flexible).",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la ventaja principal del esquema flexible de MongoDB?",
        "option_a": "Mayor velocidad de consulta",
        "option_b": "Menor uso de memoria",
        "option_c": "No requiere definir estructura fija antes de insertar datos",
        "option_d": "Mejor seguridad de datos",
        "option_e": "Compatibilidad con SQL estándar",
        "correct_answer": "c",
        "explanation": "El esquema flexible de MongoDB permite insertar documentos sin definir previamente su estructura. Cada documento en una colección puede tener campos diferentes, facilitando la evolución del modelo de datos sin necesidad de migraciones complejas.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es MongoDB Atlas?",
        "option_a": "Un cliente de escritorio para MongoDB",
        "option_b": "Una herramienta de visualización de datos",
        "option_c": "Un servicio de MongoDB en la nube totalmente gestionado",
        "option_d": "Un lenguaje de consulta para MongoDB",
        "option_e": "Una librería de Python para MongoDB",
        "correct_answer": "c",
        "explanation": "MongoDB Atlas es el servicio de base de datos como servicio (DBaaS) en la nube de MongoDB. Proporciona despliegue, gestión y escalado automático de clusters MongoDB en proveedores cloud como AWS, Azure y Google Cloud.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué puerto utiliza MongoDB por defecto?",
        "option_a": "3306",
        "option_b": "5432",
        "option_c": "27017",
        "option_d": "8080",
        "option_e": "27018",
        "correct_answer": "c",
        "explanation": "MongoDB utiliza el puerto 27017 por defecto para las conexiones de clientes. El puerto 27018 se usa típicamente para el daemon mongos en configuraciones de sharding, y 27019 para el config server.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué comando se usa para iniciar el shell de MongoDB?",
        "option_a": "mongodb",
        "option_b": "mongo",
        "option_c": "mongosh",
        "option_d": "start-mongo",
        "option_e": "db.start()",
        "correct_answer": "c",
        "explanation": "El comando 'mongosh' (MongoDB Shell) es el shell interactivo moderno de MongoDB. Anteriormente se usaba 'mongo', pero desde la versión 5.0+ se recomienda usar mongosh que ofrece mejor funcionalidad y compatibilidad con JavaScript moderno.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra todas las bases de datos en MongoDB?",
        "option_a": "db.showDatabases()",
        "option_b": "show databases",
        "option_c": "list databases",
        "option_d": "db.getDatabases()",
        "option_e": "display dbs",
        "correct_answer": "b",
        "explanation": "El comando 'show databases' o su alias 'show dbs' muestra todas las bases de datos en el servidor MongoDB. Es un comando del shell, no una función de JavaScript. También existe 'db.adminCommand({listDatabases: 1})' para uso programático.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se selecciona o crea una base de datos en MongoDB?",
        "option_a": "CREATE DATABASE nombre",
        "option_b": "use nombre",
        "option_c": "db.create('nombre')",
        "option_d": "select nombre",
        "option_e": "new database nombre",
        "correct_answer": "b",
        "explanation": "El comando 'use nombre' cambia a una base de datos. Si la base de datos no existe, MongoDB la creará automáticamente cuando insertes el primer documento. No es necesario un comando CREATE DATABASE explícito.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra la base de datos actual en uso?",
        "option_a": "show current",
        "option_b": "db.getName()",
        "option_c": "db",
        "option_d": "current db",
        "option_e": "which database",
        "correct_answer": "c",
        "explanation": "El comando 'db' en el shell de MongoDB muestra el nombre de la base de datos actualmente seleccionada. Es la forma más rápida de verificar en qué base de datos estás trabajando.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se muestran todas las colecciones de la base de datos actual?",
        "option_a": "list collections",
        "option_b": "show collections",
        "option_c": "db.showCollections()",
        "option_d": "display tables",
        "option_e": "get collections",
        "correct_answer": "b",
        "explanation": "El comando 'show collections' muestra todas las colecciones en la base de datos actual. Alternativamente, puedes usar 'show tables' (que es un alias) o 'db.getCollectionNames()' para obtener un array con los nombres.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es un documento en MongoDB?",
        "option_a": "Un archivo PDF almacenado en la base de datos",
        "option_b": "Una fila en una tabla",
        "option_c": "Un registro en formato BSON con pares clave-valor",
        "option_d": "Un esquema de validación",
        "option_e": "Una función JavaScript",
        "correct_answer": "c",
        "explanation": "Un documento en MongoDB es una estructura de datos compuesta por pares clave-valor, similar a objetos JSON. Es la unidad básica de datos en MongoDB, equivalente a una fila en SQL, pero con estructura flexible y capacidad de anidar datos.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el _id en MongoDB?",
        "option_a": "Un índice secundario opcional",
        "option_b": "El campo de clave primaria único y obligatorio para cada documento",
        "option_c": "Un identificador de colección",
        "option_d": "Una función para generar IDs",
        "option_e": "Un campo de auditoría",
        "correct_answer": "b",
        "explanation": "El campo _id es la clave primaria de cada documento en MongoDB. Es obligatorio, único dentro de una colección, e inmutable. Si no se proporciona al insertar, MongoDB genera automáticamente un ObjectId de 12 bytes.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la estructura de un ObjectId en MongoDB?",
        "option_a": "UUID estándar de 36 caracteres",
        "option_b": "Entero autoincremental",
        "option_c": "Valor hexadecimal de 24 caracteres (12 bytes)",
        "option_d": "Hash MD5",
        "option_e": "GUID de Windows",
        "correct_answer": "c",
        "explanation": "Un ObjectId es un valor BSON de 12 bytes que se representa como una cadena hexadecimal de 24 caracteres. Incluye timestamp (4 bytes), identificador de máquina (5 bytes), y un contador incremental (3 bytes), lo que garantiza su unicidad.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué ventaja tiene MongoDB sobre bases de datos SQL tradicionales en términos de escalabilidad?",
        "option_a": "Solo puede escalarse verticalmente",
        "option_b": "Escalabilidad horizontal nativa mediante sharding",
        "option_c": "No soporta escalabilidad",
        "option_d": "Requiere hardware especializado para escalar",
        "option_e": "Solo funciona en un único servidor",
        "correct_answer": "b",
        "explanation": "MongoDB soporta escalabilidad horizontal mediante sharding, distribuyendo datos automáticamente entre múltiples servidores. Esto permite manejar grandes volúmenes de datos y tráfico sin las limitaciones de escalado vertical de bases de datos SQL tradicionales.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué herramienta de línea de comandos se usa para importar datos JSON a MongoDB?",
        "option_a": "mongodump",
        "option_b": "mongoimport",
        "option_c": "mongorestore",
        "option_d": "mongoexport",
        "option_e": "mongoload",
        "correct_answer": "b",
        "explanation": "mongoimport es la herramienta para importar datos desde archivos JSON, CSV o TSV a MongoDB. Ejemplo: 'mongoimport --db basedatos --collection coleccion --file datos.json'. mongodump/mongorestore se usan para backups BSON.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para exportar una colección completa a JSON?",
        "option_a": "mongodump --db basedatos --collection coleccion",
        "option_b": "mongoexport --db basedatos --collection coleccion --out archivo.json",
        "option_c": "db.coleccion.export('archivo.json')",
        "option_d": "mongosave --collection coleccion --file archivo.json",
        "option_e": "export --from coleccion --to archivo.json",
        "correct_answer": "b",
        "explanation": "mongoexport se usa para exportar datos en formato JSON o CSV. La sintaxis incluye --db para la base de datos, --collection para la colección, y --out para el archivo de salida. mongodump exporta en formato BSON para backups.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es un replica set en MongoDB?",
        "option_a": "Un conjunto de colecciones duplicadas",
        "option_b": "Un grupo de instancias MongoDB que mantienen el mismo conjunto de datos para alta disponibilidad",
        "option_c": "Una técnica de indexación",
        "option_d": "Un backup automático",
        "option_e": "Un tipo de consulta optimizada",
        "correct_answer": "b",
        "explanation": "Un replica set es un grupo de procesos mongod que mantienen el mismo conjunto de datos. Proporciona redundancia y alta disponibilidad mediante replicación automática. Incluye un nodo primario (escrituras) y múltiples secundarios (réplicas).",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia principal entre MongoDB y bases de datos SQL?",
        "option_a": "MongoDB no soporta consultas complejas",
        "option_b": "MongoDB usa esquema flexible y no requiere JOINs tradicionales",
        "option_c": "SQL es más rápido para todos los casos de uso",
        "option_d": "MongoDB no puede almacenar datos estructurados",
        "option_e": "SQL no soporta índices",
        "correct_answer": "b",
        "explanation": "La diferencia clave es que MongoDB usa un modelo de datos basado en documentos con esquema flexible, mientras SQL usa tablas con esquema fijo. MongoDB evita JOINs costosos mediante documentos embebidos y referencias, optimizando para lecturas.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Cuándo NO es recomendable usar MongoDB?",
        "option_a": "Cuando necesitas esquema flexible",
        "option_b": "Cuando requieres transacciones ACID complejas entre múltiples tablas relacionales",
        "option_c": "Cuando trabajas con datos JSON",
        "option_d": "Cuando necesitas escalabilidad horizontal",
        "option_e": "Cuando trabajas con documentos anidados",
        "correct_answer": "b",
        "explanation": "MongoDB no es ideal para aplicaciones que requieren transacciones ACID complejas entre múltiples entidades altamente relacionadas con muchos JOINs. Aunque MongoDB 4.0+ soporta transacciones multi-documento, bases de datos SQL tradicionales siguen siendo mejores para estos casos.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el Write Concern en MongoDB?",
        "option_a": "Un nivel de logging de errores",
        "option_b": "El nivel de confirmación requerido para operaciones de escritura",
        "option_c": "Un tipo de índice",
        "option_d": "Una validación de esquema",
        "option_e": "Un patrón de diseño",
        "correct_answer": "b",
        "explanation": "Write Concern es el nivel de confirmación requerido de MongoDB para operaciones de escritura. Define cuántos nodos del replica set deben confirmar la escritura antes de considerarla exitosa. Valores comunes: {w: 1} (solo primario), {w: 'majority'} (mayoría).",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el Read Concern en MongoDB?",
        "option_a": "La cantidad de documentos que se pueden leer",
        "option_b": "El nivel de garantía sobre la durabilidad de los datos leídos",
        "option_c": "El tiempo máximo de espera para lecturas",
        "option_d": "Un filtro de lectura",
        "option_e": "Una validación de datos",
        "correct_answer": "b",
        "explanation": "Read Concern controla el nivel de consistencia de los datos leídos en operaciones de consulta. Niveles incluyen: 'local' (datos más recientes del nodo), 'majority' (datos reconocidos por la mayoría), 'linearizable' (garantía de lectura más fuerte).",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se elimina una base de datos completa en MongoDB?",
        "option_a": "DROP DATABASE nombre",
        "option_b": "db.dropDatabase()",
        "option_c": "delete database nombre",
        "option_d": "db.remove()",
        "option_e": "destroy db nombre",
        "correct_answer": "b",
        "explanation": "El método db.dropDatabase() elimina la base de datos actual y todas sus colecciones. Primero debes usar 'use nombre_bd' para seleccionar la base de datos, luego ejecutar db.dropDatabase(). Esta operación es irreversible.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Qué comando muestra las estadísticas de una base de datos?",
        "option_a": "db.status()",
        "option_b": "db.stats()",
        "option_c": "show stats",
        "option_d": "db.info()",
        "option_e": "database statistics",
        "correct_answer": "b",
        "explanation": "db.stats() devuelve estadísticas sobre la base de datos actual, incluyendo número de colecciones, vistas, objetos, tamaño promedio de documentos, tamaño de datos, índices, etc. Útil para monitoreo y optimización.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es WiredTiger en MongoDB?",
        "option_a": "Una herramienta de migración de datos",
        "option_b": "El motor de almacenamiento por defecto desde MongoDB 3.2",
        "option_c": "Un cliente GUI para MongoDB",
        "option_d": "Un protocolo de red",
        "option_e": "Una librería de validación",
        "correct_answer": "b",
        "explanation": "WiredTiger es el motor de almacenamiento por defecto de MongoDB desde la versión 3.2. Proporciona compresión de datos, concurrencia a nivel de documento, y mejor rendimiento que el motor MMAPv1 anterior. Soporta snapshots y checkpoints.",
        "difficulty": "medium"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué formato de compresión usa WiredTiger por defecto?",
        "option_a": "gzip",
        "option_b": "snappy",
        "option_c": "lz4",
        "option_d": "zlib",
        "option_e": "bzip2",
        "correct_answer": "b",
        "explanation": "WiredTiger usa Snappy como algoritmo de compresión por defecto para colecciones. Snappy ofrece un buen balance entre velocidad y ratio de compresión. Para índices, usa compresión prefix. También soporta zlib y zstd para mayor compresión.",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "syntax",
        "question_text": "¿Cómo se verifica la versión de MongoDB instalada?",
        "option_a": "mongodb --version",
        "option_b": "mongod --version",
        "option_c": "mongo --ver",
        "option_d": "show version",
        "option_e": "db.getVersion()",
        "correct_answer": "b",
        "explanation": "El comando 'mongod --version' muestra la versión del servidor MongoDB instalado. En el shell, puedes usar 'db.version()' o 'mongosh --version' para ver la versión del shell. También 'db.serverBuildInfo()' da información detallada.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el oplog en MongoDB?",
        "option_a": "Un archivo de log de errores",
        "option_b": "Una colección especial que registra todas las operaciones de escritura para replicación",
        "option_c": "Una herramienta de monitoreo",
        "option_d": "Un índice automático",
        "option_e": "Un comando de optimización",
        "correct_answer": "b",
        "explanation": "El oplog (operations log) es una colección capped especial que registra todas las operaciones que modifican datos. Los nodos secundarios de un replica set leen el oplog del primario para replicar los cambios. Es circular y tiene tamaño fijo.",
        "difficulty": "hard"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué puerto usa MongoDB Compass por defecto para conectarse?",
        "option_a": "27016",
        "option_b": "27017",
        "option_c": "28017",
        "option_d": "8080",
        "option_e": "3000",
        "correct_answer": "b",
        "explanation": "MongoDB Compass, la GUI oficial de MongoDB, se conecta por defecto al puerto 27017, que es el puerto estándar del servidor MongoDB. Compass proporciona una interfaz visual para explorar datos, crear consultas y analizar rendimiento.",
        "difficulty": "easy"
    },
    {
        "category_id": 1,
        "question_type": "conceptual",
        "question_text": "¿Qué es el sharding en MongoDB?",
        "option_a": "Un método de backup incremental",
        "option_b": "Un método de particionamiento horizontal de datos entre múltiples máquinas",
        "option_c": "Una técnica de indexación",
        "option_d": "Un tipo de validación de datos",
        "option_e": "Un algoritmo de compresión",
        "correct_answer": "b",
        "explanation": "Sharding es el método de MongoDB para distribuir datos horizontalmente entre múltiples máquinas (shards). Permite escalar más allá de los límites de un solo servidor dividiendo la colección en chunks distribuidos según una shard key.",
        "difficulty": "medium"
    },

    # ==================== CATEGORÍA 2: CRUD - CREATE ====================
    # Preguntas 31-50 (20 de 60 totales)

    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para insertar un documento en MongoDB?",
        "option_a": "db.coleccion.add({campo: 'valor'})",
        "option_b": "db.coleccion.insertOne({campo: 'valor'})",
        "option_c": "db.coleccion.create({campo: 'valor'})",
        "option_d": "INSERT INTO coleccion VALUES ({campo: 'valor'})",
        "option_e": "db.coleccion.put({campo: 'valor'})",
        "correct_answer": "b",
        "explanation": "db.coleccion.insertOne({documento}) es el método correcto para insertar un único documento en MongoDB. Retorna un objeto con el _id del documento insertado. Si el documento no tiene _id, MongoDB genera uno automáticamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se insertan múltiples documentos a la vez en MongoDB?",
        "option_a": "db.coleccion.insertOne([{}, {}])",
        "option_b": "db.coleccion.insertMany([{}, {}])",
        "option_c": "db.coleccion.insertAll([{}, {}])",
        "option_d": "db.coleccion.bulkInsert([{}, {}])",
        "option_e": "db.coleccion.addMany([{}, {}])",
        "correct_answer": "b",
        "explanation": "db.coleccion.insertMany([array_de_documentos]) inserta múltiples documentos en una sola operación. Es más eficiente que múltiples insertOne(). Retorna un objeto con los _id de todos los documentos insertados.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para el dataset infovuelos_limpio, ¿cuál es la sintaxis correcta para insertar un nuevo vuelo?",
        "option_a": "db.infovuelos.insert({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_b": "db.infovuelos_limpio.insertOne({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_c": "INSERT INTO infovuelos_limpio VALUES ('Madrid', 'Barcelona', 150)",
        "option_d": "db.infovuelos_limpio.add({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "option_e": "db.infovuelos_limpio.create({origen: 'Madrid', destino: 'Barcelona', precio: 150})",
        "correct_answer": "b",
        "explanation": "db.infovuelos_limpio.insertOne({documento}) es la sintaxis correcta. Usa el nombre exacto de la colección (infovuelos_limpio) y el método insertOne() con un objeto conteniendo los campos del vuelo. El método insert() está deprecado.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué sucede si intentas insertar un documento con un _id que ya existe?",
        "option_a": "Se actualiza el documento existente",
        "option_b": "Se genera un error de duplicate key",
        "option_c": "Se ignora silenciosamente",
        "option_d": "Se crea un nuevo documento con _id diferente",
        "option_e": "Se elimina el documento anterior",
        "correct_answer": "b",
        "explanation": "MongoDB genera un error 'E11000 duplicate key error' si intentas insertar un documento con un _id que ya existe en la colección. El _id debe ser único. Para actualizar, debes usar updateOne() o replaceOne().",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para insertar un listing en la colección listings_limpio con campos anidados, ¿cuál es correcto?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Apartamento', ubicacion: {ciudad: 'Madrid', barrio: 'Centro'}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Apartamento', ubicacion.ciudad: 'Madrid'})",
        "option_c": "db.listings_limpio.insertOne([nombre: 'Apartamento', ubicacion: [ciudad: 'Madrid']])",
        "option_d": "INSERT INTO listings_limpio (nombre, ubicacion) VALUES ('Apartamento', 'Madrid, Centro')",
        "option_e": "db.listings_limpio.add(nombre='Apartamento', ubicacion={'Madrid', 'Centro'})",
        "correct_answer": "a",
        "explanation": "MongoDB permite documentos anidados usando objetos JavaScript. La sintaxis correcta es {campo: {subcampo: valor}}. Esto crea una estructura jerárquica donde ubicacion es un objeto con propiedades ciudad y barrio.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con un array de valores?",
        "option_a": "db.coleccion.insertOne({tags: ['tag1', 'tag2', 'tag3']})",
        "option_b": "db.coleccion.insertOne({tags: 'tag1, tag2, tag3'})",
        "option_c": "db.coleccion.insertOne({tags: {0: 'tag1', 1: 'tag2'}})",
        "option_d": "db.coleccion.insertOne({tags: SET['tag1', 'tag2']})",
        "option_e": "db.coleccion.insertOne({tags: ARRAY('tag1', 'tag2')})",
        "correct_answer": "a",
        "explanation": "En MongoDB, los arrays se insertan usando la sintaxis de arrays JavaScript: [valor1, valor2, ...]. MongoDB soporta arrays nativamente como tipo de dato BSON, permitiendo almacenar listas de valores en un solo campo.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cuál es la diferencia entre insert() e insertOne()?",
        "option_a": "No hay diferencia, son sinónimos",
        "option_b": "insertOne() es el método moderno recomendado; insert() está deprecado",
        "option_c": "insert() es más rápido",
        "option_d": "insertOne() solo funciona en MongoDB Atlas",
        "option_e": "insert() requiere permisos de administrador",
        "correct_answer": "b",
        "explanation": "insertOne() e insertMany() son los métodos modernos introducidos en MongoDB 3.2+. El método insert() está deprecado. Los métodos nuevos tienen mejor manejo de errores, retornan objetos más consistentes y son más explícitos en su propósito.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento especificando un _id personalizado?",
        "option_a": "db.coleccion.insertOne({_id: 'mi_id_custom', nombre: 'valor'})",
        "option_b": "db.coleccion.insertOne({nombre: 'valor'}).setId('mi_id_custom')",
        "option_c": "db.coleccion.insertOne({nombre: 'valor'}, {_id: 'mi_id_custom'})",
        "option_d": "No es posible, MongoDB siempre genera el _id",
        "option_e": "db.coleccion.insertWithId('mi_id_custom', {nombre: 'valor'})",
        "correct_answer": "a",
        "explanation": "Puedes especificar tu propio _id incluyéndolo en el documento: {_id: valor, ...}. El _id puede ser cualquier tipo BSON excepto arrays. Si no proporcionas _id, MongoDB genera un ObjectId automáticamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para el dataset data_act_01_limpio, ¿cómo insertarías un documento con fecha actual?",
        "option_a": "db.data_act_01_limpio.insertOne({fecha: Date.now()})",
        "option_b": "db.data_act_01_limpio.insertOne({fecha: new Date()})",
        "option_c": "db.data_act_01_limpio.insertOne({fecha: CURRENT_TIMESTAMP})",
        "option_d": "db.data_act_01_limpio.insertOne({fecha: today()})",
        "option_e": "db.data_act_01_limpio.insertOne({fecha: '2024-01-21'})",
        "correct_answer": "b",
        "explanation": "new Date() crea un objeto Date de JavaScript que MongoDB almacena como tipo BSON Date. Date.now() retorna un timestamp numérico (no recomendado). Las cadenas de texto no son fechas tipadas. BSON Date permite consultas y operaciones temporales eficientes.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué retorna el método insertOne() tras una inserción exitosa?",
        "option_a": "El documento completo insertado",
        "option_b": "Un objeto con acknowledged: true y insertedId con el _id",
        "option_c": "El número de documentos insertados",
        "option_d": "true o false",
        "option_e": "Nada (void)",
        "correct_answer": "b",
        "explanation": "insertOne() retorna un objeto con dos propiedades: 'acknowledged' (boolean indicando si la operación fue reconocida) y 'insertedId' (el _id del documento insertado). Ejemplo: {acknowledged: true, insertedId: ObjectId('...')}",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Qué retorna insertMany() cuando inserta 5 documentos exitosamente?",
        "option_a": "Un array con los 5 documentos",
        "option_b": "Un objeto con acknowledged: true e insertedIds: {0: id1, 1: id2, ...}",
        "option_c": "El número 5",
        "option_d": "Los ObjectIds separados por comas",
        "option_e": "true",
        "correct_answer": "b",
        "explanation": "insertMany() retorna un objeto con 'acknowledged' (boolean) e 'insertedIds' (un objeto/mapa donde las keys son índices y los valores son los _id insertados). Ejemplo: {acknowledged: true, insertedIds: {0: ObjectId('...'), 1: ObjectId('...')}}",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es la opción 'ordered' en insertMany()?",
        "option_a": "Ordena los documentos alfabéticamente antes de insertar",
        "option_b": "Controla si la inserción se detiene en el primer error (true) o continúa (false)",
        "option_c": "Define el orden de los índices",
        "option_d": "Ordena por _id automáticamente",
        "option_e": "Requiere que los documentos estén ordenados por timestamp",
        "correct_answer": "b",
        "explanation": "La opción 'ordered: true' (default) detiene la inserción al primer error. Con 'ordered: false', MongoDB intenta insertar todos los documentos, omitiendo los que causan error. Útil para inserciones masivas donde algunos documentos pueden fallar.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples vuelos en infovuelos_limpio con ordered: false?",
        "option_a": "db.infovuelos_limpio.insertMany([{...}, {...}], {ordered: false})",
        "option_b": "db.infovuelos_limpio.insertMany([{...}, {...}], ordered=false)",
        "option_c": "db.infovuelos_limpio.insertMany([{...}, {...}]).unordered()",
        "option_d": "db.infovuelos_limpio.bulkInsert([{...}, {...}], false)",
        "option_e": "db.infovuelos_limpio.insertMany([{...}, {...}], {mode: 'unordered'})",
        "correct_answer": "a",
        "explanation": "La sintaxis correcta es insertMany(array_documentos, opciones). Las opciones se pasan como segundo parámetro en un objeto: {ordered: false}. Esto hace que MongoDB intente insertar todos los documentos incluso si algunos fallan.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite de tamaño máximo de un documento en MongoDB?",
        "option_a": "1 MB",
        "option_b": "8 MB",
        "option_c": "16 MB",
        "option_d": "32 MB",
        "option_e": "No hay límite",
        "correct_answer": "c",
        "explanation": "MongoDB tiene un límite de 16 MB por documento. Este límite previene uso excesivo de memoria y ancho de banda. Para datos más grandes, usa GridFS que divide archivos en chunks. El límite se aplica al documento BSON completo.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con un campo que contiene un objeto complejo en listings_limpio?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: {habitaciones: 3, banos: 2, amenidades: ['wifi', 'parking']}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Casa', detalles.habitaciones: 3, detalles.banos: 2})",
        "option_c": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: JSON.stringify({habitaciones: 3})})",
        "option_d": "db.listings_limpio.insertOne({nombre: 'Casa', detalles: OBJECT(habitaciones=3, banos=2)})",
        "option_e": "db.listings_limpio.insertOne(nombre='Casa', detalles={habitaciones:3})",
        "correct_answer": "a",
        "explanation": "MongoDB soporta objetos anidados arbitrariamente complejos. Puedes incluir objetos dentro de objetos, arrays dentro de objetos, etc. La sintaxis es JavaScript estándar. No necesitas stringify, MongoDB maneja la estructura nativa.",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede si insertas un documento sin especificar ningún campo?",
        "option_a": "MongoDB rechaza el documento vacío",
        "option_b": "Se inserta un documento con solo el _id",
        "option_c": "Se genera un error de validación",
        "option_d": "Se crea un documento con campos null",
        "option_e": "La colección se elimina",
        "correct_answer": "b",
        "explanation": "MongoDB permite insertar documentos vacíos: db.coleccion.insertOne({}). Se creará un documento con solo el campo _id generado automáticamente. Esto es válido aunque poco práctico en la mayoría de casos de uso.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo se inserta un documento con WriteConcern 'majority' para garantizar replicación?",
        "option_a": "db.coleccion.insertOne({...}, {w: 'majority'})",
        "option_b": "db.coleccion.insertOne({...}, {writeConcern: 'majority'})",
        "option_c": "db.coleccion.insertOne({...}, {replicate: 'all'})",
        "option_d": "db.coleccion.insertOne({...}).majority()",
        "option_e": "db.coleccion.insertOne({...}, {durability: 'high'})",
        "correct_answer": "a",
        "explanation": "El WriteConcern se especifica como opción con la propiedad 'w'. {w: 'majority'} espera confirmación de la mayoría de nodos del replica set antes de retornar. Aumenta durabilidad pero reduce performance. {w: 1} solo espera al nodo primario (default).",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'bulk write' en MongoDB?",
        "option_a": "Una operación de escritura masiva con múltiples tipos de operaciones (insert, update, delete) en una sola llamada",
        "option_b": "Un método para escribir archivos grandes",
        "option_c": "Una técnica de compresión de datos",
        "option_d": "Un tipo especial de índice",
        "option_e": "Una herramienta de backup",
        "correct_answer": "a",
        "explanation": "bulkWrite() permite ejecutar múltiples operaciones (insertOne, updateOne, deleteOne, etc.) en una sola llamada al servidor. Es más eficiente que múltiples operaciones individuales. Soporta modo ordenado y no ordenado.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con un campo de tipo NumberDecimal?",
        "option_a": "db.data_act_01_limpio.insertOne({precio: 99.99})",
        "option_b": "db.data_act_01_limpio.insertOne({precio: NumberDecimal('99.99')})",
        "option_c": "db.data_act_01_limpio.insertOne({precio: new Decimal(99.99)})",
        "option_d": "db.data_act_01_limpio.insertOne({precio: DECIMAL(99.99)})",
        "option_e": "db.data_act_01_limpio.insertOne({precio: parseDecimal('99.99')})",
        "correct_answer": "b",
        "explanation": "NumberDecimal('string') es el constructor para el tipo Decimal128 de BSON, diseñado para cálculos financieros precisos. Números normales se almacenan como Double (64-bit) que pueden tener imprecisiones. NumberDecimal evita errores de redondeo.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué ventaja tiene usar insertMany() sobre múltiples insertOne()?",
        "option_a": "insertMany() valida los datos automáticamente",
        "option_b": "insertMany() es más eficiente al enviar una sola solicitud al servidor",
        "option_c": "insertMany() crea índices automáticamente",
        "option_d": "insertMany() no requiere permisos especiales",
        "option_e": "insertMany() soporta transacciones implícitas",
        "correct_answer": "b",
        "explanation": "insertMany() reduce el overhead de red al enviar todos los documentos en una sola solicitud al servidor en lugar de múltiples round-trips. Esto mejora significativamente el rendimiento en inserciones masivas. También permite uso de writeConcern más eficiente.",
        "difficulty": "medium"
    }
]

# Total Batch 1: 50 preguntas
# Categoría 1 (Instalación y Entorno): 30 preguntas COMPLETAS ✅
# Categoría 2 (CRUD - Create): 20 de 60 preguntas

# ==================== BATCH 2: Preguntas 51-100 ====================
# Categoría 2: CRUD - Create (40 preguntas restantes)
# Categoría 3: CRUD - Read (10 preguntas iniciales)

QUESTIONS_BATCH_2 = [
    # ==================== CATEGORÍA 2: CRUD - CREATE (continuación) ====================
    # Preguntas 51-90 (40 preguntas para completar las 60 de esta categoría)

    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un campo null en MongoDB?",
        "option_a": "db.coleccion.insertOne({campo: null})",
        "option_b": "db.coleccion.insertOne({campo: NULL})",
        "option_c": "db.coleccion.insertOne({campo: 'null'})",
        "option_d": "No es posible insertar valores null",
        "option_e": "db.coleccion.insertOne({campo: undefined})",
        "correct_answer": "a",
        "explanation": "MongoDB soporta el valor null de JavaScript. Se inserta como {campo: null}. Esto es diferente de undefined (que no se almacena) y de 'null' como string. null es un valor BSON válido que indica ausencia intencional de valor.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre un campo con valor null y un campo que no existe?",
        "option_a": "Son exactamente lo mismo",
        "option_b": "null indica ausencia intencional de valor; campo inexistente simplemente no está definido",
        "option_c": "null ocupa más espacio",
        "option_d": "Campos inexistentes no se pueden consultar",
        "option_e": "null es un error, campos inexistentes son normales",
        "correct_answer": "b",
        "explanation": "Hay diferencia semántica: {campo: null} indica que el campo existe pero intencionalmente no tiene valor. Un campo inexistente simplemente no está en el documento. Ambos se consultan diferente: {campo: null} vs {campo: {$exists: false}}.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas un vuelo con un array de escalas?",
        "option_a": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: ['MAD', 'BCN', 'PAR']})",
        "option_b": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: 'MAD,BCN,PAR'})",
        "option_c": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: ARRAY('MAD', 'BCN', 'PAR')})",
        "option_d": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas: {'MAD', 'BCN', 'PAR'}})",
        "option_e": "db.infovuelos_limpio.insertOne({vuelo: 'IB3201', escalas[0]: 'MAD', escalas[1]: 'BCN'})",
        "correct_answer": "a",
        "explanation": "Los arrays en MongoDB se insertan usando sintaxis de array JavaScript: ['valor1', 'valor2', ...]. MongoDB almacena arrays nativamente como tipo BSON Array, permitiendo consultas eficientes sobre elementos del array.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un ObjectId específico que ya tienes?",
        "option_a": "db.coleccion.insertOne({_id: 'ObjectId(507f1f77bcf86cd799439011)'})",
        "option_b": "db.coleccion.insertOne({_id: ObjectId('507f1f77bcf86cd799439011')})",
        "option_c": "db.coleccion.insertOne({_id: new ObjectId('507f1f77bcf86cd799439011')})",
        "option_d": "db.coleccion.insertOne({_id: '507f1f77bcf86cd799439011'})",
        "option_e": "Tanto b como c son correctas",
        "correct_answer": "e",
        "explanation": "Ambas sintaxis son válidas: ObjectId('string') y new ObjectId('string') crean un objeto ObjectId de BSON. No uses comillas alrededor del ObjectId() ni uses solo el string, ya que se almacenaría como string en lugar de tipo ObjectId.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede si insertas dos documentos con el mismo _id en insertMany()?",
        "option_a": "Ambos se insertan con diferentes _id",
        "option_b": "Se genera error y se detiene la inserción (con ordered: true por defecto)",
        "option_c": "Se actualiza el primero",
        "option_d": "MongoDB los fusiona automáticamente",
        "option_e": "Se ignoran los duplicados silenciosamente",
        "correct_answer": "b",
        "explanation": "Con ordered: true (default), insertMany() se detiene al encontrar un error de _id duplicado, dejando sin insertar los documentos posteriores. Con ordered: false, intenta insertar todos excepto los duplicados y reporta errores al final.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo insertas un documento con un subdocumento de ubicación geográfica?",
        "option_a": "db.listings_limpio.insertOne({nombre: 'Casa', geo: {type: 'Point', coordinates: [40.4168, -3.7038]}})",
        "option_b": "db.listings_limpio.insertOne({nombre: 'Casa', geo: POINT(40.4168, -3.7038)})",
        "option_c": "db.listings_limpio.insertOne({nombre: 'Casa', lat: 40.4168, lon: -3.7038})",
        "option_d": "db.listings_limpio.insertOne({nombre: 'Casa', geo: '40.4168,-3.7038'})",
        "option_e": "db.listings_limpio.insertOne({nombre: 'Casa', geo: {lat: 40.4168, lng: -3.7038}})",
        "correct_answer": "a",
        "explanation": "MongoDB soporta datos geoespaciales usando GeoJSON. El formato correcto para un punto es {type: 'Point', coordinates: [longitud, latitud]}. Nota: longitud primero, luego latitud. Esto permite usar índices geoespaciales y consultas $near, $geoWithin, etc.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un timestamp de MongoDB?",
        "option_a": "db.coleccion.insertOne({ts: new Timestamp()})",
        "option_b": "db.coleccion.insertOne({ts: Timestamp(1, 0)})",
        "option_c": "db.coleccion.insertOne({ts: CURRENT_TIMESTAMP})",
        "option_d": "db.coleccion.insertOne({ts: Date.now()})",
        "option_e": "db.coleccion.insertOne({ts: new Date()})",
        "correct_answer": "b",
        "explanation": "Timestamp(segundos, contador) es el tipo BSON Timestamp usado internamente por MongoDB para replicación (no para fechas de aplicación). Para fechas usa new Date(). Timestamp() requiere dos parámetros: timestamp Unix y contador ordinal.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es mejor para fechas en aplicaciones: Date o Timestamp de BSON?",
        "option_a": "Timestamp siempre es mejor",
        "option_b": "Date para aplicaciones; Timestamp es para uso interno de MongoDB",
        "option_c": "Son intercambiables",
        "option_d": "Timestamp es más preciso",
        "option_e": "Date está deprecado",
        "correct_answer": "b",
        "explanation": "BSON Date (new Date()) es para fechas de aplicación. BSON Timestamp es para uso interno de MongoDB (oplog, replicación). Timestamp tiene semántica diferente y no debe usarse para datos de aplicación. Date soporta operaciones de fecha estándar.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con datos binarios (Binary) en MongoDB?",
        "option_a": "db.coleccion.insertOne({archivo: BinData(0, 'base64string')})",
        "option_b": "db.coleccion.insertOne({archivo: new Binary('data')})",
        "option_c": "db.coleccion.insertOne({archivo: BLOB('data')})",
        "option_d": "db.coleccion.insertOne({archivo: Buffer.from('data')})",
        "option_e": "Opciones a y b son correctas",
        "correct_answer": "e",
        "explanation": "Tanto BinData(subtype, base64) (en shell) como new Binary(buffer, subtype) (en drivers) son válidos. Los datos binarios se almacenan eficientemente como BSON Binary. Útil para almacenar archivos pequeños, pero para archivos grandes usa GridFS.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con un campo de tipo Long (64-bit)?",
        "option_a": "db.data_act_01_limpio.insertOne({contador: NumberLong('9223372036854775807')})",
        "option_b": "db.data_act_01_limpio.insertOne({contador: 9223372036854775807})",
        "option_c": "db.data_act_01_limpio.insertOne({contador: BIGINT(9223372036854775807)})",
        "option_d": "db.data_act_01_limpio.insertOne({contador: Long(9223372036854775807)})",
        "option_e": "db.data_act_01_limpio.insertOne({contador: new Int64(9223372036854775807)})",
        "correct_answer": "a",
        "explanation": "NumberLong('string') se usa para enteros de 64 bits que exceden el rango seguro de JavaScript (2^53). Los números normales en JS son de 64-bit float. NumberLong asegura precisión total para enteros grandes, crítico para IDs, timestamps, contadores.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples documentos usando bulkWrite()?",
        "option_a": "db.coleccion.bulkWrite([{insertOne: {document: {...}}}, {insertOne: {document: {...}}}])",
        "option_b": "db.coleccion.bulkWrite([{insert: {...}}, {insert: {...}}])",
        "option_c": "db.coleccion.bulkWrite([{...}, {...}])",
        "option_d": "db.coleccion.bulkWrite({insertMany: [{...}, {...}]})",
        "option_e": "db.coleccion.bulkWrite([{operation: 'insert', doc: {...}}])",
        "correct_answer": "a",
        "explanation": "bulkWrite() usa array de operaciones donde cada operación es un objeto con el tipo (insertOne, updateOne, etc.) y parámetros. Sintaxis: [{insertOne: {document: {...}}}, ...]. Permite mezclar múltiples tipos de operaciones en una sola llamada.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la ventaja de bulkWrite() sobre insertMany()?",
        "option_a": "bulkWrite() es más rápido",
        "option_b": "bulkWrite() permite combinar inserts, updates y deletes en una operación",
        "option_c": "bulkWrite() no genera errores",
        "option_d": "bulkWrite() soporta transacciones automáticas",
        "option_e": "insertMany() está deprecado",
        "correct_answer": "b",
        "explanation": "bulkWrite() permite ejecutar múltiples tipos de operaciones (insertOne, updateOne, deleteOne, replaceOne) en una sola llamada al servidor. insertMany() solo inserta. bulkWrite() es más flexible para operaciones batch heterogéneas.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo verificas cuántos documentos se insertaron exitosamente con insertMany()?",
        "option_a": "result.count",
        "option_b": "result.insertedCount",
        "option_c": "Object.keys(result.insertedIds).length",
        "option_d": "Opciones b y c son correctas",
        "option_e": "result.nInserted",
        "correct_answer": "d",
        "explanation": "insertMany() retorna un objeto con 'insertedCount' (número de docs insertados) y 'insertedIds' (objeto con los IDs). Puedes usar result.insertedCount directamente o contar las keys de insertedIds. Ambos dan el mismo resultado.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas un vuelo con un campo de tipo RegExp?",
        "option_a": "db.infovuelos_limpio.insertOne({codigo: /^IB\\d{4}$/})",
        "option_b": "db.infovuelos_limpio.insertOne({codigo: new RegExp('^IB\\\\d{4}$')})",
        "option_c": "db.infovuelos_limpio.insertOne({codigo: REGEX('^IB\\\\d{4}$')})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "MongoDB no soporta RegExp en documentos",
        "correct_answer": "d",
        "explanation": "MongoDB soporta BSON RegExp. Puedes usar sintaxis literal /pattern/flags o new RegExp('pattern', 'flags'). Aunque raro almacenar regex en docs, es posible. Más común es usar regex en consultas con operador $regex.",
        "difficulty": "hard",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué tipo de datos NO soporta MongoDB/BSON?",
        "option_a": "Arrays",
        "option_b": "Fechas",
        "option_c": "Funciones JavaScript",
        "option_d": "Binary data",
        "option_e": "Todos son soportados",
        "correct_answer": "c",
        "explanation": "MongoDB no almacena funciones JavaScript en documentos (aunque el shell permite ejecutar funciones). BSON soporta: String, Number, Boolean, Date, Timestamp, Binary, ObjectId, Array, Document, Null, RegExp, pero no funciones por razones de seguridad y serialización.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con validación de esquema opcional (sin Schema Validation)?",
        "option_a": "db.coleccion.insertOne({cualquier_campo: 'cualquier_valor'})",
        "option_b": "db.coleccion.insertOne({cualquier_campo: 'cualquier_valor'}, {validate: false})",
        "option_c": "db.coleccion.novalidate.insertOne({cualquier_campo: 'cualquier_valor'})",
        "option_d": "db.coleccion.insertOne({cualquier_campo: 'cualquier_valor'}, {bypassValidation: true})",
        "option_e": "Opciones a y d son correctas",
        "correct_answer": "e",
        "explanation": "Por defecto MongoDB no valida esquemas (esquema flexible). Si has definido validación con $jsonSchema, puedes saltarla con {bypassDocumentValidation: true}. Sin validación definida, insertOne() acepta cualquier estructura.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo insertas un documento con un array de documentos embebidos?",
        "option_a": "db.listings_limpio.insertOne({titulo: 'Casa', reviews: [{autor: 'Juan', rating: 5}, {autor: 'Ana', rating: 4}]})",
        "option_b": "db.listings_limpio.insertOne({titulo: 'Casa', reviews: [{autor: 'Juan', rating: 5}], [{autor: 'Ana', rating: 4}]})",
        "option_c": "db.listings_limpio.insertOne({titulo: 'Casa', reviews: JSON.stringify([{autor: 'Juan'}])})",
        "option_d": "db.listings_limpio.insertOne({titulo: 'Casa', reviews[0]: {autor: 'Juan'}, reviews[1]: {autor: 'Ana'}})",
        "option_e": "No es posible tener arrays de objetos",
        "correct_answer": "a",
        "explanation": "MongoDB soporta arrays de documentos embebidos: [{doc1}, {doc2}, ...]. Es una estructura común y poderosa que permite modelar relaciones uno-a-muchos dentro de un documento. Cada elemento del array puede ser un documento completo con su propia estructura.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuándo deberías usar documentos embebidos vs referencias en MongoDB?",
        "option_a": "Siempre usar embebidos, MongoDB no soporta referencias",
        "option_b": "Embebidos para datos que se acceden juntos; referencias para datos que se comparten o son muy grandes",
        "option_c": "Siempre usar referencias como en SQL",
        "option_d": "Depende del motor de almacenamiento",
        "option_e": "No hay diferencia de performance",
        "correct_answer": "b",
        "explanation": "Usa embebidos cuando: datos se leen juntos, relación uno-a-pocos, datos no se comparten. Usa referencias cuando: datos muy grandes, se comparten entre docs, relación muchos-a-muchos, o se actualizan frecuentemente. El diseño depende de patrones de acceso.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento con un campo que es un array vacío?",
        "option_a": "db.coleccion.insertOne({tags: []})",
        "option_b": "db.coleccion.insertOne({tags: null})",
        "option_c": "db.coleccion.insertOne({tags: EMPTY_ARRAY})",
        "option_d": "db.coleccion.insertOne({tags: {}})",
        "option_e": "No es posible, arrays deben tener al menos un elemento",
        "correct_answer": "a",
        "explanation": "MongoDB permite arrays vacíos: {campo: []}. Es diferente de null (indica sin valor) y de campo inexistente. Un array vacío puede crecer posteriormente con $push. Útil para inicializar listas que se llenarán después.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con un MinKey o MaxKey?",
        "option_a": "db.data_act_01_limpio.insertOne({limite: MinKey()})",
        "option_b": "db.data_act_01_limpio.insertOne({limite: new MinKey()})",
        "option_c": "db.data_act_01_limpio.insertOne({limite: MinKey})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "MinKey y MaxKey no son tipos BSON válidos",
        "correct_answer": "d",
        "explanation": "MinKey y MaxKey son tipos BSON especiales que se comparan menor/mayor que cualquier otro valor. Sintaxis: MinKey() o new MinKey(). Útiles para consultas de rango y en operaciones de sharding. Raramente usados en aplicaciones normales.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es un documento 'capped collection' y cómo afecta a insertOne()?",
        "option_a": "Una colección con validación de esquema estricta",
        "option_b": "Una colección de tamaño fijo que sobrescribe docs antiguos cuando se llena",
        "option_c": "Una colección comprimida",
        "option_d": "Una colección encriptada",
        "option_e": "Una colección temporal",
        "correct_answer": "b",
        "explanation": "Las capped collections tienen tamaño máximo fijo. Cuando se llena, MongoDB sobrescribe automáticamente los documentos más antiguos (comportamiento FIFO). Las inserciones son rápidas y mantienen orden de inserción. Útiles para logs, caché, historial limitado.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento garantizando que se escriba en el journal para durabilidad?",
        "option_a": "db.coleccion.insertOne({...}, {w: 1, j: true})",
        "option_b": "db.coleccion.insertOne({...}, {journal: true})",
        "option_c": "db.coleccion.insertOne({...}, {durability: 'high'})",
        "option_d": "db.coleccion.insertOne({...}, {fsync: true})",
        "option_e": "db.coleccion.insertOne({...}, {w: 'majority'})",
        "correct_answer": "a",
        "explanation": "WriteConcern con {j: true} espera confirmación de que la operación se escribió en el journal (log de escritura adelantada). Esto garantiza durabilidad ante fallos. {w: 1, j: true} espera escritura en journal del primario. Más lento pero más seguro.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el write concern {w: 0}?",
        "option_a": "Modo más seguro de escritura",
        "option_b": "Escritura sin esperar confirmación (fire and forget)",
        "option_c": "Escritura en memoria sin journal",
        "option_d": "Escritura solo en nodos secundarios",
        "option_e": "Deshabilita escrituras",
        "correct_answer": "b",
        "explanation": "{w: 0} es 'unacknowledged write' o 'fire and forget'. El cliente no espera confirmación del servidor, maximizando throughput pero sin garantías de éxito. No recomendado en producción. {w: 1} espera ack del primario, {w: 'majority'} de la mayoría.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas 1000 documentos de forma eficiente?",
        "option_a": "Usar un loop con 1000 insertOne()",
        "option_b": "db.infovuelos_limpio.insertMany([...1000 docs...])",
        "option_c": "db.infovuelos_limpio.bulkWrite([{insertOne: {...}} × 1000])",
        "option_d": "Opciones b y c son eficientes",
        "option_e": "Usar mongoimport desde archivo JSON",
        "correct_answer": "d",
        "explanation": "insertMany() y bulkWrite() son eficientes al agrupar operaciones. Evita loops de insertOne() (1000 round-trips). Para datasets muy grandes, mongoimport es la herramienta más rápida. insertMany() tiene límite de 100,000 docs por operación.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué sucede con el performance de inserciones cuando agregas muchos índices a una colección?",
        "option_a": "Mejora el performance de inserciones",
        "option_b": "Las inserciones se vuelven más lentas porque cada índice debe actualizarse",
        "option_c": "No hay efecto en el performance",
        "option_d": "Los índices solo afectan las consultas",
        "option_e": "MongoDB deshabilita índices durante inserciones masivas",
        "correct_answer": "b",
        "explanation": "Cada índice adicional ralentiza las inserciones porque MongoDB debe actualizar todos los índices al insertar. El trade-off es: índices aceleran queries pero ralentizan writes. Diseña índices basándote en patrones de lectura vs escritura de tu aplicación.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento especificando timeout personalizado?",
        "option_a": "db.coleccion.insertOne({...}, {maxTimeMS: 5000})",
        "option_b": "db.coleccion.insertOne({...}, {timeout: 5000})",
        "option_c": "db.coleccion.insertOne({...}).timeout(5000)",
        "option_d": "db.coleccion.insertOne({...}, {ttl: 5000})",
        "option_e": "No es posible especificar timeout en inserciones",
        "correct_answer": "a",
        "explanation": "La opción maxTimeMS especifica el tiempo máximo en milisegundos para la operación. Si excede el timeout, MongoDB cancela la operación con error. Útil para prevenir operaciones que se cuelgan. Ejemplo: {maxTimeMS: 5000} para timeout de 5 segundos.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo insertas un documento con un campo de tipo Code (JavaScript)?",
        "option_a": "db.listings_limpio.insertOne({script: Code('function() { return 42; }')})",
        "option_b": "db.listings_limpio.insertOne({script: new Code('function() { return 42; }')})",
        "option_c": "db.listings_limpio.insertOne({script: 'function() { return 42; }'})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "MongoDB no permite almacenar código JavaScript",
        "correct_answer": "d",
        "explanation": "BSON Code permite almacenar código JavaScript. Sintaxis: Code('codigo') o new Code('codigo'). Usado raramente, principalmente para funciones MapReduce o stored procedures. Por seguridad, no es común almacenar código en docs de aplicación.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite de anidamiento (nesting) de documentos en MongoDB?",
        "option_a": "10 niveles",
        "option_b": "50 niveles",
        "option_c": "100 niveles",
        "option_d": "No hay límite específico, pero está limitado por el tamaño máximo de 16MB",
        "option_e": "MongoDB no permite documentos anidados",
        "correct_answer": "d",
        "explanation": "MongoDB no tiene límite explícito de niveles de anidamiento, pero está limitado por el tamaño máximo de documento (16MB) y consideraciones prácticas. Anidamiento excesivo complica consultas y actualizaciones. Generalmente se recomienda mantener estructura simple.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas múltiples documentos asegurando atomicidad en MongoDB 4.0+?",
        "option_a": "db.coleccion.insertMany([...], {atomic: true})",
        "option_b": "Usar sesión con transacción: session.withTransaction(() => { db.col.insertMany([...]) })",
        "option_c": "db.coleccion.transaction.insertMany([...])",
        "option_d": "insertMany() es atómico por defecto",
        "option_e": "No es posible atomicidad en MongoDB",
        "correct_answer": "b",
        "explanation": "MongoDB 4.0+ soporta transacciones multi-documento. Para atomicidad en múltiples operaciones, usa sesiones con transacciones. insertMany() de por sí no es una transacción (aunque cada insertOne() dentro es atómico). Para atomicidad total necesitas transacciones explícitas.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'upsert' y cuándo se usa con operaciones de inserción?",
        "option_a": "Un tipo especial de índice",
        "option_b": "Una operación que inserta si no existe o actualiza si existe",
        "option_c": "Un método de compresión",
        "option_d": "Una validación de esquema",
        "option_e": "insertOne() siempre hace upsert",
        "correct_answer": "b",
        "explanation": "Upsert (update + insert) inserta un documento si no existe o lo actualiza si existe. No está disponible en insertOne(), pero sí en updateOne/updateMany con opción {upsert: true}. Útil para operaciones idempotentes o cuando no sabes si el documento existe.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo insertas un documento con el _id como string UUID?",
        "option_a": "db.data_act_01_limpio.insertOne({_id: UUID()})",
        "option_b": "db.data_act_01_limpio.insertOne({_id: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'})",
        "option_c": "db.data_act_01_limpio.insertOne({_id: new UUID('a1b2c3d4-e5f6-7890-abcd-ef1234567890')})",
        "option_d": "db.data_act_01_limpio.insertOne({_id: GUID('a1b2c3d4-e5f6-7890-abcd-ef1234567890')})",
        "option_e": "Opciones b y c son posibles",
        "correct_answer": "e",
        "explanation": "El _id puede ser cualquier tipo BSON excepto arrays. Puedes usar string UUID: {_id: 'uuid-string'} o BSON UUID: {_id: UUID('...')} (en drivers que lo soporten). La mayoría usa ObjectId por defecto, pero UUIDs son válidos si necesitas compatibilidad con otros sistemas.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es la 'write performance' vs 'read performance' en el diseño de esquema?",
        "option_a": "Son lo mismo",
        "option_b": "Documentos embebidos optimizan lecturas; normalización con referencias optimiza escrituras",
        "option_c": "Write performance siempre es más importante",
        "option_d": "MongoDB optimiza ambos automáticamente",
        "option_e": "El esquema no afecta el performance",
        "correct_answer": "b",
        "explanation": "Trade-off de diseño: documentos embebidos optimizan lecturas (un solo query) pero ralentizan escrituras (documentos más grandes). Referencias optimizan escrituras (docs pequeños) pero requieren múltiples queries ($lookup). Diseña según tu patrón de acceso dominante.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento y obtienes el _id generado inmediatamente?",
        "option_a": "const result = db.coleccion.insertOne({...}); const id = result.insertedId;",
        "option_b": "const id = db.coleccion.insertOne({...}).getId();",
        "option_c": "db.coleccion.insertOne({...}, {returnId: true});",
        "option_d": "const id = db.coleccion.insertOne({...})._id;",
        "option_e": "No es posible obtener el _id inmediatamente",
        "correct_answer": "a",
        "explanation": "insertOne() retorna un objeto con la propiedad 'insertedId' que contiene el _id del documento insertado. Accedes con result.insertedId. Si no especificaste _id, será el ObjectId generado automáticamente por MongoDB.",
        "difficulty": "easy"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Por qué MongoDB genera ObjectIds únicos globalmente sin coordinación central?",
        "option_a": "Usa un servidor central para generar IDs",
        "option_b": "ObjectId incluye timestamp, identificador de máquina y contador, garantizando unicidad",
        "option_c": "Usa números aleatorios",
        "option_d": "Solo es único dentro de una colección",
        "option_e": "Requiere sincronización entre nodos",
        "correct_answer": "b",
        "explanation": "ObjectId (12 bytes): 4 bytes timestamp + 5 bytes identificador de proceso/máquina + 3 bytes contador incremental. Esta estructura garantiza unicidad global sin coordinación entre nodos, esencial para sistemas distribuidos. Permite generación local rápida.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo insertas 3 vuelos usando una sola llamada bulkWrite con manejo de errores?",
        "option_a": "db.infovuelos_limpio.bulkWrite([{insertOne: {document: {...}}}, {...}, {...}], {ordered: false})",
        "option_b": "db.infovuelos_limpio.bulkWrite([{insert: {...}}, {...}, {...}])",
        "option_c": "db.infovuelos_limpio.insertMany([{...}, {...}, {...}])",
        "option_d": "db.infovuelos_limpio.bulkInsert([{...}, {...}, {...}])",
        "option_e": "Opciones a y c son correctas",
        "correct_answer": "e",
        "explanation": "Tanto bulkWrite() con insertOne operations como insertMany() sirven. bulkWrite() es más flexible (puede mezclar operaciones). {ordered: false} hace que continúe insertando si uno falla. insertMany() con {ordered: false} tiene el mismo comportamiento.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'document validation' en MongoDB y cómo afecta a insertOne()?",
        "option_a": "MongoDB no soporta validación",
        "option_b": "Puedes definir reglas de validación con $jsonSchema que rechazan documentos que no cumplen",
        "option_c": "Validación automática de tipos de datos",
        "option_d": "Solo valida el _id",
        "option_e": "Validación solo en el cliente",
        "correct_answer": "b",
        "explanation": "Desde MongoDB 3.6+, puedes definir validación de esquema con $jsonSchema al crear la colección. insertOne() rechaza documentos que no cumplen el schema. Puedes especificar validationLevel (strict/moderate) y validationAction (error/warn). Útil para integridad de datos.",
        "difficulty": "hard"
    },
    {
        "category_id": 2,
        "question_type": "syntax",
        "question_text": "¿Cómo insertas un documento especificando el comportamiento ante conflictos de _id duplicado en bulkWrite?",
        "option_a": "bulkWrite([...], {continueOnError: true})",
        "option_b": "bulkWrite([...], {ordered: false})",
        "option_c": "bulkWrite([...], {skipDuplicates: true})",
        "option_d": "bulkWrite([...], {ignoreErrors: true})",
        "option_e": "No es posible, siempre falla con duplicados",
        "correct_answer": "b",
        "explanation": "Con {ordered: false}, bulkWrite() continúa procesando operaciones posteriores incluso si algunas fallan por _id duplicado. {ordered: true} (default) se detiene en el primer error. Los errores se reportan en el resultado, pero las operaciones exitosas se completan.",
        "difficulty": "medium"
    },
    {
        "category_id": 2,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el límite de operaciones en un solo bulkWrite()?",
        "option_a": "100 operaciones",
        "option_b": "1,000 operaciones",
        "option_c": "100,000 operaciones",
        "option_d": "1,000,000 operaciones",
        "option_e": "No hay límite explícito, pero está limitado por el tamaño de mensaje de 48MB",
        "correct_answer": "e",
        "explanation": "No hay límite explícito en número de operaciones, pero el tamaño total del mensaje está limitado a 48MB (maxMessageSizeBytes). Para grandes volúmenes, divide en múltiples bulkWrite(). MongoDB procesa en batches internos de 1000 operaciones.",
        "difficulty": "hard"
    },

    # ==================== CATEGORÍA 3: CRUD - READ ====================
    # Preguntas 91-100 (10 de 80 totales)

    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cuál es la sintaxis correcta para encontrar todos los documentos de una colección?",
        "option_a": "db.coleccion.findAll()",
        "option_b": "db.coleccion.find()",
        "option_c": "db.coleccion.select()",
        "option_d": "SELECT * FROM coleccion",
        "option_e": "db.coleccion.getAll()",
        "correct_answer": "b",
        "explanation": "db.coleccion.find() sin parámetros retorna todos los documentos de la colección (equivalente a SELECT * en SQL). Retorna un cursor que puedes iterar. Para limitar resultados usa .limit(n). findAll() y getAll() no existen en MongoDB.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras un único documento en MongoDB?",
        "option_a": "db.coleccion.find().one()",
        "option_b": "db.coleccion.findOne()",
        "option_c": "db.coleccion.find().first()",
        "option_d": "db.coleccion.getSingle()",
        "option_e": "db.coleccion.find().limit(1)",
        "correct_answer": "b",
        "explanation": "findOne() retorna el primer documento que coincide con el filtro (o null si no hay coincidencias). No retorna un cursor, retorna el documento directamente. find().limit(1) retorna un cursor con un doc, no es lo mismo.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo encuentras todos los vuelos con origen 'Madrid'?",
        "option_a": "db.infovuelos_limpio.find({origen: 'Madrid'})",
        "option_b": "db.infovuelos_limpio.find({origen = 'Madrid'})",
        "option_c": "db.infovuelos_limpio.find(origen: 'Madrid')",
        "option_d": "db.infovuelos_limpio.find('origen', 'Madrid')",
        "option_e": "db.infovuelos_limpio.where({origen: 'Madrid'})",
        "correct_answer": "a",
        "explanation": "La sintaxis correcta es find({campo: valor}). El filtro es un objeto JavaScript con pares clave-valor. MongoDB busca documentos donde el campo 'origen' sea exactamente 'Madrid' (case-sensitive). where() no existe en MongoDB.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras documentos donde un campo específico existe?",
        "option_a": "db.coleccion.find({campo: {$exists: true}})",
        "option_b": "db.coleccion.find({campo: {$notNull: true}})",
        "option_c": "db.coleccion.find({campo: EXISTS})",
        "option_d": "db.coleccion.find({campo: IS NOT NULL})",
        "option_e": "db.coleccion.find({$has: 'campo'})",
        "correct_answer": "a",
        "explanation": "El operador $exists verifica si un campo existe en el documento. {campo: {$exists: true}} encuentra docs con el campo (incluso si es null). {$exists: false} encuentra docs sin el campo. Diferente de {campo: {$ne: null}} que excluye null.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo encuentras listings con precio mayor a 100?",
        "option_a": "db.listings_limpio.find({precio: {$gt: 100}})",
        "option_b": "db.listings_limpio.find({precio > 100})",
        "option_c": "db.listings_limpio.find({precio: '> 100'})",
        "option_d": "db.listings_limpio.find({precio: {gt: 100}})",
        "option_e": "db.listings_limpio.find().where(precio > 100)",
        "correct_answer": "a",
        "explanation": "El operador $gt (greater than) compara valores numéricos: {campo: {$gt: valor}}. Otros operadores: $lt (menor), $gte (mayor o igual), $lte (menor o igual), $eq (igual), $ne (diferente). No uses sintaxis tipo SQL.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo encuentras documentos donde un campo está en un conjunto de valores?",
        "option_a": "db.coleccion.find({campo: {$in: ['valor1', 'valor2', 'valor3']}})",
        "option_b": "db.coleccion.find({campo: ['valor1', 'valor2', 'valor3']})",
        "option_c": "db.coleccion.find({campo IN ('valor1', 'valor2', 'valor3')})",
        "option_d": "db.coleccion.find({campo: {$or: ['valor1', 'valor2', 'valor3']}})",
        "option_e": "db.coleccion.find({campo: {$anyOf: ['valor1', 'valor2', 'valor3']}})",
        "correct_answer": "a",
        "explanation": "El operador $in busca documentos donde el campo coincide con cualquier valor del array: {campo: {$in: [valores]}}. Es equivalente a múltiples $or pero más eficiente. $nin es el opuesto (not in).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo combinas múltiples condiciones con AND en una consulta?",
        "option_a": "db.coleccion.find({campo1: valor1, campo2: valor2})",
        "option_b": "db.coleccion.find({$and: [{campo1: valor1}, {campo2: valor2}]})",
        "option_c": "db.coleccion.find({campo1: valor1 AND campo2: valor2})",
        "option_d": "Tanto a como b son correctas",
        "option_e": "db.coleccion.find({campo1: valor1}).and({campo2: valor2})",
        "correct_answer": "d",
        "explanation": "Por defecto, múltiples campos en el filtro son AND implícito: {a: 1, b: 2}. También puedes usar $and explícito: {$and: [{a: 1}, {b: 2}]}. $and explícito es necesario cuando necesitas múltiples condiciones en el mismo campo.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo encuentras documentos donde precio está entre 50 y 100?",
        "option_a": "db.data_act_01_limpio.find({precio: {$gte: 50, $lte: 100}})",
        "option_b": "db.data_act_01_limpio.find({precio: {$between: [50, 100]}})",
        "option_c": "db.data_act_01_limpio.find({precio BETWEEN 50 AND 100})",
        "option_d": "db.data_act_01_limpio.find({precio: {$range: [50, 100]}})",
        "option_e": "db.data_act_01_limpio.find({$and: [{precio: {$gte: 50}}, {precio: {$lte: 100}}]})",
        "correct_answer": "a",
        "explanation": "Combina $gte y $lte en el mismo campo: {campo: {$gte: min, $lte: max}}. MongoDB permite múltiples operadores en el mismo campo. La opción 'e' también funciona pero 'a' es más concisa. No existe $between en MongoDB.",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo limitas el número de resultados retornados?",
        "option_a": "db.coleccion.find().limit(10)",
        "option_b": "db.coleccion.find({}, {limit: 10})",
        "option_c": "db.coleccion.find().take(10)",
        "option_d": "db.coleccion.find({$limit: 10})",
        "option_e": "db.coleccion.find().max(10)",
        "correct_answer": "a",
        "explanation": "El método .limit(n) limita el número de documentos retornados por el cursor. Es un método de cursor, no parte del filtro. Ejemplo: find({...}).limit(10). Útil para paginación junto con .skip(). limit() debe ser después de find().",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo saltas los primeros N documentos en los resultados?",
        "option_a": "db.coleccion.find().skip(N)",
        "option_b": "db.coleccion.find().offset(N)",
        "option_c": "db.coleccion.find({$skip: N})",
        "option_d": "db.coleccion.find().ignore(N)",
        "option_e": "db.coleccion.find({}, {skip: N})",
        "correct_answer": "a",
        "explanation": "El método .skip(n) salta los primeros n documentos del resultado. Usado con .limit() para paginación: find().skip(pagina * tamaño).limit(tamaño). ADVERTENCIA: skip() es lento con valores grandes porque MongoDB debe recorrer los documentos saltados.",
        "difficulty": "easy"
    }
]

# Total Batch 2: 50 preguntas
# Categoría 2 (CRUD - Create): 40 preguntas (completando las 60 totales) ✅
# Categoría 3 (CRUD - Read): 10 de 80 preguntas

# ==================== BATCH 3: Preguntas 101-150 ====================
# Categoría 3: CRUD - Read (50 preguntas adicionales)

QUESTIONS_BATCH_3 = [
    # ==================== CATEGORÍA 3: CRUD - READ (continuación) ====================
    # Preguntas 101-150 (50 preguntas adicionales)

    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo ordenas los resultados por un campo en orden ascendente?",
        "option_a": "db.coleccion.find().sort({campo: 1})",
        "option_b": "db.coleccion.find().orderBy({campo: 'asc'})",
        "option_c": "db.coleccion.find().sort(campo, 1)",
        "option_d": "db.coleccion.find({}, {sort: {campo: 1}})",
        "option_e": "db.coleccion.find().ascending(campo)",
        "correct_answer": "a",
        "explanation": "El método .sort({campo: 1}) ordena en orden ascendente (1) o descendente (-1). Es un método de cursor. Ejemplo: find().sort({precio: 1}) ordena por precio de menor a mayor. Puedes ordenar por múltiples campos: sort({campo1: 1, campo2: -1}).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo ordenas los vuelos por precio de mayor a menor?",
        "option_a": "db.infovuelos_limpio.find().sort({precio: -1})",
        "option_b": "db.infovuelos_limpio.find().sort({precio: 'desc'})",
        "option_c": "db.infovuelos_limpio.find().sort({precio: 1})",
        "option_d": "db.infovuelos_limpio.find().orderBy({precio: -1})",
        "option_e": "db.infovuelos_limpio.find().descending('precio')",
        "correct_answer": "a",
        "explanation": "sort({campo: -1}) ordena en orden descendente (de mayor a menor). -1 significa descendente, 1 significa ascendente. Para precios de mayor a menor usa -1. sort() se encadena después de find().",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo cuentas el número total de documentos en una colección?",
        "option_a": "db.coleccion.count()",
        "option_b": "db.coleccion.countDocuments({})",
        "option_c": "db.coleccion.size()",
        "option_d": "db.coleccion.length()",
        "option_e": "db.coleccion.total()",
        "correct_answer": "b",
        "explanation": "countDocuments({}) es el método moderno para contar documentos. count() está deprecado. countDocuments({filtro}) cuenta docs que coinciden con el filtro. Para estimación rápida usa estimatedDocumentCount() (sin filtro, usa metadatos).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo seleccionas solo ciertos campos en los resultados (proyección)?",
        "option_a": "db.coleccion.find({}, {campo1: 1, campo2: 1})",
        "option_b": "db.coleccion.find().select('campo1', 'campo2')",
        "option_c": "db.coleccion.find({fields: ['campo1', 'campo2']})",
        "option_d": "db.coleccion.find().only(['campo1', 'campo2'])",
        "option_e": "SELECT campo1, campo2 FROM coleccion",
        "correct_answer": "a",
        "explanation": "La proyección se especifica como segundo parámetro de find(): find({filtro}, {proyección}). {campo: 1} incluye el campo, {campo: 0} lo excluye. _id se incluye por defecto, usa {_id: 0} para excluirlo. No puedes mezclar inclusiones y exclusiones excepto con _id.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo obtienes solo el nombre y precio, sin el _id?",
        "option_a": "db.listings_limpio.find({}, {nombre: 1, precio: 1, _id: 0})",
        "option_b": "db.listings_limpio.find({}, {nombre: true, precio: true, _id: false})",
        "option_c": "db.listings_limpio.find().select('nombre', 'precio')",
        "option_d": "db.listings_limpio.find({fields: {nombre: 1, precio: 1}})",
        "option_e": "db.listings_limpio.find({}, {_id: 0}).only(['nombre', 'precio'])",
        "correct_answer": "a",
        "explanation": "Proyección con {campo: 1} incluye campos específicos. _id se incluye automáticamente, para excluirlo usa {_id: 0}. Sintaxis: find({}, {campo1: 1, campo2: 1, _id: 0}). Solo valores 1 y 0 son válidos en proyecciones (no true/false).",
        "difficulty": "medium",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo usas OR para buscar documentos que cumplan al menos una de varias condiciones?",
        "option_a": "db.coleccion.find({$or: [{condicion1}, {condicion2}]})",
        "option_b": "db.coleccion.find({condicion1 OR condicion2})",
        "option_c": "db.coleccion.find({condicion1}).or({condicion2})",
        "option_d": "db.coleccion.find({$any: [{condicion1}, {condicion2}]})",
        "option_e": "db.coleccion.find().or([{condicion1}, {condicion2}])",
        "correct_answer": "a",
        "explanation": "El operador $or toma un array de condiciones: {$or: [{cond1}, {cond2}, ...]}. Retorna documentos que cumplen al menos una condición. Ejemplo: {$or: [{precio: {$lt: 50}}, {categoria: 'oferta'}]}. Puede combinarse con otras condiciones.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo encuentras vuelos con origen 'Madrid' O destino 'Barcelona'?",
        "option_a": "db.infovuelos_limpio.find({$or: [{origen: 'Madrid'}, {destino: 'Barcelona'}]})",
        "option_b": "db.infovuelos_limpio.find({origen: 'Madrid', destino: 'Barcelona'})",
        "option_c": "db.infovuelos_limpio.find({origen: 'Madrid' OR destino: 'Barcelona'})",
        "option_d": "db.infovuelos_limpio.find({$any: {origen: 'Madrid', destino: 'Barcelona'}})",
        "option_e": "db.infovuelos_limpio.find().or({origen: 'Madrid'}, {destino: 'Barcelona'})",
        "correct_answer": "a",
        "explanation": "Usa $or con array de condiciones: {$or: [{campo1: valor1}, {campo2: valor2}]}. Sin $or (opción b) sería AND (ambas condiciones simultáneamente). $or permite condiciones independientes.",
        "difficulty": "easy",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo niegas una condición en MongoDB?",
        "option_a": "db.coleccion.find({campo: {$not: {$gt: 100}}})",
        "option_b": "db.coleccion.find({NOT campo: {$gt: 100}})",
        "option_c": "db.coleccion.find({campo: {!$gt: 100}})",
        "option_d": "db.coleccion.find().not({campo: {$gt: 100}})",
        "option_e": "db.coleccion.find({campo: {$ne: {$gt: 100}}})",
        "correct_answer": "a",
        "explanation": "$not niega una expresión: {campo: {$not: {operador: valor}}}. Ejemplo: {edad: {$not: {$gt: 18}}} encuentra personas con edad <= 18. $not funciona con operadores de comparación. Para negar igualdad simple usa $ne.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo NO está en un conjunto de valores?",
        "option_a": "db.coleccion.find({campo: {$nin: ['valor1', 'valor2']}})",
        "option_b": "db.coleccion.find({campo: {$not: {$in: ['valor1', 'valor2']}}})",
        "option_c": "db.coleccion.find({campo: {$notIn: ['valor1', 'valor2']}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find({campo NOT IN ['valor1', 'valor2']})",
        "correct_answer": "d",
        "explanation": "$nin (not in) es el opuesto de $in: {campo: {$nin: [valores]}}. También puedes usar {campo: {$not: {$in: [valores]}}} que es equivalente. $nin es más directo y preferido. Ambos excluyen documentos con el campo en el array.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo consultas un campo anidado usando dot notation?",
        "option_a": "db.coleccion.find({'direccion.ciudad': 'Madrid'})",
        "option_b": "db.coleccion.find({direccion: {ciudad: 'Madrid'}})",
        "option_c": "db.coleccion.find({direccion.ciudad: 'Madrid'})",
        "option_d": "db.coleccion.find({direccion->ciudad: 'Madrid'})",
        "option_e": "db.coleccion.find({direccion[ciudad]: 'Madrid'})",
        "correct_answer": "a",
        "explanation": "Dot notation con comillas: {'campo.subcampo': valor}. Las comillas son necesarias por el punto. Opción b buscaría un documento con SOLO el campo ciudad (match exacto del objeto completo). Dot notation permite consultar campos anidados específicos.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, si la ubicación es {ciudad: 'Madrid', barrio: 'Centro'}, ¿cómo buscas por barrio?",
        "option_a": "db.listings_limpio.find({'ubicacion.barrio': 'Centro'})",
        "option_b": "db.listings_limpio.find({ubicacion: {barrio: 'Centro'}})",
        "option_c": "db.listings_limpio.find({ubicacion.barrio: 'Centro'})",
        "option_d": "db.listings_limpio.find({ubicacion: {'barrio': 'Centro'}})",
        "option_e": "db.listings_limpio.find({ubicacion[barrio]: 'Centro'})",
        "correct_answer": "a",
        "explanation": "Usa dot notation con comillas: {'objeto.campo': valor}. Esto busca en el subcampo sin requerir match exacto del objeto completo. Opción b requeriría que ubicacion sea exactamente {barrio: 'Centro'}, sin ciudad ni otros campos.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo consultas elementos específicos de un array por posición?",
        "option_a": "db.coleccion.find({'array.0': 'valor'})",
        "option_b": "db.coleccion.find({array[0]: 'valor'})",
        "option_c": "db.coleccion.find({array: {$index: 0, $value: 'valor'}})",
        "option_d": "db.coleccion.find({array: {0: 'valor'}})",
        "option_e": "db.coleccion.find({array.at(0): 'valor'})",
        "correct_answer": "a",
        "explanation": "Usa dot notation con índice: {'array.0': valor} busca en el primer elemento, {'array.1': valor} en el segundo, etc. Los índices comienzan en 0. Las comillas son necesarias. Útil cuando conoces la posición exacta del elemento.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un array contiene un valor específico?",
        "option_a": "db.coleccion.find({tags: 'valor'})",
        "option_b": "db.coleccion.find({tags: {$contains: 'valor'}})",
        "option_c": "db.coleccion.find({tags: {$in: ['valor']}})",
        "option_d": "Opciones a y c son correctas",
        "option_e": "db.coleccion.find({tags: {$has: 'valor'}})",
        "correct_answer": "d",
        "explanation": "Para buscar un valor en un array, simplemente usa {array: valor}. MongoDB automáticamente busca en el array. También puedes usar {array: {$in: [valor]}} que es equivalente. Ambas sintaxis funcionan correctamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un array contiene TODOS los valores especificados?",
        "option_a": "db.coleccion.find({tags: {$all: ['valor1', 'valor2']}})",
        "option_b": "db.coleccion.find({tags: ['valor1', 'valor2']})",
        "option_c": "db.coleccion.find({tags: {$containsAll: ['valor1', 'valor2']}})",
        "option_d": "db.coleccion.find({tags: {$and: ['valor1', 'valor2']}})",
        "option_e": "db.coleccion.find({tags: {$in: ['valor1', 'valor2']}})",
        "correct_answer": "a",
        "explanation": "$all requiere que el array contenga TODOS los valores especificados (pero puede tener otros): {array: {$all: [v1, v2]}}. Opción b buscaría un array exactamente igual. $in busca al menos uno. $all es AND, $in es OR.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, si escalas es un array, ¿cómo buscas vuelos con escalas en 'MAD' Y 'BCN'?",
        "option_a": "db.infovuelos_limpio.find({escalas: {$all: ['MAD', 'BCN']}})",
        "option_b": "db.infovuelos_limpio.find({escalas: ['MAD', 'BCN']})",
        "option_c": "db.infovuelos_limpio.find({escalas: {$in: ['MAD', 'BCN']}})",
        "option_d": "db.infovuelos_limpio.find({escalas: 'MAD', escalas: 'BCN'})",
        "option_e": "db.infovuelos_limpio.find({escalas: {$and: ['MAD', 'BCN']}})",
        "correct_answer": "a",
        "explanation": "$all garantiza que el array contenga ambos valores: {escalas: {$all: ['MAD', 'BCN']}}. El orden no importa y puede haber otros valores. Opción b requiere array exacto. $in busca al menos uno, no ambos.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un array tiene un tamaño específico?",
        "option_a": "db.coleccion.find({array: {$size: 3}})",
        "option_b": "db.coleccion.find({array: {$length: 3}})",
        "option_c": "db.coleccion.find({array.length: 3})",
        "option_d": "db.coleccion.find({$where: 'this.array.length == 3'})",
        "option_e": "Opciones a y d son correctas",
        "correct_answer": "e",
        "explanation": "$size busca arrays con longitud exacta: {array: {$size: n}}. LIMITACIÓN: $size no soporta rangos, solo valores exactos. $where permite JavaScript pero es más lento. Para rangos de tamaño, almacena un campo de contador separado.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un elemento de un array de objetos cumple múltiples condiciones?",
        "option_a": "db.coleccion.find({array: {$elemMatch: {campo1: valor1, campo2: valor2}}})",
        "option_b": "db.coleccion.find({'array.campo1': valor1, 'array.campo2': valor2})",
        "option_c": "db.coleccion.find({array: {campo1: valor1, campo2: valor2}})",
        "option_d": "db.coleccion.find({$and: [{'array.campo1': valor1}, {'array.campo2': valor2}]})",
        "option_e": "db.coleccion.find({array: {$match: {campo1: valor1, campo2: valor2}}})",
        "correct_answer": "a",
        "explanation": "$elemMatch asegura que UN MISMO elemento del array cumpla todas las condiciones: {array: {$elemMatch: {cond1, cond2}}}. Sin $elemMatch (opción b/d), las condiciones pueden cumplirse en diferentes elementos del array, dando resultados incorrectos.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio con array reviews: [{autor: 'Juan', rating: 5}, {autor: 'Ana', rating: 3}], ¿cómo buscas listings con una review de 'Juan' con rating 5?",
        "option_a": "db.listings_limpio.find({reviews: {$elemMatch: {autor: 'Juan', rating: 5}}})",
        "option_b": "db.listings_limpio.find({'reviews.autor': 'Juan', 'reviews.rating': 5})",
        "option_c": "db.listings_limpio.find({reviews: {autor: 'Juan', rating: 5}})",
        "option_d": "db.listings_limpio.find({$and: [{'reviews.autor': 'Juan'}, {'reviews.rating': 5}]})",
        "option_e": "Opciones a y b son correctas",
        "correct_answer": "a",
        "explanation": "$elemMatch es necesario para asegurar que ambas condiciones se cumplan en el MISMO elemento del array. Opción b podría coincidir si un elemento tiene autor: 'Juan' y OTRO elemento tiene rating: 5, lo cual es incorrecto.",
        "difficulty": "hard",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos usando expresiones regulares?",
        "option_a": "db.coleccion.find({campo: {$regex: /patron/i}})",
        "option_b": "db.coleccion.find({campo: {$regex: 'patron', $options: 'i'}})",
        "option_c": "db.coleccion.find({campo: /patron/i})",
        "option_d": "Todas las opciones anteriores son correctas",
        "option_e": "db.coleccion.find({campo LIKE '%patron%'})",
        "correct_answer": "d",
        "explanation": "MongoDB soporta tres sintaxis de regex: 1) $regex con regex literal: {$regex: /pattern/flags}, 2) $regex con string y $options: {$regex: 'pattern', $options: 'i'}, 3) regex directo: campo: /pattern/flags. Todas son válidas.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo buscas documentos donde nombre empieza con 'Mar' (case-insensitive)?",
        "option_a": "db.data_act_01_limpio.find({nombre: {$regex: /^Mar/i}})",
        "option_b": "db.data_act_01_limpio.find({nombre: {$regex: '^Mar', $options: 'i'}})",
        "option_c": "db.data_act_01_limpio.find({nombre: /^Mar/i})",
        "option_d": "Todas las opciones anteriores son correctas",
        "option_e": "db.data_act_01_limpio.find({nombre: {$startsWith: 'Mar'}})",
        "correct_answer": "d",
        "explanation": "^ indica inicio de string. Flag 'i' hace case-insensitive. Todas las sintaxis de regex son válidas. $startsWith no existe en MongoDB. Regex es poderoso pero puede ser lento sin índice apropiado (use índice text para búsquedas complejas).",
        "difficulty": "medium",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuál es el operador $nor?",
        "option_a": "Busca documentos que NO cumplen NINGUNA de las condiciones",
        "option_b": "Busca documentos que cumplen todas las condiciones",
        "option_c": "Es lo mismo que $not",
        "option_d": "Normaliza los resultados",
        "option_e": "No existe en MongoDB",
        "correct_answer": "a",
        "explanation": "$nor es el opuesto de $or: {$nor: [{cond1}, {cond2}]} retorna docs que NO cumplen NINGUNA condición (ni cond1 ni cond2). Es como NOT (cond1 OR cond2) = (NOT cond1) AND (NOT cond2). Útil para exclusiones múltiples.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes los valores únicos de un campo en toda la colección?",
        "option_a": "db.coleccion.distinct('campo')",
        "option_b": "db.coleccion.find().distinct('campo')",
        "option_c": "db.coleccion.find({}, {campo: 1}).unique()",
        "option_d": "db.coleccion.unique('campo')",
        "option_e": "SELECT DISTINCT campo FROM coleccion",
        "correct_answer": "a",
        "explanation": "distinct('campo') retorna un array con valores únicos del campo. Sintaxis: db.coleccion.distinct('campo', {filtro_opcional}). Útil para obtener listas de valores posibles. Puede usarse con filtro como segundo parámetro.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo obtienes la lista de ciudades de origen únicas?",
        "option_a": "db.infovuelos_limpio.distinct('origen')",
        "option_b": "db.infovuelos_limpio.find({}, {origen: 1}).unique()",
        "option_c": "db.infovuelos_limpio.aggregate([{$group: {_id: '$origen'}}])",
        "option_d": "Opciones a y c son correctas",
        "option_e": "db.infovuelos_limpio.find().distinct('origen')",
        "correct_answer": "d",
        "explanation": "distinct('campo') es la forma más simple. También puedes usar aggregation con $group para valores únicos. distinct() es método de colección, no de cursor (no va después de find()). Ambos enfoques funcionan, distinct es más directo.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuál es la diferencia entre countDocuments() y estimatedDocumentCount()?",
        "option_a": "No hay diferencia",
        "option_b": "countDocuments() cuenta exacto con filtro; estimatedDocumentCount() es rápido pero aproximado sin filtro",
        "option_c": "estimatedDocumentCount() es más preciso",
        "option_d": "countDocuments() está deprecado",
        "option_e": "estimatedDocumentCount() soporta filtros",
        "correct_answer": "b",
        "explanation": "countDocuments({filtro}) cuenta documentos exactos que coinciden con el filtro (puede ser lento en colecciones grandes). estimatedDocumentCount() usa metadatos para estimación rápida de toda la colección (sin filtro, puede estar desactualizado). Elige según necesites precisión vs velocidad.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo verificas si un array está vacío en una consulta?",
        "option_a": "db.coleccion.find({array: {$size: 0}})",
        "option_b": "db.coleccion.find({array: []})",
        "option_c": "db.coleccion.find({array: {$eq: []}})",
        "option_d": "Todas las opciones anteriores son correctas",
        "option_e": "db.coleccion.find({array: null})",
        "correct_answer": "d",
        "explanation": "Tres formas válidas: {array: {$size: 0}} cuenta elementos, {array: []} y {array: {$eq: []}} buscan match exacto con array vacío. Todas funcionan. {array: null} buscaría null, no array vacío (son diferentes).",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo combinas limit() y skip() para implementar paginación?",
        "option_a": "db.coleccion.find().skip(pagina * tamaño).limit(tamaño)",
        "option_b": "db.coleccion.find().limit(tamaño).skip(pagina * tamaño)",
        "option_c": "db.coleccion.find({}, {skip: pagina * tamaño, limit: tamaño})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find().page(pagina, tamaño)",
        "correct_answer": "d",
        "explanation": "El orden de skip() y limit() en el código no importa, MongoDB los aplica en el orden correcto (skip antes de limit). Para página 0: skip(0).limit(10), página 1: skip(10).limit(10), etc. NOTA: skip() es ineficiente para valores grandes.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo obtienes los 10 listings más caros?",
        "option_a": "db.listings_limpio.find().sort({precio: -1}).limit(10)",
        "option_b": "db.listings_limpio.find().limit(10).sort({precio: -1})",
        "option_c": "db.listings_limpio.find({}, {sort: {precio: -1}, limit: 10})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.listings_limpio.find().top(10, 'precio')",
        "correct_answer": "d",
        "explanation": "El orden de los métodos de cursor en el código no afecta la ejecución: MongoDB optimiza automáticamente. sort({precio: -1}) ordena descendente (mayor primero), limit(10) toma los primeros 10. Ambos órdenes de escritura son válidos.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es un cursor en MongoDB?",
        "option_a": "Un puntero de mouse",
        "option_b": "Un iterador que apunta a los resultados de una consulta",
        "option_c": "Un tipo de índice",
        "option_d": "Una variable de sesión",
        "option_e": "Un método de ordenamiento",
        "correct_answer": "b",
        "explanation": "find() retorna un cursor, no los documentos directamente. El cursor es un iterador sobre los resultados. En el shell, el cursor itera automáticamente mostrando hasta 20 docs. En drivers, debes iterar explícitamente. Los cursores permiten operaciones eficientes con grandes resultados.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo conviertes un cursor a un array en el shell?",
        "option_a": "db.coleccion.find().toArray()",
        "option_b": "db.coleccion.find().array()",
        "option_c": "Array.from(db.coleccion.find())",
        "option_d": "db.coleccion.find().collect()",
        "option_e": "db.coleccion.find().list()",
        "correct_answer": "a",
        "explanation": "El método .toArray() convierte un cursor en un array JavaScript con todos los documentos. PRECAUCIÓN: En colecciones grandes, esto puede consumir mucha memoria. Usa .toArray() solo cuando necesites todos los resultados en memoria simultáneamente.",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo es de un tipo específico?",
        "option_a": "db.coleccion.find({campo: {$type: 'string'}})",
        "option_b": "db.coleccion.find({campo: {$type: 2}})",
        "option_c": "db.coleccion.find({campo: {$instanceof: String}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find({typeof campo: 'string'})",
        "correct_answer": "d",
        "explanation": "$type filtra por tipo BSON: {campo: {$type: 'string'}} o {campo: {$type: 2}} (número de tipo BSON). Tipos comunes: 'string' (2), 'int' (16), 'long' (18), 'double' (1), 'array' (4), 'object' (3). Útil en esquemas flexibles.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo buscas documentos donde precio es un número (no string)?",
        "option_a": "db.data_act_01_limpio.find({precio: {$type: 'number'}})",
        "option_b": "db.data_act_01_limpio.find({precio: {$type: [1, 16, 18]}})",
        "option_c": "db.data_act_01_limpio.find({precio: {$type: 'double'}})",
        "option_d": "Opción b es la más correcta (incluye double, int, long)",
        "option_e": "db.data_act_01_limpio.find({precio: {$isNumeric: true}})",
        "correct_answer": "d",
        "explanation": "'number' no es un alias válido en $type. Los tipos numéricos BSON son: double (1), int (16), long (18), decimal (19). Para buscar cualquier número usa array: {$type: [1, 16, 18, 19]}. Esto captura todos los tipos numéricos.",
        "difficulty": "hard",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos con texto en un campo usando búsqueda de texto completo?",
        "option_a": "db.coleccion.find({$text: {$search: 'palabra clave'}})",
        "option_b": "db.coleccion.find({campo: {$contains: 'texto'}})",
        "option_c": "db.coleccion.find({campo: {$fulltext: 'texto'}})",
        "option_d": "db.coleccion.fullTextSearch('texto')",
        "option_e": "db.coleccion.find({campo MATCH 'texto'})",
        "correct_answer": "a",
        "explanation": "$text requiere un índice de texto previamente creado: db.coleccion.createIndex({campo: 'text'}). Luego usa {$text: {$search: 'términos'}}. Soporta búsqueda de palabras, frases (con comillas), y negación (con -). Más eficiente que regex para búsquedas de texto.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es mejor para búsquedas de texto: $regex o $text?",
        "option_a": "$regex siempre es mejor",
        "option_b": "$text es mejor para búsqueda de palabras completas en lenguaje natural; $regex para patrones exactos",
        "option_c": "Son equivalentes",
        "option_d": "$text no existe",
        "option_e": "$regex es más rápido",
        "correct_answer": "b",
        "explanation": "$text (con índice text) es optimizado para búsqueda de palabras, soporta stemming, stop words, y puntuación de relevancia. $regex es para patrones exactos pero puede ser lento sin índice. Para búsqueda en lenguaje natural usa $text, para patrones específicos usa $regex.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo contiene null O no existe?",
        "option_a": "db.coleccion.find({campo: null})",
        "option_b": "db.coleccion.find({campo: {$in: [null]}})",
        "option_c": "db.coleccion.find({$or: [{campo: null}, {campo: {$exists: false}}]})",
        "option_d": "Opciones a y b retornan documentos con null O sin el campo",
        "option_e": "db.coleccion.find({campo: {$eq: null, $exists: false}})",
        "correct_answer": "d",
        "explanation": "{campo: null} encuentra documentos donde el campo es null O no existe. Para buscar SOLO null (campo existe pero es null): {campo: {$type: 10}}. Para buscar SOLO campo inexistente: {campo: {$exists: false}}.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para infovuelos_limpio, ¿cómo buscas vuelos con precio entre 100 y 200, ordenados por fecha?",
        "option_a": "db.infovuelos_limpio.find({precio: {$gte: 100, $lte: 200}}).sort({fecha: 1})",
        "option_b": "db.infovuelos_limpio.find({$and: [{precio: {$gte: 100}}, {precio: {$lte: 200}}]}).sort({fecha: 1})",
        "option_c": "db.infovuelos_limpio.find({precio: {$between: [100, 200]}}).orderBy({fecha: 1})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.infovuelos_limpio.find().where(precio >= 100 && precio <= 200).sort({fecha: 1})",
        "correct_answer": "d",
        "explanation": "Ambas sintaxis son válidas. La opción 'a' es más concisa combinando operadores en el mismo campo. Opción 'b' usa $and explícito. sort({fecha: 1}) ordena ascendente por fecha. No existe $between ni .where() en MongoDB.",
        "difficulty": "medium",
        "dataset_reference": "infovuelos_limpio"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es un 'covered query' en MongoDB?",
        "option_a": "Una consulta encriptada",
        "option_b": "Una consulta que puede responderse completamente usando solo el índice, sin leer documentos",
        "option_c": "Una consulta con múltiples condiciones",
        "option_d": "Una consulta en una transacción",
        "option_e": "Una consulta con proyección",
        "correct_answer": "b",
        "explanation": "Un covered query es respondido completamente por el índice sin acceder a los documentos. Requisitos: 1) todos los campos consultados están en el índice, 2) todos los campos proyectados están en el índice, 3) _id no se proyecta (o está en índice). Muy rápido.",
        "difficulty": "hard"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo excluyes campos específicos de los resultados?",
        "option_a": "db.coleccion.find({}, {campo1: 0, campo2: 0})",
        "option_b": "db.coleccion.find({}, {campo1: false, campo2: false})",
        "option_c": "db.coleccion.find().exclude('campo1', 'campo2')",
        "option_d": "db.coleccion.find({}, {$exclude: ['campo1', 'campo2']})",
        "option_e": "db.coleccion.find().without(['campo1', 'campo2'])",
        "correct_answer": "a",
        "explanation": "Proyección de exclusión: {campo: 0} excluye campos. Puedes excluir múltiples campos: {campo1: 0, campo2: 0}. REGLA: No puedes mezclar inclusión (1) y exclusión (0) excepto con _id. Solo 0 y 1 son válidos (no false/true).",
        "difficulty": "easy"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para listings_limpio, ¿cómo obtienes todos los campos EXCEPTO las reviews?",
        "option_a": "db.listings_limpio.find({}, {reviews: 0})",
        "option_b": "db.listings_limpio.find({}, {reviews: false})",
        "option_c": "db.listings_limpio.find().exclude('reviews')",
        "option_d": "db.listings_limpio.find({}, {$not: 'reviews'})",
        "option_e": "db.listings_limpio.find().without('reviews')",
        "correct_answer": "a",
        "explanation": "Proyección de exclusión {reviews: 0} retorna todos los campos excepto reviews. Es más simple que listar todos los campos a incluir cuando solo quieres excluir pocos. MongoDB retorna todos los demás campos automáticamente.",
        "difficulty": "easy",
        "dataset_reference": "listings_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo limitas los elementos retornados de un array en la proyección?",
        "option_a": "db.coleccion.find({}, {array: {$slice: 5}})",
        "option_b": "db.coleccion.find({}, {array: {$limit: 5}})",
        "option_c": "db.coleccion.find({}, {'array.0-5': 1})",
        "option_d": "db.coleccion.find().slice('array', 5)",
        "option_e": "db.coleccion.find({}, {array: {$take: 5}})",
        "correct_answer": "a",
        "explanation": "$slice en proyección limita elementos del array: {array: {$slice: n}} retorna primeros n elementos. {$slice: -n} últimos n. {$slice: [skip, limit]} para rango. Útil para arrays grandes donde solo necesitas algunos elementos.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos donde un campo de fecha es posterior a una fecha específica?",
        "option_a": "db.coleccion.find({fecha: {$gt: new Date('2024-01-01')}})",
        "option_b": "db.coleccion.find({fecha: {$gt: ISODate('2024-01-01')}})",
        "option_c": "db.coleccion.find({fecha: {$after: '2024-01-01'}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.coleccion.find({fecha > '2024-01-01'})",
        "correct_answer": "d",
        "explanation": "Usa operadores de comparación con objetos Date: {fecha: {$gt: new Date('ISO8601')}} o ISODate('ISO8601') en shell. $gt funciona con fechas porque BSON Date es comparable. Asegúrate que el campo sea tipo Date, no string.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Por qué es importante que los campos de fecha se almacenen como BSON Date y no como strings?",
        "option_a": "Ocupan menos espacio",
        "option_b": "Permiten comparaciones cronológicas correctas y operaciones de fecha eficientes",
        "option_c": "Son más fáciles de leer",
        "option_d": "No hay diferencia práctica",
        "option_e": "Strings son mejores para fechas",
        "correct_answer": "b",
        "explanation": "BSON Date permite comparaciones cronológicas ($gt, $lt) y operaciones de fecha en agregación ($year, $month, etc.). Strings se comparan lexicográficamente (alfabéticamente), lo que falla con formatos como 'DD/MM/YYYY'. Usa siempre Date para timestamps y fechas.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "Para data_act_01_limpio, ¿cómo cuentas cuántos documentos tienen precio mayor a 50?",
        "option_a": "db.data_act_01_limpio.countDocuments({precio: {$gt: 50}})",
        "option_b": "db.data_act_01_limpio.find({precio: {$gt: 50}}).count()",
        "option_c": "db.data_act_01_limpio.count({precio: {$gt: 50}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "db.data_act_01_limpio.find({precio: {$gt: 50}}).length()",
        "correct_answer": "d",
        "explanation": "countDocuments({filtro}) es el método moderno recomendado. cursor.count() también funciona pero está deprecado en favor de countDocuments(). count() como método de colección está deprecado. length() no existe.",
        "difficulty": "easy",
        "dataset_reference": "data_act_01_limpio"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo obtienes un documento aleatorio de una colección?",
        "option_a": "db.coleccion.aggregate([{$sample: {size: 1}}])",
        "option_b": "db.coleccion.find().random()",
        "option_c": "db.coleccion.findOne().random()",
        "option_d": "db.coleccion.find().sort({$random: 1}).limit(1)",
        "option_e": "db.coleccion.getRandom()",
        "correct_answer": "a",
        "explanation": "$sample en aggregation retorna n documentos aleatorios: [{$sample: {size: n}}]. Es eficiente incluso en colecciones grandes. No hay método .random(). Para un documento aleatorio, $sample con size: 1 es la forma correcta.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Cuándo es más eficiente usar aggregation framework en lugar de find()?",
        "option_a": "Siempre usar aggregation",
        "option_b": "Para transformaciones complejas, agrupaciones, joins, y procesamiento de datos multi-etapa",
        "option_c": "find() siempre es más rápido",
        "option_d": "Solo para consultas de texto",
        "option_e": "No hay diferencia",
        "correct_answer": "b",
        "explanation": "Usa find() para consultas simples de lectura. Usa aggregation para: transformaciones de datos, agrupaciones ($group), joins ($lookup), cálculos complejos, pipelines multi-etapa. Aggregation es más poderoso pero con más overhead para consultas simples.",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "syntax",
        "question_text": "¿Cómo buscas documentos con múltiples condiciones en el mismo campo?",
        "option_a": "db.coleccion.find({precio: {$gte: 100, $lt: 200, $ne: 150}})",
        "option_b": "db.coleccion.find({$and: [{precio: {$gte: 100}}, {precio: {$lt: 200}}, {precio: {$ne: 150}}]})",
        "option_c": "db.coleccion.find({precio: {$gte: 100}, precio: {$lt: 200}, precio: {$ne: 150}})",
        "option_d": "Opciones a y b son correctas",
        "option_e": "No es posible",
        "correct_answer": "d",
        "explanation": "Puedes combinar múltiples operadores en el mismo campo: {campo: {$op1: v1, $op2: v2}}. MongoDB aplica AND implícito. También funciona con $and explícito. Opción c es inválida (solo la última clave 'precio' prevalecería en JavaScript).",
        "difficulty": "medium"
    },
    {
        "category_id": 3,
        "question_type": "conceptual",
        "question_text": "¿Qué es el 'explain' y para qué sirve en consultas?",
        "option_a": "Documenta la consulta",
        "option_b": "Muestra el plan de ejecución de la consulta, índices usados, y estadísticas de performance",
        "option_c": "Traduce la consulta a SQL",
        "option_d": "Valida la sintaxis",
        "option_e": "Formatea los resultados",
        "correct_answer": "b",
        "explanation": ".explain() muestra cómo MongoDB ejecuta la consulta: índices usados, documentos examinados, tiempo de ejecución. Modos: 'queryPlanner' (plan), 'executionStats' (estadísticas), 'allPlansExecution' (todos los planes). Esencial para optimizar queries.",
        "difficulty": "medium"
    }
]

# Total Batch 3: 50 preguntas
# Categoría 3 (CRUD - Read): 60 de 80 preguntas (10 del batch anterior + 50 de este batch)
